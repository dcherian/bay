#+TITLE: Bay of Bengal notes
#+SETUPFILE: ~/org/notebook.org

* Map
#+NAME: map
#+BEGIN_SRC ipython :session :results none
import bay

bay.make_labeled_map()
plt.gcf().set_size_inches((6, 8))
plt.savefig('../images/map.svg')
plt.savefig('../images/map.png', bbox_inches='tight')
#+END_SRC
#+CAPTION: χ-pod locations.
#+ATTR_HTML: :width 55%
[[file:images/map.png]]

#+BEGIN_SRC ipython :session :results none
import bay
pods = {
    'RAMA67':
        {'lon': 67, 'lat': 0, 'label': 'RAMA',
         'ha': 'center', 'va': 'bottom',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA80':
        {'lon': 80, 'lat': 0, 'label': 'RAMA',
         'ha': 'center', 'va': 'bottom',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA90':
        {'lon': 90, 'lat': 0, 'label': 'RAMA',
         'ha': 'left', 'va': 'center',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA4':
        {'lon': 90, 'lat': 4, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '45 m': ''}},
    'RAMA12':
        {'lon': 90, 'lat': 12, 'label': 'RAMA',
         'ha': 'center', 'va': 'top',
         'depths': {
             '15 m': '',
             '45 m': ''}},
    'RAMA15':
        {'lon': 90, 'lat': 15, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '15 m': '2018, 19',
             '30 m': '2018, 19',
             '45 m': '2018, 19',
             '55 m': '2018, 19',
             '65 m': '2018, 19'}},
}

ax, colors = bay.make_map(pods, DX=1, DY=1, add_year=False)

ax.set_xlim([65, 96])
ax.set_ylim([-2, 24])
ax.set_xticks([65, 67, 70, 75, 80, 85, 90, 95])
ax.set_yticks([0, 4, 8, 12, 15, 18, 20, 22, 24])

ax.set_title('MISOBOB $χ$pod deployments (2018, 19)')
plt.savefig('../images/map-misobob.svg')
plt.savefig('../images/map-misobob.png', bbox_inches='tight')
#+END_SRC
#+ATTR_HTML: :width 55%
[[file:images/map-misobob.png]]

** emily :noexport:
#+CAPTION: χpod locations for ASIRI/EBOB/MISOBOB
#+ATTR_HTML: :width 55%
[[file:../images/MixingmapASIRIPiston.png]]
* All χpods
** RAMA
#+ATTR_HTML: :class full-width
[[file:images/summary-RAMA-12N-2014.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-RAMA-12N-2015.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-RAMA-15N.png]]

** EBOB
#+ATTR_HTML: :class full-width
[[file:images/summary-NRL1.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL2.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL3.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL4.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL5.png]]

* vertical distribution of $K_T$
** Make plot
*** Merge together
#+CALL: read-all-moorings()
#+NAME: make-merged-KT
#+BEGIN_SRC ipython :session :results none
import bay

moorings = [ra12, ra15, nrl1, nrl3, nrl4, nrl5]
bay.make_merged_nc(moorings)

#KTm = xr.open_dataset('merged_KT.nc')
#ρbins = histedges_equalN(np.ravel(KTm.ρ), 11)
#Sbins = histedges_equalN(np.ravel(KTm.S), 11)

#KTdf = bin_and_to_dataframe(KTm, ρbins)
#+END_SRC
*** means/medians profile
#+NAME: vert-profile
#+BEGIN_SRC ipython :session :results none
import bay
bay = importlib.reload(bay)

moors = ['RAMA12', 'RAMA15', 'NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5']

bay.make_vert_distrib_plot('KT', label_moorings=True)
plt.savefig('images/vert-profile.svg', bbox_inches='tight')
plt.savefig('images/bay-KT-vert-profile.pdf', bbox_inches='tight')
plt.savefig('images/bay-KT-vert-profile.png', bbox_inches='tight')
#+END_SRC
#+ATTR_HTML: :class full-width
[[file:images/bay-KT-vert-profile.png]]

Some sensitivities:
1. Changing 505 to 'mmw': not much

2. High mixing at 70-100m depth in SW monsoon, compared to NE monsoon.
   1. Connected to SMC/SLD?
   2. Near-inertial waves from storms could be a thing
   3. Something happens in NRL5, around SW monsoon start to see temperature inversions semi-regularly (rare, but regular)

3. High values near surface are usually base of mixed layer/barrier layer χpods (527, 814)

4. 814 is crap: some changes moving distributions lower.

5. Changing 511 to mm2: quite a bit. Reduced the double peak stuff


#+NAME: save-distrib-for-each-mooring
#+BEGIN_SRC ipython :session :results none
import bay
bay = importlib.reload(bay)

bins = [1018, 1021, 1022, 1022.5, 1023, 1023.5, 1024.25, 1029]
moors = ['RAMA12', 'RAMA15', 'NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5']

for mm in moors:
    bay.make_vert_distrib_plot('KT', bins, mm)
    plt.gcf().suptitle(mm)
    plt.savefig('images/vert-profile-moor/'+mm+'.png', bbox_inches='tight')
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgrtIJ8z.png
season = 'SW'
bin_name = 24.0

ρmid = (KTdf.bin
        .apply(lambda x: x.mid-1000 if type(x) is not str else None))

if type(bin_name) is str:
    mask = KTdf.bin == bin_name
else:
    mask = (abs(ρmid - bin_name) < 0.2)

# mask = np.logical_and(mask, KTdf.season == season)
subset = KTdf[mask]
f, ax = vert_distrib(subset, subset.moor, varname='ρ')
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[702]:
:END:

#+NAME: sal-distrib
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgbp6rfN.png :results drawer
<<define-vert_distrib>>

Sbins = pd.qcut(KTdf.S, 11)

f, ax = plot_distrib(KTdf, bins, varname='S', xlines=[32, 35])
# plot_distrib(KTdf.where(KTdf.S > 34.9), bins, pal=[[0.5,0.5,0.5]]*13, f=f, ax=ax)
#+END_SRC
#+RESULTS: sal-distrib
:RESULTS:
[[file:images/temp/imgbp6rfN.png]]
:END:
*** full distrib seaborn
#+NAME: define-seaborn_vert_distrib
#+BEGIN_SRC ipython :session :results none
pal_dist = sns.color_palette("GnBu_d", n_colors=13)
pal_dist.reverse()

def seaborn_vert_distrib(KTdf, category, kind='kde'):
    stylekwargs = dict(style="ticks",
                       rc={'axes.facecolor': 'None',
                           'figure.facecolor': 'None'})
    bandwidth = 'scott'
    # pal_dist=sns.cubehelix_palette(11, rot=-.25, light=.7)
    # pal_dist = [pal_dist[0]]*13

    pal_boxplot = sns.color_palette("muted",
                                    n_colors=len(KTdf['latlon'].unique()))
    pal_boxplot[1] = (0,0,0)
    pal_boxdict = dict(zip(KTdf['latlon'].unique(), pal_boxplot))

    # pal = sns.cubehelix_palette(11, rot=-.25, light=0.7)

    def label(x, color, label):
        def stat_label(name, x, fmt, suffix=''):
            q75, q25 = np.percentile(x, [75, 25])
            return ((name+': {0:'+fmt+'}'+suffix
                     +', {1:'+fmt+'}'+suffix
                     +', {2:'+fmt+'}'+suffix)
                    .format(q25, x.mean(), q75))

        extract = KTdf.take(x.index)
        ax = plt.gca()
        label = float(label)
        if category == 'ρbinned':
            lab = (stat_label('S', extract.S, '.1f') + '\n'
                   + stat_label('z', extract.z, '.0f', 'm') + '\n'
                   +'σ: {0:2.1f}kg/m³'.format(label-1000))
        elif category == 'Sbinned':
            lab = '{0:2.1f}'.format(label)
        elif category == 'mean_depth':
            lab = '{0:.0f}m'.format(label)

        ax.text(1, 0.05, lab,
                color=(sns.light_palette((210, 90, 20), input="husl"))[3],
                fontsize=8,
                ha="right", va="bottom", transform=ax.transAxes)

    def mark_distributions_by_location(x, color, label):
        ax = plt.gca().twinx()
        gby = KTdf.take(x.index).groupby('latlon');

        for index, (name, grp) in enumerate(gby):
            props = {'linewidth': 1, 'color': pal_boxdict[name]}
            ax.boxplot(grp['KT'], vert=False, sym='', widths=0.08,
                       showbox=False,
                       showmeans=False, positions=[0.2+0.1*index],
                       boxprops={**props}, whiskerprops={**props},
                       medianprops={**props}, capprops={**props})

        ax.set_ylim([0, 2])
        ax.set_yticks([])

        # with sns.axes_style(**stylekwargs):
        #     sns.boxplot(data=KTdf.take(x.index), x='KT', hue='latlon',
        #                 ax=ax, orient='h', width=0.1)

    def mark_mean_mdn(x, color, label):
        ax = plt.gca()

        mean = np.log10(np.nanmean(10**x))
        median = np.log10(np.nanmedian(10**x))
        yloc = 0.5
        plt.plot(mean, yloc, color=color, marker='x')
        # plt.plot(mean, yloc, color='w', marker='x', fillstyle='none')
        plt.plot(median, yloc, color=color, marker='o', ms=10)
        plt.plot(median, yloc, color='w', marker='o', ms=11, fillstyle='none')

    with sns.axes_style(**stylekwargs):
        g = sns.FacetGrid(KTdf, row=category, col="season",
                          col_order=['NE', 'NESW', 'SW', 'SWNE'],
                          hue=category, xlim=[-7, 0],
                          sharex=True, sharey=True, palette=pal_dist,
                          aspect=4, size=1)


        kdekwargs = {'clip': [-8, 0],
                     'clip_on': False,
                     'cut': 0,
                     'bw': bandwidth}

        distkwargs = {'bins': 50, 'hist':True, 'rug':False, 'norm_hist':True,
                      'kde':False, 'kde_kws':{'lw': 1, **kdekwargs}}
        if kind == 'kde':
            g.map(sns.kdeplot, "KT", shade=True, alpha=0.6, lw=1.5, **kdekwargs)
            g.map(sns.kdeplot, "KT", color="w", lw=2, **kdekwargs)

        elif kind == 'dist':
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'alpha': 1})
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'histtype': 'step', 'color': 'w',
                            'lw': 1, 'alpha': 1})

        g.map(plt.axhline, y=0, lw=2, clip_on=False)

        g.map(label, "KT")
        g.map(mark_mean_mdn, "KT")
        g.map(mark_distributions_by_location, "KT")
        g.fig.subplots_adjust(hspace=-0.58)
        g.set_xlabels('$K_T$')
        g.set_titles('')
        g.set(yticks=[], ylim=[0, 2])
        _ = g.despine(left=True)

        g.axes[1,0].set_title('NE\n(Dec-Mar)')
        g.axes[1,1].set_title('NE → SW\n(Apr-May)')
        g.axes[1,2].set_title('SW\n(Jun-Sep)')
        g.axes[1,3].set_title('SW → NE\n(Oct-Nov)')

        for index, tt in enumerate(KTdf['latlon'].unique()):
            plt.gcf().text(0.98,0.97-index*0.015, tt,
                           color=pal_boxplot[index],
                           ha='right', va='top')
            plt.suptitle('Columns are seasons, rows are density bins', y=0.95)

        return g

#+END_SRC

#+NAME: KT-vert-hist
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist.png :results drawer
<<define-seaborn_vert_distrib>>
KTdf['ρbinned'] = pd.qcut(KTdf.ρ, 11, precision=1)
KTdf.ρbinned = KTdf.ρbinned.apply(lambda x: x.mid)
g = seaborn_vert_distrib(KTdf, "ρbinned", 'dist')
#+END_SRC
#+RESULTS: KT-vert-hist
:RESULTS:
# Out[24]:
[[file:images/bay-KT-vert-hist.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/bay-sampling-hist.png :results drawer
<<define-seaborn_vert_distrib>>
KTdf.bin = pd.qcut(KTdf.ρ, 11, precision=1)
g = seaborn_vert_distrib(KTdf, "bin", 'dist')
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist-depths.png
<<define-seaborn_vert_distrib>>
seaborn_vert_distrib(KTdf, 'mean_depth', 'kde')
#+END_SRC
#+RESULTS:
[[file:images/bay-KT-vert-hist-depths.png]]
** nutrient fluxes
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgDBOejX.png
df = bay.convert_nc_to_binned_df()

# needed to preserve order
coords = {'season': df.season.cat.categories,
          'bin': df.bin.cat.categories}

means = xr.DataArray(np.zeros((len(df.season.unique()), len(df.bin.unique()))),
                     dims=['season', 'bin'],
                     coords=coords, name='means')

medians = xr.DataArray(np.zeros((len(df.season.unique()),
                                 len(df.bin.unique()))),
                       dims=['season', 'bin'],
                       coords=coords, name='medians')

z = xr.DataArray(np.zeros((len(df.season.unique()), len(df.bin.unique()))),
                 dims=['season', 'bin'],
                 coords=coords, name='z')

stats = xr.merge([means, medians, z])

for label, group in df.groupby(['season', 'bin']):
    season = label[0]
    interval = label[1]

    stats['means'].loc[season, interval] = (10**group.KT).mean()
    stats['medians'].loc[season, interval] = (10**group.KT).median()
    stats['z'].loc[season, interval] = group.z.mean()

stats.means.attrs['description'] = 'Seasonal and density-binned means of hourly-mean temperature diffusivity K_T'

stats.medians.attrs['description'] = 'Seasonal and density-binned medians of hourly-mean temperature diffusivity K_T'

stats.to_netcdf('means_medians.nc')
#+END_SRC

TODO:
1. Subset K_T to appropriate locations
2. why are the bins unsorted?

#+BEGIN_SRC ipython :session :ipyfile images/temp/imge5GfnK.png

o2 = (xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_o*_01.nc',
                        autoclose=True, decode_times=False)
      .sel(**bay.region)
      .load())

t = (xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_decav_t*_01v2.nc',
                       autoclose=True, decode_times=False)
     .sel(**bay.region)
     .load())

s = (xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_decav_s*_01v2.nc',
                       autoclose=True, decode_times=False)
     .sel(**bay.region)
     .load())

time_new = np.datetime64(pd.datetime(2001, 1, 15)) + t.time.astype('timedelta64[M]')
time_new['time'] = time_new.data

smon = (s.s_an.sel(**bay.ebob_region)
        .groupby(time_new.monsoon.labels)
        .mean(dim='time').mean(dim='lat').mean(dim='lon'))

(nioa.SALT.sel(**bay.ebob_region)
 .mean(dim=['lon', 'lat'])
 .groupby(time_new.monsoon.labels.rename({'time': 'TIME'}))
 .mean(dim='TIME')
 .plot.line(y='DEPTH', hue='monsoon', yincrease=False))

# TODO: subset to use EBoB region K_T also
rho = (xr.DataArray(sw.pden(s.s_an, t.t_an, xr.broadcast(s.s_an, s.depth)[1]),
                    dims=t.t_an.dims, coords=t.t_an.coords)
       .sel(**bay.ebob_region)
       .mean(dim='lat').mean(dim='lon')
       .groupby(time_new.monsoon.labels)
       .mean(dim='time')
       .rename({'monsoon': 'season'}))

oxy = (o2.o_an
       .sel(lon=slice(85.5, 88.5), lat=slice(5, 8))
       .mean(dim='lat').mean(dim='lon')
       .groupby(time_new.monsoon.labels)
       .mean(dim='time')
       .rename({'monsoon': 'season'}))

flux = xr.zeros_like(stats.means) * np.nan
do2_dz = xr.zeros_like(stats.means) * np.nan
flux.name = 'o2 flux'
flux.attrs['long_name'] = '$O_2$ flux'

# interpolate WOA profile to this grid
depth_new = np.linspace(0, 400, 400)

for bb in stats.bin:
    interval = bb.item()

    if not isinstance(interval, pd.Interval):
        continue

    for seas in stats.season:
        rho_prof = rho.sel(season=seas).interp(depth=depth_new)
        oxy_prof = oxy.interp(depth=depth_new)
        mask = np.logical_and((rho_prof >= interval.left).values,
                              (rho_prof < interval.right).values)
        if mask.sum() < 3:
            continue

        do2_dz.loc[seas, interval] = (
            np.polyfit(-oxy_prof.sel(season=seas)[mask].depth.values,
                       oxy_prof.sel(season=seas)[mask].values, 1)[0])

flux = -stats.means * do2_dz
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[303]:
:END:

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgMFPMNy.png
import numpy as np
import bootstrapped.bootstrap as bs
import bootstrapped.stats_functions as bs_stats

mean = 100
stdev = 10

population = np.random.normal(loc=mean, scale=stdev, size=50000)

# take 1k 'samples' from the larger population
samples = population[:1000]

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
:END:

*** old attempts
**** without MLD binning : only ρ binning
#+CAPTION: After extending unit 814 with pitot
[[file:images/bay-KT-vert-profile-pre-mld-bin.png]]

**** by latitude
#+NAME: kt-by-lat
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-by-lat.png
KTdf.loc[KTdf['depth'] == 43.0, 'depth'] = 45.0
KTdf.loc[KTdf['depth'] == 68.5, 'depth'] = 69.0
KTdf.loc[KTdf['depth'] == 89.4, 'depth'] = 88.2
g = sns.FacetGrid(KTdf, row='depth', col='lat', hue='season',
                  sharex=True, sharey=True,
                  hue_order=['NE', 'NESW', 'SW', 'SWNE'],
                  col_order=[5., 8., 12.0, 15.0],
                  margin_titles=True, legend_out=False,
                  size=1.2, aspect=2)

kdekwargs = {'clip': [-8, 0],
             'clip_on': False,
             'bw': 0.2}

g.map(sns.kdeplot, "KT", shade=False, lw=1.5, **kdekwargs)
g.add_legend()
g.set(xlim=[-8,0], ylim=[0, 1], yticks=[])
sns.despine(left=True)
plt.subplots_adjust(hspace=-0.15)
#+END_SRC
#+RESULTS: kt-by-lat
[[file:images/bay-KT-by-lat.png]]
** Bin testing
Test out binning so that there are equal number of observations (NaN filtered) in each bin
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgSAH1E0.png :results drawer
def histedges_equalN(x, nbin):
    # from https://stackoverflow.com/questions/39418380/histogram-with-equal-number-of-points-in-each-bin
    x = x[np.logical_not(np.isnan(x))]
    npt = len(x)
    return np.interp(np.linspace(0, npt, nbin + 1),
                     np.arange(npt),
                     np.sort(x))

turb.ρ.plot.hist(bins='fd', density=True)
ρbins = histedges_equalN(np.ravel(turb.ρ), 12)
_ = turb.ρ.plot.hist(bins=ρbins, density=True, edgecolor='k', facecolor='none')
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/temp/imgSAH1E0.png]]
:END:


#+NAME: argo-clim-density
#+BEGIN_SRC ipython :session :ipyfile images/mean-density-at-moorings.png
import dcpy.oceans
import seawater as sw

latitude = [12, 15, 5, 6.5, 8, 8, 8]
longitude = [90, 90, 85.5, 85.5, 85.5, 87, 88.5]
name = ['RA12', 'RA15', 'NRL1', 'NRL3', 'NRL4', 'NRL5']

_, ax = plt.subplots(1, 3, sharey=True)
if 'argoS' not in locals():
    argoS = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Salinity_2016.nc',
                            decode_times=False)
    argoT = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Temperature_2016.nc',
                            decode_times=False)

for (lon, lat, moorname) in zip(longitude, latitude, name):
    S = argoS.ARGO_SALINITY_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    T = argoT.ARGO_TEMPERATURE_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    ρ = sw.pden(S, T, argoS.PRESSURE)

    ax[0].plot(S, argoS.PRESSURE, label=moorname)
    ax[1].plot(T, argoS.PRESSURE, label=moorname)
    ax[2].plot(ρ, argoS.PRESSURE, label=moorname)

plt.ylim([120, 0])
plt.gcf().legend()
dcpy.plots.linex(Sbins, ax=ax[0])
dcpy.plots.linex(ρbins, ax=ax[2])
ax[0].set_ylabel('Pressure')
ax[0].set_xlabel('S')
ax[1].set_xlabel('T')
ax[1].set_xlim([20, 30])
ax[2].set_xlabel('ρ')
plt.gcf().suptitle('Roemmich & Gilson ARGO Climatology')
plt.gcf().set_size_inches((5.5, 2.5))
#+END_SRC
#+CAPTION: Mark density bins on ARGO climatology density profile
#+RESULTS: argo-clim-density
[[file:images/mean-density-at-moorings.png]]

#+NAME: TS-sampled-distribution
#+BEGIN_SRC ipython :session :ipyfile images/TSρ-sampled-by-χpod.png :results drawer
f, ax = plt.subplots(2,1)
sns.violinplot(data=KTdf.dropna(), x="depth", y="ρ", ax=ax[0])
sns.violinplot(data=KTdf.dropna(), x="depth", y="S", ax=ax[1])
# sns.violinplot(data=KTdf.dropna(), x="depth", y="T", ax=ax[2])
plt.gcf().autofmt_xdate()
ρbins2 = [ 1019.45,  1020.43,  1021.05,  1021.68,
           1022.49,  1022.94,  1023.49,  1026.27]
dcpy.plots.liney(ρbins, ax=ax[0])
dcpy.plots.liney(Sbins, ax=ax[1])
plt.gcf().set_size_inches((8.5, 7.5))
plt.tight_layout()
#+END_SRC
#+RESULTS: TS-sampled-distribution
:RESULTS:
[[file:images/TSρ-sampled-by-χpod.png]]
:END:

#+NAME: kmeans
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgiZJc38.png
data = KTdf.ρ
centroids, _ = sp.cluster.vq.kmeans(data, 10)
idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(10):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1])

#+END_SRC
#+RESULTS: kmeans
[[file:images/temp/imgiZJc38.png]]

#+NAME: TS-plot
#+BEGIN_SRC ipython :session :ipyfile images/rho-bins-TS-plot.png :results drawer
T, S, binned= dcpy.util.BinEqualizeHist([KTdf['T'], KTdf['S']], bins=[200, 100])
Tg, Sg = np.meshgrid(T, S, indexing='ij')
ρg = sw.pden(Sg, Tg, 50)
# plt.plot(KTdf['S'], KTdf['T'], '.')
plt.pcolormesh(S, T, binned.T, cmap=mpl.cm.Reds)
# hc = plt.contour(Sg, Tg, ρg, colors='k', levels=ρbins)
# plt.clabel(hc, fmt='%1.1f')
plt.xlabel('S')
plt.ylabel('T')

kmeans = 12

data = KTdf.ρ
centroids, _ = sp.cluster.vq.kmeans(data, kmeans)
idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(kmeans):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1], 'k--')

cent = np.sort(centroids)
newbins = np.hstack([KTdf.ρ.min(), (cent[:-1]+cent[1:])/2])
hc = plt.contour(Sg, Tg, ρg, colors='k', levels=newbins, zorder=10)
plt.clabel(hc, fmt='%1.1f')
#+END_SRC
#+RESULTS: TS-plot
:RESULTS:
: <a list of 12 text.Text objects>
[[file:images/rho-bins-TS-plot.png]]
:END:
** analysis
*** Why is there a peak in SWNE in the EBOB array?
Biggest contribution is NRL1. Some more from NRL4. The low values are from NRL5. NRL3 seems to miss out... because the instruments are shallower?

#+CAPTION: 2014 monthly mean SSH EKE normalized by climatological monthly mean SSH EKE. NRL3 sees more EKE than usual.
[[file:images/eke-norm-clim-2014.png]]
*** At what ρ levels in the Bay is there large spiciness / large watermass contrasts?
  - σ=22-24; 23 is where the Arabian Sea S_{max} is.
* Surface fluxes
#+CALL: read-tropflux()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img7tMMDR.png
# sst = ra12.ctd['T'].sel(depth=1).groupby('time.month').mean(dim='time')

timebase = 'weekofyear'

tfsel = tropflux.sel(longitude=90, latitude=12, method='nearest')
tf = (tfsel.groupby('time.'+timebase)
      .mean(dim='time'))

jq0 = tf.netflux

if 'mldclim' not in locals():
   mldclim = dcpy.oceans.argo_mld_clim()

mld = mldclim.mld_da_mean.sel(lon=90, lat=12, method='nearest')

if timebase == 'weekofyear':
   ihi = np.interp(np.linspace(1,13, 53), mld.month,
                   0.45 * tfsel.swr.groupby('time.month').mean(dim='time')
                   ,* np.exp(-0.04 * mld))
   Ih = xr.DataArray(ihi, dims=[timebase],
                     coords=[jq0[timebase]], name='Ih')
else:
   Ih = 0.45*tfsel.swr.groupby('time.month').mean(dim='time')

f, ax = plt.subplots(2,1)
hsst = tf.sst.plot(ax=ax[0],color='k')
ax0 = ax[0]
ax1 = ax0.twinx()
hjq0 = ax1.fill_between(jq0[timebase], jq0-Ih, color='salmon')
ax1.set_zorder(-10)
ax1.axhline(0, color='k')
# hIh = Ih.plot.line('k--', ax=ax1)

ax0.set_title(''); ax1.set_title('');

_ = f.legend((hsst[0], hjq0),
           ('SST', 'Jq0-Ih'),
           loc='upper center')

jq14 = ra12.Jq.sel(time='2014').groupby('time.'+timebase).mean(dim='time')
jq15 = ra12.Jq.sel(time='2015').groupby('time.'+timebase).mean(dim='time')
jqt = (jq14.fillna(0) + jq15.fillna(0))/2
jqt.plot.line(ax=ax1)

_ = (mld*-1).plot(ax=ax[1])
args = {'color': 'k', 'ls': '--'}
ax[1].axhline(-15, **args)
ax[1].axhline(-30, **args)
ax[1].axhline(-45, **args)
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img7tMMDR.png]]
* Seasonal patterns
** depth of salinity surfaces

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgzHFIIB.png
(clim.SALT.isel(TIME=3).sel(DEPTH=50, method='nearest')
 .plot.contourf(cmap=mpl.cm.Reds, levels=20, robust=True))
hdl = (clim.SALT.isel(TIME=3).sel(DEPTH=50, method='nearest')
 .plot.contour(colors='k', levels=[32, 33, 34, 35], robust=True))
plt.gca().set_aspect('equal')
plt.gca().clabel(hdl, hdl.levels)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[14]:
: <a list of 2 text.Text objects>
:END:

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgzT2m1u.png :results drawer
clim = xr.open_dataset('~/work/datasets/nio-atlas/nioa_climatology_seasonal_temp_salt_monsoon_season.nc', decode_times=False)

_, zmat = xr.broadcast(clim.SALT, clim.DEPTH)

S0 = 33
isodepth = zmat.where(np.logical_and(clim.SALT > S0-0.1, clim.SALT < S0+0.1)).mean(dim='DEPTH')

isodepth.plot(x='LONGITUDE', col='TIME', col_wrap=2, levels=np.arange(10, 500, 30))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[138]:
: <xarray.plot.facetgrid.FacetGrid at 0x7f23fd4b7630>
[[file:images/temp/imgzT2m1u.png]]
:END:
** "pycnocline uplift"
It is quite hard to see if there is a semi-regular period.

This could be the large-scale ∇S being advected back and forth across the mooring.
1. At 12N, it happens in Jul-2014, Jul-2015

#+BEGIN_SRC ipython :session :ipyfile images/rama-sal-mosaic.png :results drawer
sal = xr.open_dataset('~/TaoTritonPirataRama/RAMA/s_xyzt_dy.cdf',
                      autoclose=True)['S_41'].sel(lon=90, lat=[12,15])
sal.values[sal.values > 40] = np.nan
sal = sal.dropna(dim='depth', how='all')

def process(x):
    x = x.expand_dims('year')
    x['year'] = x.time.dt.year.pipe(np.unique)
    x['time'] = x.time.dt.dayofyear
    x = x.rename({'time': 'dayofyear'})
    return x

stacked = [process(a[1]) for a in sal.groupby('time.year')]

syearly = (xr.concat(stacked, dim='year')
           .dropna(dim='year', how='all')
           .drop([2007, 2018], dim='year'))

g = syearly.plot.contourf(x='dayofyear', row='year', col='lat',
                          robust=True, levels=40, yincrease=False, size=1, aspect=7)
# g.axes[0,0].set_xlim([0, 100])
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/rama-sal-mosaic.png]]
:END:
*** old figures :noexport:
[[file:images/15n-sal.png]]
[[file:images/12n-sal.png]]
** K_T variations
#+CAPTION: Distribution of 5 minute averages of K_T.
#+RESULTS:
[[file:../images//rama12n-kt-boxplot.png]]
** Spectrograms
*** Things to look at
1. NRL1 cyclonic shear bit; might be a signal in J_q. Also near-(shifted) inertial energy at this point
2.
*** Summary
- M_2 *shear* has some patterns. M_2 signal in temperature occurs throughout.
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| Moor | Overall                     | NE              | NESW         | SW                           | SWNE         |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL1 | Not much f_0                 | max CW f_0 shear |              | some diurnal                 |              |
|      | M_2, M_4 T throughout         |                 |              | lots of high frequency shear |              |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL2 |                             |                 |              |                              |              |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL3 |                             |                 |              | max f_0 shear                 |              |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL4 | max f_0 shear                |                 |              |                              | max f_0 shear |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL5 | IW energy only along f_0, M_2 | Max f_0 shear    | max f_0 shear |                              |              |
|      | Lots of f_0 shear            |                 |              | Bursts of M_2 shear           |              |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgcwn1WZ.png
self = nrl1
depth = 140

f, ax = plt.subplots(3, 1, sharex=True)

self.vel.u.sel(depth=depth, method='nearest').plot(ax=ax[0])
self.vel.v.sel(depth=depth, method='nearest').plot(ax=ax[0])
ax[0].legend('u', 'v')
ax[0].axhline(0)

self.vel.uz.sel(depth_shear=depth, method='nearest').plot(ax=ax[1])
self.vel.vz.sel(depth_shear=depth, method='nearest').plot(ax=ax[1])
ax[1].axhline(0)
ax[1].legend('$u_z$', '$v_z$')

self.ctd['T'].sel(depth2=depth, method='nearest').plot(ax=ax[2])
ax2 = ax[2].twinx()
self.ctd['S'].isel(z=3).plot(ax=ax2, color='teal')

[self.MarkSeasonsAndEvents(aa) for aa in ax]

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[53]:
: [None, None, None]
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgKGsAoh.png
# test interpolation

da = xr.DataArray(np.sin(0.3 * np.arange(20).reshape(5, 4)),
                  [('x', np.arange(5)),
                   ('y', [0.1, 0.2, 0.3, 0.4])])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[185]:
:END:


nrl5 ε seems have some nice period variability during SW monsoon. can I see that in a spectrum?

#+BEGIN_SRC ipython :session :ipyfile images/temp/img0A5iM0.png
eps1 = (nrl5.ε
       .resample(time='12H').mean(dim='time'))
eps2 = (eps1
        .where(eps1 > 1e-12)
        .interpolate_na(dim='time')
        .dropna(dim='time'))


f, ax = plt.subplots()

for zz in eps1.depth:
    dcpy.ts.PlotSpectrum((eps2.sel(depth=zz)),
                         multitaper=True, preserve_area=True,
                         ax=ax)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[341]:
[[file:images/temp/img0A5iM0.png]]
:END:

#+BEGIN_SRC ipython :session :results none
for m in [nrl1, nrl3, nrl4, nrl5]:
    m.plot_turb_spectrogram()
    plt.gca().set_xlim(['2014-01-01', '2014-12-31'])

    plt.savefig('images/specgram-' + m.name + '.png',
                bbox_inches='tight')
#+END_SRC

[[file:images/specgram-NRL1.png]]
[[file:images/specgram-NRL2.png]]
[[file:images/specgram-NRL3.png]]
[[file:images/specgram-NRL4.png]]
[[file:images/specgram-NRL5.png]]
*** Coarser summary

#+CAPTION: RAMA13 526 15m: NE & NESW have CW energy ≈ CCW energy (not polarised!) Very heavily polarized during the SW and SWNE. Big diurnal peak during SWNE too. Why is there not more CW-polarized NIW energy during NE monsoon?
[[file:images/mixing_seasons_ra12_526.png]]

#+CAPTION: NRL5 519 105m:
[[file:images/mixing_seasons_nrl5_519.png]]
*** NRL5
Let's look at IW spectrum during period  of low mixing and period of high mixing.

#+BEGIN_SRC ipython :session :ipyfile images/temp/img50EzMF.png

lowmix = slice('2014-03-17', '2014-05-05')
himix = slice('2014-05-06', '2014-11-01')

dTdz = -nrl5.ctd['T'].diff(dim='depth2')/nrl5.ctd.depth2.diff(dim='depth2')

z = 90
f, ax = plt.subplots(constrained_layout=True)
kwargs = dict(ax=ax, multitaper=True, dt=600/86400)
dcpy.ts.PlotSpectrum((nrl5.ctd['T'].sel(time=lowmix, depth2=z)
                      / dTdz.sel(time=lowmix, depth2=z).mean(dim='time')),
                     ,**kwargs)
dcpy.ts.PlotSpectrum((nrl5.ctd['T'].sel(time=himix, depth2=z)
                      / dTdz.sel(time=himix, depth2=z).mean(dim='time')),
                     ,**kwargs)
ax.legend(('lowmix', 'himix'))

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[175]:
: <matplotlib.legend.Legend at 0x7fbaccba9f98>
:END:

** Seasonal cycle in internal wave energy?

Given a mooring calculate spectra at all depths. Average over season?

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgjHIylm.png

# T = nrl5.ctd['T_S']

kwargs = dict(dim='time', window=20*86400/10/60, shift=2*86400/10/60,
              multitaper=True)
plot_kwargs = dict(cmap=svc.cm.blue_orange_div, add_colorbar=True)

spec = dcpy.ts.Spectrogram(nrl5.ctd.T_S.isel(z=3), **kwargs,
                           dt=10/24/60)
spec.freq.attrs['units'] = 'cpd'
spec.name = 'PSD(T)'


plt.figure(); np.log10(spec).plot(x='time', **plot_kwargs)

#+END_SRC
#+RESULTS:
:RESULTS:
# Out[978]:
: <matplotlib.collections.QuadMesh at 0x7f2f604b4a90>
:END:

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgnRA15P.png
T = nrl5.ctd.T_S.isel(z=3)

kwargs = {'dt': 600/86400,
          'multitaper': True,
          'nsmooth': 5}
dcpy.ts.PlotSpectrum(T.monsoon.ne, **kwargs)
dcpy.ts.PlotSpectrum(T.monsoon.nesw, **kwargs)
dcpy.ts.PlotSpectrum(T.monsoon.sw, **kwargs)
dcpy.ts.PlotSpectrum(T.monsoon.swne, **kwargs)
tides = dcpy.ts.TidalAliases(600/86400)

plt.gca().axvline(1/(2*np.pi/dcpy.oceans.coriolis(8.5)/86400))
plt.gca().axvline(1/(2*np.pi/dcpy.oceans.coriolis(8.5)/86400))

dcpy.plots.linex([tt for tt in tides.values()])

plt.gca().legend(['NE', 'NESW', 'SW', 'SWNE'])

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[22]:
: <matplotlib.legend.Legend at 0x7f4248874b70>
[[file:images/temp/imgnRA15P.png]]
:END:

Let's integrate temperature spectrum in 3 bands:
1. Internal waves: 1/1.2f < freq < 1/20 minutes
2. Near-inertial: 1/1.2f < freq < 1/0.9f (*clockwise only*)
3. M2 : 0.9*f_M2 < freq < 1.1*f_M2
4. K1 : 0.9*f_K1 < freq < 1.1*f_K1

Compute the rotary spectra and integrate the sum if not near-inertial (in that case, I do clockwise only).
#+NAME: integrate_velocity_spectrum
#+BEGIN_SRC ipython :session :results none
kwargs = {'dt': 3600/86400,
          'multitaper': True,
          'nsmooth': 5}

Eiw = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                   columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                   dtype=np.float64)
Eniw = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                    columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                    dtype=np.float64)
Em2 = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                   columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                   dtype=np.float64)

Ek1 = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                   columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                   dtype=np.float64)

tides = dcpy.ts.TidalAliases(dt=600/86400)

debug = True

def integrate_spectrum(spec, flo, fhi, debug=False):
    spec_iw = spec.where(np.logical_and(spec.freq > flo,
                                        spec.freq < fhi))

    if debug:
        spec.plot()
        spec_iw.dropna(dim='freq', how='all').plot()
        dcpy.plots.linex([flo, fhi])
        plt.gca().set_xscale('log')
        plt.gca().set_yscale('log')

    return (xrsp.integrate.trapz(spec_iw.dropna(dim='freq'),
                                 coord='freq')
            .values.ravel()[0])

if debug:
    with plt.style.context('ggplot'):
        fall, axall = plt.subplots(1, 2);
        fall.set_size_inches((10, 10/2.5))

for moor in [nrl1, nrl3, nrl4, nrl5]:
    print(moor.name)
    inertial = 1/(2*np.pi/(dcpy.oceans.coriolis(moor.lat)*86400))

    T = ((moor.vel.u + 1j * moor.vel.v)
         .sel(depth=100, method='nearest'))

    if np.all(np.isnan(T)):
        continue

    with plt.style.context('ggplot'):
        if debug:
            dcpy.ts.PlotSpectrum(T.dropna(dim='time'),
                                 preserve_area=True,
                                 ax=axall, twoside=True, **kwargs)

            f, ax = plt.subplots(2, 2, sharex=True, sharey=True)
            f.set_size_inches(8, 5)
            plt.suptitle(moor.name)
            axes = dict(NE=ax[0,0], SW=ax[0,1],
                        NESW=ax[1,0], SWNE=ax[1,1])

        for season in Eiw.index:
            # T = (np.hypot(moor.vel.u, moor.vel.v)
            #      .sel(depth=100, method='nearest'))

            Tsub = (T.where(T.monsoon.labels == season)
                    .sel(time='2014')
                    .dropna(dim='time'))

            # S, freq, conf = dcpy.ts.SpectralDensity(T, **kwargs)
            cw, ccw, freq, conf_cw, conf_ccw = dcpy.ts.RotaryPSD(Tsub, **kwargs)

            dakwargs = dict(dims=['freq'], coords={'freq': freq})
            spec = xr.Dataset()
            spec['cw'] = xr.DataArray(cw, **dakwargs)
            spec['ccw'] = xr.DataArray(ccw, **dakwargs)

            if debug:
                dcpy.ts.PlotSpectrum(Tsub, axes[season], twoside=False,
                                     preserve_area=True,
                                     ,**kwargs)
                axes[season].set_title(season)

            # spec = xr.DataArray(S, dims=['freq'], coords={'freq': freq})
            # integrate_spectrum(spec.cw, 0.9*inertial, 1.2*inertial)

            Eiw[moor.name][season] = (integrate_spectrum(spec.cw + spec.ccw,
                                                         0.9*inertial,
                                                         1/1200*86400))
            Eniw[moor.name][season] = (
                integrate_spectrum(spec.cw, 0.9*inertial, 1.2*inertial))
            Em2[moor.name][season] = (integrate_spectrum(spec.cw+spec.ccw,
                                                         0.9*tides['M2'],
                                                         1.1*tides['M2']))
            Ek1[moor.name][season] = (integrate_spectrum(spec.cw+spec.ccw,
                                                         0.9*tides['K1'],
                                                         1.1*tides['K1']))

        if debug:
            dcpy.plots.linex([0.9*inertial, 1.2*inertial,
                              0.9*tides['M2'], 1.1*tides['M2'],
                              0.9*tides['K1'], 1.1*tides['K1']],
                             ax=ax.ravel())
            [aa.set_xlabel('') for aa in ax[0, :]]
            [aa.set_ylabel('') for aa in ax[:, 1]]
            [aa.set_xlabel('Freq (cpd)') for aa in ax[1, :]]
            [aa.set_ylim([0, 0.013]) for aa in ax.flat]

            f.savefig('images/rotary-vel-spectra-'+moor.name+'.png',
                      bbox_inches='tight', transparent=False)

axall[0].set_ylim(axall[1].get_ylim())
axall[1].legend(['NRL1', 'NRL3', 'NRL4', 'NRL5'])
fall.savefig('images/rotary-vel-spectra-NRL.png', bbox_inches='tight',
             transparent=False)
#+END_SRC

#+CAPTION: Seasonal area/variance-preserving two-sided spectra of velocity at 100m for NRL1,3,4,5.
[[file:images/rotary-vel-spectra-NRL.png]]

[[file:images/rotary-vel-spectra-NRL1.png]]
[[file:images/rotary-vel-spectra-NRL3.png]]
[[file:images/rotary-vel-spectra-NRL4.png]]
[[file:images/rotary-vel-spectra-NRL5.png]]

#+BEGIN_SRC ipython :session :ipyfile images/temperature-seasonal-variance.png
f, ax = plt.subplots(1, 3)
sns.heatmap(Eiw*1e3, ax=ax[0], robust=True, annot=True, linecolor='w', linewidths=3,
            cmap=mpl.cm.Reds, fmt='.2f')
ax[0].set_title('internal wave band')

sns.heatmap(Eniw*1e3, ax=ax[1], robust=True, annot=True, linecolor='w', linewidths=3,
            cmap=mpl.cm.Reds, fmt='.2f')
ax[1].set_title('NIW band')

sns.heatmap(Em2*1e3, ax=ax[2], robust=True, annot=True, linecolor='w', linewidths=3,
            cmap=mpl.cm.Reds, fmt='.2f')
ax[2].set_title('M2 band')

f.suptitle('Temperature variance at 200m')
f.set_size_inches(16, 5)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[475]:
:END:

** Seasonal cycle in M_2 tide!
There is a seasonal cycle in M2. There are also prominent tidal harmonics = nonlinear tide?

There is a more prominent seasonal cycle in the K1 tide too?

Most of these KT are contaminated by instrument moving down in the water column :(

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl1.png
nrl1.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[171]:
[[file:images/seasonal-nrl1.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl2.png
nrl2.plot_spectrogram()
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl3.png
nrl3.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[176]:
[[file:images/seasonal-nrl3.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl4.png
nrl4.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[175]:
[[file:images/seasonal-nrl4.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl5.png
nrl5.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[174]:
[[file:images/seasonal-nrl5.png]]
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgdYM4bm.png
dt = 10/24/60
kwargs = dict(dim='time', dt=dt, window=25/dt, shift=5/dt)

spec = dcpy.ts.Spectrogram(self.ctd['T'].sel(depth2=150), **kwargs)
np.log10(spec).plot(robust=True, x='time')
plt.gca().set_yscale('log')

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[157]:
:END:


#+begin_SRC ipython :session :ipyfile images/temp/imgoi5WUg.png
spec = dcpy.ts.Spectrogram(ra15.vel.spd.interpolate_na(dim='time').squeeze(),
                           dim='time',
                           window=(7*86400)/(30*60),
                           shift=(3.5*86400)/(30*60), nsmooth=15)
np.log10(spec).plot.contourf(x='time', levels=40);
plt.gca().set_yscale('log')
#+END_SRC

#+RESULTS:
** Seasonal cycle in NIW?
*** NIW input u⋅τ using Alford (2003) spectral solution
**** double check with in-situ data : looks OK
Doing for RAMA12 and topmost bin from NRL5.

#+BEGIN_SRC ipython :session :results none
def compare_fluxes(mooring):

    # 1/1.25, 1.25 taken from Alford (2003)
    freqs = np.array([1/1.25, 1.25]) * mooring.inertial.values

    def filt(comp, freqs=freqs):
        dt = (comp.time.diff('time').mean()
             .values.astype('timedelta64[m]').astype('float32'))
        ufilt = dcpy.ts.BandPassButter(np.real(comp),
                                       dim='time',
                                       freqs=freqs,
                                       dt=dt/24/60)
        vfilt = dcpy.ts.BandPassButter(np.imag(comp),
                                       dim='time',
                                       freqs=freqs,
                                       dt=dt/24/60)

        return (ufilt + 1j*vfilt)

    # pick topmost bin
    ZI = (filt((mooring.vel.u.isel(depth=0).squeeze().interpolate_na('time')
               + 1j * mooring.vel.v.isel(depth=0).squeeze().interpolate_na('time')))
          .sel(time='2014'))

    if 'taux' in mooring.met:
        T = (mooring.met.taux + 1j * mooring.met.tauy)
    else:
        T = (mooring.tropflux.taux + 1j * mooring.tropflux.tauy)

    T = 1/1025 * (T.interp_like(ZI).interpolate_na('time')
                  .sel(time='2014')
                  .rolling(time=12).mean().dropna('time'))
    flux = np.real(1025 * ZI * np.conj(T))

    if np.isnan(mooring.mld).all():
        mld = (mimoc.DEPTH_MIXED_LAYER
               .interp(lon=mooring.lon, lat=mooring.lat).load()
               .interp(time=T.time))
    else:
        mld = mooring.mld.interp(time=T.time).rolling(time=300).mean()

    model_input, ZImodel = dcpy.oceans.calc_wind_power_input(
        (T * 1025),
        mld=mld,
        f0=dcpy.oceans.coriolis(mooring.lat))
    ZIfilt = filt(ZImodel.dropna('time'))
    filt_input = np.real(1025 * ZIfilt * np.conj(T))

    f, ax = plt.subplots(2, 2, sharex='col', constrained_layout=True,
                         gridspec_kw={'width_ratios': [2, 1]})
    ZImodel.plot(ax=ax[0, 0], lw=0.5)
    ZI.plot(ax=ax[0, 0])
    ZIfilt.plot(ax=ax[0, 0], color='k')
    ax[0, 0].legend(['unfiltered model', 'true', 'filtered model'])

    model_input.plot(ax=ax[1, 0])
    flux.plot(ax=ax[1, 0])
    filt_input.plot(ax=ax[1, 0], color='k')
    ax[1, 0].legend(['unfiltered flux', 'true flux', 'filtered flux'])

    dcpy.ts.PlotSpectrum(ZI.dropna('time'), twoside=False, ax=ax[0, 1])
    dcpy.ts.PlotSpectrum(ZImodel.dropna('time'), twoside=False, ax=ax[0, 1])
    ax[0, 1].legend(['true cw', 'true ccw', 'filt model cw', 'filt model ccw'])

    dcpy.ts.PlotSpectrum(model_input.dropna('time'), ax=ax[1, 1])
    dcpy.ts.PlotSpectrum(flux.dropna('time'), ax=ax[1, 1])
    dcpy.ts.PlotSpectrum(filt_input.dropna('time'), ax=ax[1, 1], color='k')
    ax[1, 1].legend(['unfiltered flux', 'true flux', 'filtered flux'])
    dcpy.plots.linex(freqs, ax=ax[:, 1])
    dcpy.plots.linex(mooring.inertial, ax=ax[:, 1])

    ax[1, 1].set_ylim([1e-7, 5e-3])
    ax[1, 0].set_ylim([-0.05, 0.05])
    ax[0, 0].set_ylim([-0.3, 0.3])
    ax[1, 0].set_xlim(('2014-01-01', '2015-01-01'))
    ax[0, 1].set_title('Spectra of currents')
    ax[1, 1].set_title('Spectra of flux')
    f.suptitle(mooring.name + ' | wind power input comparison | data vs model.')

compare_fluxes(ra12)
plt.savefig('images/niw-input-ra12-check.png')

nrl5.vel['time'] = nrl5.vel.time.dt.round('H')
nrl5.tropflux['time'] = nrl5.tropflux.time.dt.round('D')
compare_fluxes(nrl5)
plt.savefig('images/niw-input-nrl5-check.png')

#+END_SRC

#+CAPTION: RAMA12: Agreement between flux calculated using filtered currents (0.5f - 1.5f) and predicted is good. No tuning required! The black should agree with orange. Black is (0.5f - 1.5f) filtered version of blue. There's a lot of high frequency information in the solution that makes the blue look worse but it really isn't.
[[file:images/niw-input-ra12-check.png]]

#+CAPTION: Same as above for NRL5. Agreement isn't as good. One funny thing is that there's a lot more clockwise energy in the near-inertial band here. Not sure if that's the discrepancy though cite:Plueddemann2006 seem to think it could make a file.
[[difference:images/niw-input-nrl5-check.png]]

**** Basin-wide estimate
#+BEGIN_SRC ipython :session :results none

wind_input = xr.open_dataset('~/bay/estimates/wind-power-input-2014.nc')

monthly = wind_input.groupby('time.month').mean('time')
g = (monthly*1000).plot(col='month', col_wrap=4, robust=True,
                        add_colorbar=False)
g.add_colorbar(label='Monthly average near-inertial power input [mW/m²]')
g.fig.savefig('images/niw-input-monthly.png', bbox_inches='tight')

f, ax = plt.subplots(2, 1, constrained_layout=True)
((wind_input*1000).mean('lon').dropna('lat', how='all')
 .plot(x='time', robust=True, ax=ax[0]))
ax[0].set_title('Longitudinally-averaged wind-input [mW/m²]')
ax[0].set_xlabel('')
[tt.set_rotation(0) for tt in ax[0].xaxis.get_ticklabels()]
[tt.set_ha('center') for tt in ax[0].xaxis.get_ticklabels()]

((monthly*1000).mean('lon').dropna('lat')
 .plot(x='month', robust=True, ax=ax[1]))
ax[1].set_title('Longitudinally-averaged monthly-mean wind-input [mW/m²]')

plt.savefig('images/niw-input-lon-mean.png')
#+END_SRC
#+CAPTION: Monthly mean near-inertial wave input. These values seem low currently. :( I've used MIMOC MLD (Argo MLD has some gaps) and Tropflux winds. For about half the year, there's very little wind input north of 10N!
[[file:images/niw-input-monthly.png]]


#+CAPTION: Average the above in lon. This is cool, because near-inertial waves only propagate equatorward. That means if the wind input is limited to < 10N, as it is, most of the Bay should see little inertial energy. i.e. our 8N χpods should be seeing high mixing relative to the rest of the Bay.
[[file:images/niw-input-lon-mean.png]]

**** old crap: need near-inertial current!                      :noexport:
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgCv7Gly.png
taux = xr.open_mfdataset('../datasets/tropflux/taux_tropflux_1d_*.nc')
tauy = xr.open_mfdataset('../datasets/tropflux/tauy_tropflux_1d*.nc')
tau = (xr.merge([taux, tauy])
       .rename({'latitude': 'lat', 'longitude': 'lon'})
       .sel(**bay.region).sel(time='2014')).load()

oscar = (xr.open_mfdataset('/home/deepak/work/datasets/oscar/oscar_vel*.nc',
                          autoclose=True, drop_variables=['year'])
         .squeeze()
         .rename({'latitude': 'lat', 'longitude': 'lon'})
         .sel(lon=slice(80, 94), lat=slice(24, 4)).sel(time='2014')).load()

oscar_1deg = (oscar
              .rolling(lat=3, center=True).mean(dim='lat')
              .sel(lat=slice(None, None, 3))
              .rolling(lon=3, center=True).mean(dim='lon')
              .sel(lon=slice(None, None, 3)))

oscari = oscar_1deg.interp_like(tau)
windinput = oscari.u * tau.taux + oscari.v * tau.tauy

windinput.attrs['long_name'] = 'near-inertial wind input'

monthly_windinput = windinput.resample(time='M').mean(dim='time').compute()
monthly_windinput.attrs = windinput.attrs

g = monthly_windinput.plot(col='time', col_wrap=4, robust=True,
                           add_colorbar=False)
g.map(bay.mark_moors)
g.add_colorbar()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[660]:
: <xarray.plot.facetgrid.FacetGrid at 0x7f9d1b4cc860>
:END:
*** Seasonal cycle of Ri at EBOB?
#+BEGIN_SRC ipython :session :ipyfile images/nrl5-Ri.png
N2 = nrl5.N2.isel(depth=1)

z = (nrl5.zχpod.isel(num=1)
     .interp(time=nrl5.vel.time)
     .dropna(dim='time')
     .drop('num'))

S2 = (nrl5.vel.shear.interp(time=z.time, depth_shear=z)**2)

f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True)
(S2/4).plot(ax=ax[0], label='$S^2/4$')
N2.plot(ax=ax[0], yscale='log', label='$N^2$')
plt.gca().set_ylabel('')
ax[0].legend()

((N2/S2).resample(time='D').mean()
 .plot(yscale='log', ax=ax[1], ylim=[1, 100]))
ax[1].set_ylabel('Ri')
ax[1].grid(True)

(nrl5.KT.resample(time='D').mean(dim='time')
 .plot.line(x='time', yscale='log', ax=ax[2]))
ax[2].grid(True)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[6]:
: <matplotlib.legend.Legend at 0x7fcf64041dd8>
[[file:images/nrl5-Ri.png]]
:END:

Argo N2 agrees with NRL5, so I'm not doing something insane
#+BEGIN_SRC ipython :session :ipyfile images/temp/img9hBMIK.png
argo = dcpy.oceans.read_argo_clim()
argo_nrl5 = argo.sel(lat=nrl5.lat, lon=nrl5.lon, method='nearest').load()
argo_nrl5['rho'] = argo_nrl5.S.copy(data=sw.pden(argo_nrl5.S,
                                                 argo_nrl5['T'],
                                                 argo_nrl5.pres))
argo_nrl5['N2'] = 10/1025 * argo_nrl5.rho.differentiate('pres')
argo_nrl5_clim = argo_nrl5.groupby('time.month').mean(dim='time')
#+END_SRC
*** NIW energy at moorings

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-niw-nrl.png
import bay

if 'nrl1' not in locals():
    nrl1 = bay.read_nrl1()

def depth_average(da, depth_range):
    import xrscipy as xrsp
    return (xrsp.integrate.trapz(da.sel(depth=depth_range),
                                 coord='depth'))

f, ax = plt.subplots(2, 2, constrained_layout=True)

for idx, moor in enumerate([nrl1, nrl3, nrl4, nrl5]):
    aa = ax.flat[idx]
    top = depth_average(moor.niw.KE, slice(0, 40))
    bottom = depth_average(moor.niw.KE, slice(40, None))

    def plot_monthly_average(da):
        mean = da.groupby('time.month').mean(dim='time')
        std = da.groupby('time.month').std(dim='time')

        norm = mean.max()
        (mean/norm).plot(yerr=std/norm/np.sqrt(2), ax=aa)

    plot_monthly_average(top)
    plot_monthly_average(bottom)
    aa.set_title(moor.name)
    f.legend(['0-40m', 'below 40m'], loc='outside')
    f.suptitle('Normalized seasonal mean depth integrated NIW KE + std')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[290]:
[[file:images/seasonal-niw-nrl.png]]
:END:
:END:
*** Ewa NIW @ NRL processing :noexport:
#+NAME: read-ewa
#+BEGIN_SRC ipython :session :results none
for fname in ['NRL1', 'NRL3', 'NRL4', 'NRL5']:

    nn = sp.io.loadmat('../datasets/ewa/' + fname + 'cxdm_out.mat', squeeze_me=True)

    time = dcpy.util.datenum2datetime(nn['date_time'])
    nrl = xr.Dataset()
    nrl['amp'] = xr.DataArray(nn['CA'].T/100,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['amp'].attrs['long_name'] = 'Clockwise amplitude'
    nrl['amp'].attrs['units'] = 'm/s'

    nrl['pha'] = xr.DataArray(nn['Cp'].T,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['pha'].attrs['long_name'] = 'Clockwise phase'
    nrl['pha'].attrs['units'] = 'rad'

    nrl['KE'] = xr.DataArray(nn['CKE'].T,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['KE'].attrs['long_name'] = 'Clockwise KE'
    nrl['KE'].attrs['units'] = 'J/m³'

    nrl.attrs['name'] = fname

    nrl.to_netcdf('../datasets/ewa/'+fname+'.nc')
#+END_SRC

#+NAME: plot-niw
#+BEGIN_SRC ipython :session :results none
def plot_ewa_niw(nrl):
    import cmocean

    kwargs = dict(robust=True, yincrease=False, cmap=mpl.cm.Reds)

    f, ax = plt.subplots(3, 1, sharex=True, sharey=True)

    nrl.amp.plot(ax=ax[0], **kwargs)
    nrl.pha.plot(ax=ax[1], robust=True, cmap=cmocean.cm.phase, yincrease=False, center=0)
    nrl.KE.plot(ax=ax[2], **kwargs)

    f.suptitle(nrl.name, y=0.91)
    ax[0].set_xlabel('')
    ax[1].set_xlabel('')


for nn in ['NRL1', 'NRL3', 'NRL4', 'NRL5']:
    nrl = xr.open_dataset('../datasets/ewa/' + nn + '.nc').load()
    plot_ewa_niw(nrl)
    plt.savefig('../images/niw-' + nn + '.png', bbox_inches='tight')


#+END_SRC
** Wavelets vs spectrograms
Wavelets need a good understanding of wavelet choice.

variance-preserving spectrogram seems a good way to go.

*** spectrogram to recover wijesekara et al (2016) wavelet

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgx9o72o.png
# da = nrl3.vel.u.sel(depth=120, method='nearest')

# spec = dcpy.ts.Spectrogram(da, nfft=24*60, shift=1*24,
#                            dt=1/24, multitaper=True)

plt.figure(constrained_layout=True)
hdl = (spec*spec.freq).plot.contourf(yscale='log', x='time', robust=True,
                                     levels=30, cmap=svc.cm.red_1)

ax = plt.gca()
ax2 = ax
ax2.yaxis.set_tick_params(which='both', left=True, right=True,
                          labelleft=True, labelright=True)
ax2.spines['right'].set_visible(True)

# ax2.xaxis.set_tick_params(top=False, bottom=False,
#                           labeltop=False, labelbottom=False)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[409]:
:END:

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgw7sScw.png

wz = (
(nrl3.vel.uz + 1j * nrl3.vel.vz)
      .sel(depth_shear=120, method='nearest'))

spec = dcpy.ts.PlotSpectrogram(wz, nfft=60*24, shift=3*24, dt=1/24)
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgz8e7q3.png
import tfr

frames = tfr.SignalFrames(da.values, sample_rate=1/24,
                          frame_size=24*60, hop_size=1*24)
spec = tfr.Spectrogram(frames)

spec = tfr.reassigned_spectrogram(frames, magnitudes='power')


#+END_SRC
*** test jwavelet
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgJWY9H3.png
time = np.arange(1000)
a = np.sin(2*np.pi/20*time)

da = xr.DataArray(a, dims=['time'], coords={'time': time})

da = ra12.vel.u.squeeze().interpolate_na(dim='time').dropna(dim='time')
wt = dcpy.ts.matlab_wavelet(da, dt=60/1440, kind='jlab', eng=eng, beta=10.0)

plt.figure()
np.log10(wt.power).plot.contourf(levels=20, x=dim, yincrease=False, yscale='log',
                                 robust=True, cmap=svc.cm.blue_orange_div)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[887]:
: <matplotlib.contour.QuadContourSet at 0x7f178d87c470>
:END:

*** Seasonal cycle summary : wavelets

#+BEGIN_SRC ipython :session :results none
for m in [nrl1, nrl3, nrl4, nrl5]:
    m.plot_turb_wavelet()
    plt.savefig('images/wavelet-'+m.name+'.png')

#+END_SRC

** test complex demod
I'm not sure this works for near-inertial frequencies. f_0 can change throughout the year and so there'll be phase differences and the near-inertial input won't look right. Probably makes more sense for M_2 and tidal lines.

#+BEGIN_SRC ipython :session :ipyfile images/complex-demod-ewa-mine.png
z = 100

u = nrl5.vel.u.sel(depth=z, method='nearest').interpolate_na(dim='time')
v = nrl5.vel.v.sel(depth=z, method='nearest').interpolate_na(dim='time')

dm = dcpy.ts.complex_demodulate(u + 1j * v,
                                dim='time',
                                central_period=1/nrl5.inertial,
                                cycles_per='D', bw=0.3, filt='butter',
                                debug=True)

ewa = (nrl5.niw.amp.sel(depth=z, method='nearest')
       ,* np.exp(1j * nrl5.niw.pha.sel(depth=z, method='nearest')))

f, ax = plt.subplots(2, 2)
np.abs(dm.cw).plot(ax=ax[0, 0])
nrl5.niw.amp.sel(depth=z, method='nearest').plot(ax=ax[0, 0])
ax[0, 0].legend(['mine', 'ewa'])

xr.DataArray((np.angle(dm.cw, deg=False)),
             dims=dm.cw.dims, coords=dm.cw.coords,
).plot(ax=ax[1, 0])
nrl5.niw.pha.sel(depth=z, method='nearest').plot(ax=ax[1, 0])

dm.cw.real.plot(ax=ax[0, 1])
ewa.real.plot(ax=ax[0, 1])
dm.cw.imag.plot(ax=ax[1, 1])
ewa.imag.plot(ax=ax[1, 1])

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[214]:
: [<matplotlib.lines.Line2D at 0x7f7c58aeb780>]
:END:
* checking inter-mooring variability
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgBRHfA4.png

turb = xr.open_dataset('bay_merged_hourly.nc')

ra = (turb.KT.sel(lon=90)
      .dropna(dim='lat', how='all')
      .dropna(dim='depth', how='all')
      .resample(time='D').mean(dim='time'))

ra.plot.line(x='time', hue='depth', row='lat', yscale='log')
#+END_SRC



#+BEGIN_SRC ipython :session :ipyfile images/ra12-ra15-compare-15m.png
d15 = ra.sel(depth=15)

plt.figure()
for da in [d15.sel(lat=12, time='2014'),
           d15.sel(lat=12, time='2015'),
           d15.sel(lat=15)]:
    plt.plot(da.time.dt.dayofyear, da.values)

plt.gca().set_yscale('log')
plt.legend(['12N, 2014', '12N, 2015', '15N, 2015'])
plt.title('15m χpod')
plt.gcf().set_size_inches((8, 5))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[124]:
[[file:images/ra12-ra15-compare-15m.png]]
:END:

15N, 2015 and 12N, 2014 are quite similar. 12N, 2015 is different mostly because of stratification.
- in 2014, there are a lot of temperature inversions during SW monsoon at 15m; χpod is frequently in barrier layer.
- in 2015, χpod sees basically single-signed gradient nearly all the time.

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgFx1nQF.png

#+END_SRC

* NRL5 details
** M_2 soliton mixing?
#+BEGIN_SRC ipython :session :results none
trange = slice('2014-08-10', '2014-08-14')
t518 = nrl5.χpod[518].convert_to_xarray('mmw')
t519 = nrl5.χpod[519].convert_to_xarray('mmw')

f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True,
                     gridspec_kw={'height_ratios': [1, 1, 2]})
hdl1 = t518['T'].sel(time=trange).plot(x='time', ax=ax[0])
hdl2 = t519['T'].sel(time=trange).plot(x='time', ax=ax[0])
hdl3 = nrl5.ctd['T'].sel(time=trange, depth2=106).plot(x='time', ax=ax[0])
f.legend(handles=[hdl1[0], hdl2[0], hdl3[0]],
         labels=['χpod @ 84', 'χpod @ 104', 'T logger @ 104'])

(nrl5.ε.sel(time=trange)
 .plot.line(x='time', ax=ax[1], yscale='log', ylim=[1e-10, 1e-6],
            add_legend=False))

(nrl5.vel.shear.sel(time=trange, depth=slice(100, None))
 .plot(yincrease=False, cmap=mpl.cm.Reds, vmax=0.015))
(nrl5.ctd['T'].sel(time=trange)
 .plot.contour(levels=20, colors='k', yincrease=False, linewidths=1))

# hdl = (nrl5.ctd['T'].sel(time=trange)
#        .plot.contourf(levels=20, x='time', yincrease=False,
#                       cmap=mpl.cm.RdYlBu_r, ax=ax[2], robust=True))
# (nrl5.ctd['T'].sel(time=trange)
#  .plot.contour(levels=hdl.levels, x='time', yincrease=False,
#                colors='k', ax=ax[2], linewidths=0.75))
nrl5.zχpod.sel(time=trange).plot.line(x='time', ax=ax[2], color='b',
                                      add_legend=False)

ax[1].set_title('')
[aa.set_xlabel('') for aa in ax]

ax[2].set_ylim([250, 75])
f.set_size_inches((16, 9))

f.savefig('images/m2-soliton-nrl5.png')
#+END_SRC

#+ATTR_HTML: :class full-width
#+CAPTION: M_2 solitons? And a mixing signal? High ε lines up with high shear *but this is shear calculated from the first bin!*
[[file:images/m2-soliton-nrl5.png]]


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgdpXv0t.png
plt.figure(constrained_layout=True);
(nrl5.vel.shear.sel(time=trange, depth=slice(100, None))
.plot(yincrease=False, cmap=mpl.cm.Greens, vmin=4e-3, vmax=0.014))
(nrl5.ctd['T'].sel(time=trange)
 .plot.contour(levels=20, colors='k', yincrease=False, linewidths=1))
plt.gca().set_ylim([250, 100])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[244]:
: (250, 100)
:END:

** NIW mixing
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgwBTzp9.png
trange = slice('2014-07-21', '2014-08-07')
f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True,
                     gridspec_kw={'height_ratios': [1, 1, 2]})
hdl1 = t518['T'].sel(time=trange).plot(x='time', ax=ax[0])
hdl2 = t519['T'].sel(time=trange).plot(x='time', ax=ax[0])
hdl3 = nrl5.ctd['T'].sel(time=trange, depth2=106).plot(x='time', ax=ax[0])
f.legend(handles=[hdl1[0], hdl2[0], hdl3[0]],
         labels=['χpod @ 84', 'χpod @ 104', 'T logger @ 104'])

(nrl5.ε.sel(time=trange)
 .plot.line(x='time', ax=ax[1], yscale='log', ylim=[1e-10, 1e-6],
            add_legend=False))

(nrl5.vel.shear.sel(time=trange, depth=slice(100, None))
 .plot(yincrease=False, cmap=mpl.cm.Reds, vmax=0.015))
(nrl5.ctd['T'].sel(time=trange)
 .plot.contour(levels=7, colors='k', yincrease=False, linewidths=1))

# hdl = (nrl5.ctd['T'].sel(time=trange)
#        .plot.contourf(levels=20, x='time', yincrease=False,
#                       cmap=mpl.cm.RdYlBu_r, ax=ax[2], robust=True))
# (nrl5.ctd['T'].sel(time=trange)
#  .plot.contour(levels=hdl.levels, x='time', yincrease=False,
#                colors='k', ax=ax[2], linewidths=0.75))
nrl5.zχpod.sel(time=trange).plot.line(x='time', ax=ax[2], color='b',
                                      add_legend=False)
v = nrl5.vel.v.sel(time=trange).resample(time='2H').mean(dim='time')
v.plot.contour(ax=ax[2], yincrease=False, levels=20, colors='w')

ax[1].set_title('')
[aa.set_xlabel('') for aa in ax]

ax[2].set_ylim([250, 75])
f.set_size_inches((16, 9))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[332]:
:END:

#+BEGIN_SRC ipython :session :ipyfile images/temp/imggajQY2.png
plt.figure();

v = nrl5.vel.v.sel(time=trange).resample(time='2H').mean(dim='time')
v.plot.contour(yincrease=False, levels=20, colors='k')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[329]:
: <matplotlib.contour.QuadContourSet at 0x7f5cd2945b38>
:END:

** vel, shear spectra

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgzmw1zO.png

u = interpolate_shear(nrl5.vel.u, zpod).interpolate_na(dim='time')
v = interpolate_shear(nrl5.vel.v, zpod).interpolate_na(dim='time')
uz = interpolate_shear(nrl5.vel.uz, zpod).interpolate_na(dim='time')
vz = interpolate_shear(nrl5.vel.vz, zpod).interpolate_na(dim='time')

z0 = 200
u = nrl5.vel.u.sel(depth=z0).interpolate_na(dim='time')
v = nrl5.vel.v.sel(depth=z0).interpolate_na(dim='time')
uz = nrl5.vel.uz.sel(depth=z0).interpolate_na(dim='time')
vz = nrl5.vel.vz.sel(depth=z0).interpolate_na(dim='time')

fM2 = 24/12.42
f0 = nrl5.inertial

f, ax = plt.subplots(2, 1, sharex=True, constrained_layout=True)

dcpy.ts.PlotSpectrum((u+1j*v), multitaper=True, twoside=False, ax=ax[0])
dcpy.ts.PlotSpectrum((uz+1j*vz), multitaper=True, twoside=False, ax=ax[1])
dcpy.plots.linex([f0, fM2 - f0, fM2 + f0, 2*f0,
                  fM2, 2*fM2, 3*fM2, 4*fM2], ax=ax)

ax[0].set_title('PSD(u + iv)')
ax[0].set_xlabel('')
ax[1].set_title('PSD(u_z + iv_z)')

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[174]:
: Text(0.5, 1.0, 'PSD(u_z + iv_z)')
:END:

** pollard millard model
#+BEGIN_SRC ipython :session :results none
def read_ncep():
    uwnd = (xr.open_dataset('~/datasets/ncep/uwnd.10m.gauss.2014.nc')
            .uwnd.interp(lat=nrl5.lat, lon=nrl5.lon))
    vwnd = (xr.open_dataset('~/datasets/ncep/vwnd.10m.gauss.2014.nc')
            .vwnd.interp(lat=nrl5.lat, lon=nrl5.lon))

    taux = uwnd.copy(data=airsea.windstress.stress(uwnd) * np.sign(uwnd))
    tauy = vwnd.copy(data=airsea.windstress.stress(vwnd) * np.sign(vwnd))
    taux.attrs['long_name'] = '$τ_x$'
    taux.name = 'taux'
    tauy.attrs['long_name'] = '$τ_y$'
    tauy.name = 'tauy'

    return xr.merge([taux, tauy])

if 'ncep' not in locals():
    ncep = read_ncep()

f0 = dcpy.oceans.coriolis(nrl5.lat)/2/np.pi  # needed in cps
mld = 30
Ttrop = ((nrl5.tropflux.taux + 1j*nrl5.tropflux.tauy)
         .sel(time='2014').interpolate_na('time'))
Tncep = (ncep.taux + 1j*ncep.tauy)

Ttrop.attrs['long_name'] = 'Wind stress'
Ttrop.attrs['units'] = 'N/m²'
Tncep.attrs['long_name'] = 'Wind stress'
Tncep.attrs['units'] = 'N/m²'

tropinput = dcpy.oceans.calc_wind_power_input(Ttrop, mld, f0)
ncepinput = dcpy.oceans.calc_wind_power_input(Tncep, mld, f0)

f, ax = plt.subplots(4, 1, constrained_layout=True, sharex=True)

for T, windinput in zip([Ttrop, Tncep], [tropinput, ncepinput]):
    h = T.copy(data=np.abs(T)).plot(ax=ax[0])
    h[0].set_clip_on(False)
    h[0].set_in_layout(False)
    h = windinput.plot(ax=ax[1])
    h[0].set_clip_on(False)
    h[0].set_in_layout(False)

(nrl5.ε.where(nrl5.ε > 0)
 .resample(time='D').mean('time').sel(time='2014')
 .plot.line(x='time', ax=ax[2], yscale='log'))

(nrl5.KT
 .resample(time='D').mean('time').sel(time='2014')
 .plot.line(x='time', ax=ax[3], yscale='log'))

ax[0].legend(['tropflux', 'ncep'])
[aa.set_xlabel('') for aa in ax]
[aa.set_title('') for aa in ax]
ax[0].set_title('Compare wind input for Tropflux/NCEP at NRL5')

plt.savefig('images/nrl5-wind-input-tropflux-vs-ncep.png')
#+END_SRC
#+CAPTION: Near-inertial input is *not* directly correlated to wind-stress. Looks like NCEP understimates the peak stress events.
[[file:images/nrl5-wind-input-tropflux-vs-ncep.png]]

* Barrier layers
When the freshwater arrives, I see large values of Jqt at 30m/45m. This is at both 12N, 15N in both 2014, 2015.

- This observation contradicts the presence of layers hmmm...

- Some of these are where T_z changes sign frequently. (╯°□°）╯︵ ┻━┻

- Sally says that in the Gulf of Mexico she thinks that ambient water is getting subducted under river plumes and mixing there because of strong shear at the base. This is as opposed to the standard barrier layer idea that there is not much mixing happening beneath the mixed layer: i.e., the freshwater cap prevents wind-forced turbulence from penetrating downward?

- Ritabrata observes similar stuff: high mixing near the base and mixing shuts down in 10-20m range below the base.

Some examples follow.
#+NAME: barrier-rama15-2015
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama15-2015-feb.png :results raw
ax = ra15.Plotχpods(region={'time': slice('2015-02-01', '2015-03-31')},
                    filt='mean',  filter_len=6*3600, Tlim=[26.5,28])
_ = ax['T'].set_ylim([50,0])
_ = ax['Jq'].set_yscale('symlog', linthreshy=10, linscaley=0.5)
#+END_SRC
#+ATTR_HTML: :class full-width
#+CAPTION: In this one, the rise in turbulence at 30m coincides with *speed increasing*. 30m χpod sees relatively few changes in T_z sign, but high heat fluxes (compare with below). The "waviness" seems to be M_2.
#+RESULTS: barrier-rama15-2015
[[file:images/barrier-layer-rama15-2015-feb.png]]

When the freshwater arrives we see stronger M_2 tides, maybe a packet came by? But the variability is confined to 20m, 40m CTDs.

#+BEGIN_SRC ipython :session :ipyfile images/rama-15n-freshwater-M2.png
f, ax = plt.subplots(3,1, sharex=False, sharey=False)

(ra15.ctd.S.sel(depth=[10, 20, 40, 60],
                time=slice('2015-02-01', '2015-04-10'))
.plot.line(x='time', ax=ax[0]))

(ra15.ctd.S.sel(depth=[10, 20, 40, 60],
                time=slice('2015-02-22', '2015-03-01'))
.plot.line(x='time', ax=ax[1], add_legend=False))
ax[0].set_title('RAMA 15N, arrival of freshwater 2015 - Note M2 signal')

specargs =dict(dt=600/86400, nsmooth=2, multitaper=True, preserve_area=False, ax=ax[2])
dcpy.ts.PlotSpectrum(ra15.ctd.S.sel(depth=40,
                                    time=slice('2015-02-16', '2015-03-10')),
                     **specargs)
dcpy.ts.PlotSpectrum(ra15.ctd.S.sel(depth=40,
                                    time=slice('2015-03-20', '2015-04-10')),
                     **specargs)
ax[2].set_ylim([10**-5, 1])
ax[2].set_xlabel('Freq (cpd)')
dcpy.plots.linex([1/(2*np.pi/dcpy.oceans.coriolis(15)/86400),
                  24/12.42], ax=ax[2])

plt.gca().set_title('Spectra of salinity at 40m | RAMA 15N, 90E')
plt.legend(['2015-Feb-16 - 2015-Mar-10', '2015-Mar-20 - 2015-Apr-10'])
# plt.gca().set_yscale('linear')
# plt.gca().set_ylim([0, 1])

plt.setp(ax[0].get_xticklabels(), visible=True, rotation=20)
plt.setp(ax[1].get_xticklabels(), visible=True, rotation=20)

f.set_size_inches((8.5, 12.5))
plt.tight_layout()
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/rama-15n-freshwater-M2.png]]
:END:

10m velocity is not useful: 10m salinity behaves much differently. There's a near inertial packet Mar 13-17, otherwise just M2 in velocity.
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgt8hw0H.png
hdl, ax = (dcpy.ts.PlotSpectrum((ra15.vel.u+1j*ra15.vel.v)
                                .squeeze().sel(time=slice('2014-02-16',
                                                          '2014-03-10')),
                                multitaper=True, dt=30*60/86400))
hdl, ax = (dcpy.ts.PlotSpectrum((ra15.vel.u+1j*ra15.vel.v)
                                .squeeze().sel(time=slice('2014-03-12',
                                                          '2014-04-10')),
                                multitaper=True, dt=30*60/86400, ax=ax))

dcpy.plots.linex([1/(2*np.pi/dcpy.oceans.coriolis(15)/86400),
                  24/12.42], ax=ax)
ax[1].set_xlim([1e-1, 1e1])
ax[0].set_xlim([1e1, 1e-1])
#+END_SRC

#+RESULTS:
:RESULTS:
: (10.0, 0.1)
[[file:images/temp/imgt8hw0H.png]]
:END:

#+NAME: barrier-rama12-2014
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama12-2014-feb.png :results raw
ax = ra12.Plotχpods(region={'time': slice('2014-02-20', '2014-03-20')},
                    Tlim=[26.5, 28.75],
                    filt='hann',  filter_len=3*3600)
_ = ax['T'].set_ylim([60,0])
#+END_SRC
#+CAPTION: Here, both χpods see frequent changes in the sign of T_z and heat fluxes are large and change sign often. |T_z| stays decently big (0.01-0.1) for chunks of time --- these are associated with large fluxes. Maybe using internal T_z might make sense here.
#+RESULTS: barrier-rama12-2014
[[file:images/barrier-layer-rama12-2014-feb.png]]

#+NAME: barrier-rama12-2015
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama12-2015-apr.png :results raw
ax = ra12.Plotχpods(filt='hann',  filter_len=6*3600, met='tropflux')
_ = ax['T'].set_ylim([60,0])
_ =  ax['met'].set_xlim(('2015-04-10', '2015-05-10'))
#+END_SRC
#+CAPTION: Not that similar to above (but see 2015/04/15-2015/04/18). Here, 45m χpod sees large heat fluxes.
#+RESULTS: barrier-rama12-2015
[[file:images/barrier-layer-rama12-2015-apr.png]]
* Hudhud sensitivity to Jq
# Read data
#+BEGIN_SRC ipython :session
def read_Turb(filename):
    from scipy.io import loadmat
    f = loadmat(filename)

    def process_estimate(estimate):
        chi = xr.Dataset()
        tmatlab = estimate[0,0]['time'][0,0].squeeze()
        tcommon = ((-86400 + (tmatlab-366) * 86400).astype('timedelta64[s]')
                   + np.datetime64('0001-01-01')).astype('datetime64[ns]')

        chi['χ'] = xr.DataArray(estimate[0,0]['chi'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['Kt'] = xr.DataArray(estimate[0,0]['Kt'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['Jq'] = xr.DataArray(estimate[0,0]['Jq'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['ε'] = xr.DataArray(estimate[0,0]['eps'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])

        return chi

    Turb = dict()
    for field in f['Turb'].dtype.names:
        if field in ['mm1', 'mm2', 'pm1', 'pm2',
                     'mi11', 'mi22', 'pi11', 'pi22']:
            estimate = f['Turb'][field]
            Turb[field] = process_estimate(estimate)
    return Turb

dirname = '/home/deepak/pods/526/proc/'
est = dict()
for tz in [1e-4, 3e-4, 7.5e-4, 1e-3, 2e-3, 5e-3]:
    filename = dirname + 'Turb-{0:.1e}.mat'.format(tz)
    print(filename)
    est[tz] = read_Turb(filename)

if ra12.sst == xr.Dataset():
    ra12.ReadSST()
#+END_SRC

# plot results
#+BEGIN_SRC ipython :session
trange = slice('2014-10-07','2014-10-11')
hudhud = slice('2014-10-08','2014-10-10 12:00')

uTx = (ra12.sst.Tx.sel(time=trange)
       ,* ra12.vel.u.squeeze().resample(time='D').mean(dim='time'))
vTy = (ra12.sst.Ty.sel(time=trange)
       ,* ra12.vel.v.squeeze().resample(time='D').mean(dim='time'))


meanvel = ra12.vel.sel(time=trange).mean()
meanSST = ra12.sst.sel(time=hudhud).mean()
meanSST = ra12.sst.sel(time=hudhud).mean()

mld = 15
Qadv = -(uTx + vTy) * 1025 * 4200 * mld
Qmean = -(meanvel.u * meanSST.Tx + meanvel.v * meanSST.Ty) * 1025 * 4200 * mld
print(Qmean)
print(Qadv.sel(time=hudhud).mean())

barwidth = 1e-4
f, ax = plt.subplots(2, 1)
for ee in est.keys():
    Jqvec = est[ee]['mm1'].Jq
    (Jqvec
     .resample(time='H').mean()
     .sel(time=trange)
     .plot(ax=ax[1], lw=1, label=ee))

    hb = ax[0].bar(ee, Jqvec.where(Jqvec > 0).sel(time=hudhud).mean(),
                   barwidth)
    ax[0].bar(ee, Jqvec.where(Jqvec < 0).sel(time=hudhud).mean(),
              barwidth, color=hb[0].get_facecolor())
    ax[0].plot(ee, Jqvec.sel(time=hudhud).mean(), 'k.')

ax[0].set_title('Mean heat flux (+/-) during Hudhud as fn(min_dTdz)')

hwda = (ra12.Jq.sel(depth=15, time=trange)
        .plot(ax=ax[1], add_legend=False, label='wda'))
ax[1].legend()

dcpy.plots.liney([ra12.Jq.where(ra12.Jq > 0).sel(depth=15, time=hudhud).mean(),
                  ra12.Jq.where(ra12.Jq < 0).sel(depth=15, time=hudhud).mean()],
                 ax=ax, color=hwda[0].get_color(), zorder=8)
dcpy.plots.liney(0, ax=ax, zorder=10, color='k', ls='-')
dcpy.plots.liney([Qadv.sel(time=hudhud).mean(), Qmean],
                 ax=ax, color='k', zorder=10)

plt.savefig('/home/deepak/bay/images/526-heat-flux-dTdz.png', bbox_inches='tight')
#+END_SRC

#+CAPTION: Sensitivity to ~min_dTdz~. Looks like there are a lot of observations at T_z ~ 1e-3. For lower values of ~min_dTdz~, there is a lot of +/- cancellation. Which do I believe? Bottom time series is hourly averaged Jq (for comparison with sally's paper). The WDA estimate in pink is still 60s-average.
file:images/526-heat-flux-dTdz.png

#+CAPTION: Turns out removing IC fits removes a lot of data during Hudhud.
[[file:images/wda-526-hudhud-jq-masking.png]]

* ECCO $K_d$
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgrONH8U.png
ecco = xr.open_dataset('../datasets/ecco/interp_Kd_ECCOv4.nc');

Kd = ecco.Kd_ECCOv4
Kd = xr.DataArray(Kd.values,
                  coords={'lon': Kd.lon.sel(i1=1).values,
                          'lat': Kd.lat.sel(i2=1).values,
                          'dep': Kd.dep.values},
                  dims=['lat', 'lon', 'dep'])

np.log10(Kd.sel(dep=50)).plot.contourf(levels=15);
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[200]:
[[file:images/temp/imgrONH8U.png]]
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgfv1To1.png
np.log10(Kd).sel(lon=90, lat=[12, 15], method='nearest').plot.line(y='dep', yincrease=False)
np.log10(Kd).sel(lon=[85.5, 87, 88.5], lat=8, method='nearest').plot.line(y='dep', yincrease=False)
plt.gca().set_ylim([500, 0])
dcpy.plots.linex(np.log10([1e-6, 1e-5, 5e-4]))
dcpy.plots.liney([15, 30, 45])
plt.xlim([-6.5, -3])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[388]:
: (-6.5, -3)
[[file:images/temp/imgfv1To1.png]]
:END:

* O_2, nutrients
** climatological profiles: basin-wide average
#+NAME: read-nutrients
#+BEGIN_SRC ipython :session :ipyfile :results none
o2 = xr.open_dataset('../datasets/woa13/woa13_all_o00_01.nc',
                     autoclose=True, decode_times=False)
o2seas = xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_o*_01.nc',
                           autoclose=True, decode_times=False)

n = xr.open_dataset('../datasets/woa13/woa13_all_n00_01.nc',
                     autoclose=True, decode_times=False)
nseas = xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_n*_01.nc',
                           autoclose=True, decode_times=False)

p = xr.open_dataset('../datasets/woa13/woa13_all_p00_01.nc',
                    autoclose=True, decode_times=False)
pseas = xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_p*_01.nc',
                          autoclose=True, decode_times=False)
i = xr.open_dataset('../datasets/woa13/woa13_all_i00_01.nc',
                     autoclose=True, decode_times=False)
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/bay-chem-annual-mean.png
import bay

def plot_nutrients(nut, nutseas, var, ax, **kwargs):
    mean = (nut[var+'_mn'].sel(**bay.region)
            .mean(dim=['lat', 'lon']).squeeze())
    if ax[0] is not None:
        (mean.plot(ax=ax[0], y='depth', yincrease=False, color='k',
                   lw=2, zorder=10, **kwargs))
        plt.gca().set_ylim([150, 0])

    if var != 'o':
        ((mean/mean.sel(depth=150, method='nearest'))
         .plot(ax=ax[1], y='depth', yincrease=False, **kwargs))
    else:
        ((mean/mean.max())
         .plot(ax=ax[1], y='depth', yincrease=False, **kwargs))

    if nutseas is not None:
        (nutseas[var+'_mn'].sel(**bay.region)
         .mean(dim=['lat', 'lon']).squeeze()
         .plot.line(ax=ax[0], y='depth', yincrease=False, hue='time', **kwargs))

f, ax = plt.subplots(1, 4, sharey=True)
f.set_size_inches(8,4)
plot_nutrients(o2, o2seas, 'o', [ax[0], ax[-1]], add_legend=False)
plot_nutrients(n, nseas, 'n', [ax[1], ax[-1]], add_legend=False)
plot_nutrients(p, pseas, 'p', [ax[2], ax[-1]])
plot_nutrients(i, None, 'i', [None, ax[-1]])

ax[-1].set_title('')
ax[-1].set_xlabel('Normalized profile')
ax[-1].set_xlim([0, 1])
ax[-1].legend(['O₂', 'N', 'P', 'Si'])

[aa.set_ylabel('') for aa in ax[1:]]
f.suptitle('Average oxygen, nutrient distributions (WOA13) for Bay of Bengal')
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[166]:
: Text(0.5,0.98,'Average oxygen, nutrient distributions (WOA13) for Bay of Bengal')
[[file:images/bay-chem-annual-mean.png]]
:END:
** seasonality in nutrient fluxes?
#+BEGIN_SRC ipython :session :ipyfile images/temp/img41q71z.png
import bay

region = dict(lon=slice(85.5, 88.5), lat=slice(5.5, 8.5))

nmean = (nseas.n_an
         .sel(**region)
         .mean(dim='lon')
         .mean(dim='lat'))
(nmean.groupby('time.season').mean(dim='season'))
#+END_SRC

** map the OMZ
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgCN0V8s.png
(o2seas.o_an.sel(**bay.region)
.sel(lon=87.5)
.plot.contour(col='time', col_wrap=3, robust=True, aspect=2,
              yincrease=False, ylim=[400, 0],
              cmap=mpl.cm.Blues, labels=True,
              cbar_kwargs={'label': '$$O_2$$'}))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[9]:
: <xarray.plot.facetgrid.FacetGrid at 0x7fda7d5f27f0>
:END:
** gyaan
cite:Sarma2016
1. Primary production is comparable to AS for NE and transitions but /lower/ for SW.
2. Cold-core eddies uplift nutrients?
3. Silicate is not a limiting nutrient
4. More depletion of N, P in the north

cite:Vinayachandran2005:
#+BEGIN_QUOTE
Biological productivity in the Bay of Bengal is believed to be considerably less than in the Arabian Sea, particularly during the summer monsoon [Kumar et al., 2002; Madhupratap et al., 2003]. A possible reason for this difference is that the Bay receives large quantities of freshwater from rainfall and rivers. The fresh water caps the upper layer of the northern Bay and neighboring coastal regions, leading to the formation of a barrier layer [Vinayachandran et al., 2002] that can affect thermodynamic processes in the mixed layer. Specifically, the strong stratification due to the barrier layer impedes the transfer of nutrients into the euphotic zone from below [Gomes et al., 2000].
#+END_QUOTE

* MISO signals?
** Summary
cite:Sobel2010 show large TRMM 30-90 day variance between May and October in the Bay.
[[file:../images//sobel-trmm-variance.png]]

#+CAPTION: Subsurface anomalies line up with northward propagating features in SST, LWR.
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]

#+CAPTION: Southward propagating signals in 2011-Nov/Dec!
#+RESULTS:
[[file:images/bandpass-90e-2011.png]]

*** old                                                          :noexport:
I see northward propagating "anomalies" in Tropflux SWR.
[[file:images/90e-swr-anom.png]]
** in mixing
*** RAMA 12N
**** Coherence
- Note sure coherence is the way to do this given short records

The next figure shows coherence between Jq0 and  Jqt at 15m, 30m at the RAMA 12N mooring for the year 2014. Signs for all fluxes are such that +ve warms the surface.
Looks like we have significant coherence in the 20-60day band between daily averaged Jq0 and Jqt at 15m.
The 180 phase difference looks stable, is apparent in the filtered time series and seems to make physical sense (more surface heating → increases T_z → reduces J_q^t and vice versa).

Nothing at 30m
 - short(er) data record - instrument dies in september
 - not much temp fluctuations at that depth while the instrument was alive (see above).

#+CAPTION: (Top left) Band-passed time series. (bottom left) PSD for the unfiltered time series. (Right) coherence amplitude and phase between J_q^0 and J_q^t at both depths. Significance level marked by horizontal line. Pass band marked by vertical lines.
file:rama/images/ra12-jq0-jqt-coherence.png
** temp / salinity record
*** Stratification T_z
Filtered T_z?
#+BEGIN_SRC ipython :session :ipyfile images/ra12n-bandpass-strat.png
from dcpy.plots import offset_line_plot
f, ax = plt.subplots(4, 1, sharex=True)

trange = slice('2014-06', '2014-08')
T = rama.SelectVar('T', dict(lon=90))
Tz = (T.sel(lat=12)
      .dropna(dim='depth', how='all')
      .drop(-13, dim='depth')
      .diff(dim='depth'))
Tz /= Tz.sel(time=trange).std(dim='time')
Tzbp = (Tz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Tzbp /= Tzbp.sel(time=trange).std(dim='time')

S = rama.SelectVar('S', dict(lon=90))
Sz = (S.sel(lat=12)
      .dropna(dim='depth', how='all')
      .diff(dim='depth'))
Sz /= Sz.sel(time=trange).std(dim='time')
Szbp = (Sz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Szbp /= Szbp.sel(time=trange).std(dim='time')

dcpy.plots.offset_line_plot(
    Tz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[0])

dcpy.plots.offset_line_plot(
    Tzbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[1])

dcpy.plots.offset_line_plot(
    Sz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[2])

dcpy.plots.offset_line_plot(
    Szbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[3])

ax[0].set_ylabel('$ΔT$')
ax[1].set_ylabel('$ΔT$\'')
ax[2].set_ylabel('$ΔS$')
ax[3].set_ylabel('$ΔS$\'')

dcpy.plots.liney(0, ax=ax[0])
dcpy.plots.liney(0, ax=ax[1])

plt.suptitle('10-80 day bandpass filtered at χpod depths / normalized by std.', y=1.0)
plt.tight_layout()
plt.gcf().autofmt_xdate()
#+END_SRC

#+RESULTS:
[[file:images/ra12n-bandpass-strat.png]]
*** Subsurface MISO signals?
What am I looking for?
1. northward propagation of MISO signal
2. subsurface MISO signals in 30d-90d band

#+BEGIN_SRC ipython :session :ipyfile images/temp/asd02j.png :noweb yes
if 'rama' not in locals():
     print('reading rama')
     <<read-rama-array>>

flen = np.array([10.0, 80.0])
hdl, var = rama.hov('T', region=dict(lon=90, depth=[-1, -10, -20]),
                    row='depth', filt='bandpass',
                    filter_len=flen*86400)

plt.gcf().set_size_inches((8.5, 2.5))
plt.gca().set_xlim(['2011-01-01', '2013-07-01'])
plt.gcf().autofmt_xdate()
# plt.gcf().suptitle('bandpass ' + str(flen) + 'days')
#+END_SRC
#+CAPTION: Hovmöller plot of RAMA 90E data | Bandpassed 10, 80 days. Looks like _southward_ propagation in Nov/Dec 2011.
#+RESULTS:
[[file:images/temp/asd02j.png]]
#+BEGIN_SRC ipython :session :ipyfile images/rama-iso-T-std.png :noweb yes
if 'rama' not in locals():
    <<read-rama-array>>

from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

Tfilt = BandPassButter(rama.T.where(rama.T < 40), freqs=freqs, dim='time')

MayToOct = np.logical_and(Tfilt.time.dt.month >=5,
                          Tfilt.time.dt.month <= 10)

def plot_temp_std_along_lon(Tfilt, inmask, lon):
    f, ax = plt.subplots(2, 2, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx], cmap=mpl.cm.Reds))

        # normalize at each lat,lon by maximum in depth
        Tnorm = Tstd / Tstd.max(dim='depth')
        Tnorm.name = 'normalized to \n show structure'
        (Tnorm.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx+2], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_along_lon(Tfilt, MayToOct, lon=90)
#+END_SRC
#+CAPTION: Lon = 90: Max 30-90 day std dev is within 5S-5N as expected from Han (2005). Seems independent of season. Subsurface peak = thermocline? Agrees with Girishkumar et al (2013)
#+RESULTS:
[[file:images/rama-iso-T-std.png]]

#+BEGIN_SRC ipython :session :ipyfile images/iso-T-std-lat-lon-map.png
def plot_temp_std_lat_lon(Tfilt, inmask):
    ''' Takes max. std along depth and plots in (lon, lat) space'''
    f, ax = plt.subplots(2, 1, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.dropna(dim='depth', how='all')
             .dropna(dim='lat', how='all')
             .max(dim=['depth']).transpose()
             .plot(ax=ax[idx], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_lat_lon(Tfilt, MayToOct)
#+END_SRC
#+CAPTION: Taking max(std) along depth → (lon, lat) map. Some sign of near-equatorial maxima.
#+RESULTS:
[[file:images/iso-T-std-lat-lon-map.png]]


#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907n9q.png
from dcpy.ts import apply_along_dim_1d

freqs = [1/30.0, 1/60.0]

T = rama.T.copy()

T.values[T.values > 40] = np.nan

apply_along_dim_1d(T, 'time', dcpy.ts.FillGaps, x=T.time, maxlen=20)

bp = (BandPassButter(T.sel(lon=90, lat=[15, 12, 8])
                     .dropna(dim='time', how='all'),
                     freqs=freqs, dim=['time'])
      .dropna(dim='depth', how='all'))

bp.plot.contourf(row='lat', x='time', levels=40)
plt.gcf().set_size_inches((8.5, 4.5))
plt.gca().set_ylim([-140, 0])
# plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img3907n9q.png]]

#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img9554Dcu.png
from dcpy.plots import offset_line_plot

T = rama.SelectVar('T', dict(lon=90.0))

T = T.groupby('time.month') - T.groupby('time.month').mean(dim='time')
Tclim = T.groupby('time.dayofyear').mean(dim='time')
Tanom = T.groupby('time.dayofyear') - Tclim


offset_line_plot(T.sel(depth=-1)
           .dropna(dim='time', how='all'),
          x='time', y='lat')
plt.gca().set_xlim('2011', '2014')

# Tanom.sel(depth=-1).plot()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC

#+RESULTS:
[[file:images/temp/img9554Dcu.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-90e-2014.png :noweb yes
freqs = [1/10.0, 1/80.0]
time = '2015'

<<bandpass-mosaic>>
#+END_SRC
#+CAPTION: Southward propagating signals in 2011-Nov/Dec, but not so much in 2014?
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]
*** Spectra
#+call: read-mur()

#+NAME: calc-spec
#+BEGIN_SRC ipython :session :results none
import xarray as xr
from dcpy.ts import SpectralDensity

var = rama.SelectVar('T', region=dict(lon=90, lat=12)).dropna(dim='depth', how='all')

iz = var.get_axis_num('depth')

spec = []
for zz in range(var.shape[iz]):
    S, f, conf = SpectralDensity(var.isel(depth=zz), dt=1,
                                 multitaper=False, nsmooth=2,
                                 fillgaps=True, maxlen=60)
    # create a DataArray
    spec.append(xr.DataArray(S, coords=[f], dims=['freq'],
                             attrs={'depth': var.depth.values[zz]},
                             name='PSD'))
#+END_SRC

:code-notes:
1. Let's try FFT - yes, using ~apply()~ works like doing things manually. +But results look weird+ xarray isn't respecting missing_value; haven't figured out why :(

2. bah gaps are non-uniform at all depths. can't do the groupby-apply thing. lets make a list of DataArrays and iterate over them when we plot.

3. xarray line-plots are only for 1D data.

:END:
#+CALL: calc-spec()
#+BEGIN_SRC ipython :session :ipyfile images/12n-spectra.png :exports results
if 'mur' in locals():
    S, f, conf = dcpy.ts.SpectralDensity(mur['sst'].sel(lon=90, lat=12), multitaper=True)
    plt.loglog(f, S*10**1.25, label='SST', lw=0.5)

for si, ss in enumerate(spec[0:8]):
    (ss*10**-si**1.15).plot(label=str(ss.depth), lw=0.5)

plt.title('12N 90E')
ax = plt.gca()
ax.set_xscale('log')
ax.set_yscale('log')
ax.legend()
plt.gcf().set_size_inches(8.5, 5.5)
plt.xlim([10**-3.5, 1])
#+END_SRC

#+RESULTS:
[[file:../images/12n-spectra.png]]

*** spectra old :noexport:
#+BEGIN_SRC ipython :session :ipyfile images/temp/img16594-DQ.png
data = rama.SelectVar('T', region=dict(lon=90, lat=12, depth=10))

S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=True)
plt.loglog(f, S)
S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=False)
plt.loglog(f, S)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img16594-DQ.png]]

#+BEGIN_SRC ipython :session
%matplotlib inline

import moor.moor as moor
import chipy.chipy as chipy

moor = importlib.reload(moor)
chipy = importlib.reload(chipy)

import os
if 'rama' not in os.getcwd():
    os.chdir('/home/deepak/rama/scripts/')

ra12 = moor.moor(90, 12, 'RAMA 12N', '../RAMA13/')
# ra12.AddChipod(526, 15, 'mm', '2017-07-10.mat')
# ra12.AddChipod(527, 30, 'mm', '2017-07-10.mat')
ra12.ReadMet('../RAMA13/rama_mooring_data/', WindType='pmel')
# ra12.ReadCTD('../RamaPrelimProcessed/RAMA13.mat', 'ramaprelim')
ra12.ReadCTD('../data/', 'rama')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :session :ipyfile images/temp/py28335Frc.png
dcpy.ts = importlib.reload(dcpy.ts)
dcpy.oceans = importlib.reload(dcpy.oceans)
dcpy.plots = importlib.reload(dcpy.plots)

freqs = [1/(2*np.pi/dcpy.oceans.inertial(ra12.lat)/86400),
         dcpy.ts.AliasFreq(1/(12.42/24), 1),
         1/30, 1/90]

nsmooth = 4
subset = None
mtflag = True

plt.figure(figsize=(6.5, 10.5))
ax0 = plt.subplot(211)
dcpy.ts.PlotSpectrum(ra12.ctd.Tlong, SubsetLength=subset, ax=ax0,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
ax0.set_ylabel('PSD (T)')
if mtflag:
    ax0.set_title('Multitaper')

dcpy.plots.linex(freqs)
ax1 = plt.subplot(212, sharex=ax0)
dcpy.ts.PlotSpectrum(ra12.ctd.Slong, SubsetLength=subset, ax=ax1,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
dcpy.plots.linex(freqs)
ax1.set_ylabel('PSD (S)')
ax1.set_xlabel('Freq (cpd)')

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//temp/py28335Frc.png]]

** winds at EBOB and rama
#+BEGIN_SRC ipython :session :ipyfile images/bob-winds.png
from scipy.interpolate import interpn

tau = nc.MFDataset('../tropflux/tau_tropflux*')
flx = nc.MFDataset('../tropflux/netflux_tropflux*')

ttime = tau['time'][:]
ftime = flx['time'][:]

ax = [1, 1, 1, 1]
ax[0] = plt.subplot(4, 1, 1)
ax[0].set_title('RAMA')
ax[1] = plt.subplot(4, 1, 2, sharex=ax[0])
ax[1].set_title('EBOB')
ax[2] = plt.subplot(4, 1, 3, sharex=ax[0])
ax[2].set_title('RAMA')
ax[3] = plt.subplot(4, 1, 4, sharex=ax[0])
ax[3].set_title('EBOB')

for latm, lonm in zip([12, 18, 5.5, 8],
                     [90, 90, 85.5, 88.5]):

    if latm < 12:
        ind = 1
    else:
        ind = 0

    label = str(latm) + 'N, ' + str(lonm) + 'E'
    τtrop = interpn((ttime,
                     tau['latitude'][:],
                     tau['longitude'][:]),
                    tau['tau'][:, :, :],
                    (ttime, latm, lonm))
    ftrop = interpn((ttime,
                     flx['latitude'][:],
                     flx['longitude'][:]),
                    flx['netflux'][:, :, :],
                    (ttime, latm, lonm))
    ttrop = ttime \
            + dt.date2num(dt.datetime.date(1950, 1, 1))

    ax[ind].plot(ttrop, τtrop, label=label)
    ax[ind+2].plot(ttrop, ftrop, label=label)

for ind in [0,1]:
    ax[ind].xaxis_date()
    ax[ind].legend()
    ax[ind].set_ylim([0, 0.4])
    ax[ind].set_ylabel('τ (N/m²)')
    ax[ind+2].set_ylabel('flux (W/m²)')

ax[0].set_xlim([dt.datetime.datetime(2013, 11, 29, 0, 0, 0),
                dt.datetime.datetime(2015, 1, 1, 0, 0, 0)])
ax[2].axhline(0, color='gray')
ax[3].axhline(0, color='gray')
plt.gcf().autofmt_xdate()
plt.tight_layout()
#+END_SRC
#+RESULTS:
[[file:../images//bob-winds.png]]
** in SWR
Look at anomalies:
1. Subtract yearly average.
2. Subtract daily climatology (2001-2017)

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-anom.png :noweb yes
if 'swr' not in locals():
    <<read-tropflux-swr>>
swr['swr'].load()

grpstr = 'time.dayofyear'

# pick location
sw = swr['swr'].sel(longitude=90.5, latitude=slice(0.5, 22.5))
# remove yearly average
swa = (sw.groupby('time.year')
       - sw.groupby('time.year').mean(dim='time'))
# make daily climatology
clim = sw.groupby(grpstr).mean(dim='time')
# get daily anomalies
anom = sw.groupby(grpstr) - clim

f, ax = plt.subplots(3, 1, sharey=True)

(anom.sel(time=slice('2014-05', '2014-09'))
     .plot(x='time', y='latitude', ax=ax[0]))
(anom.sel(time=slice('2015-05', '2015-09'))
     .plot(x='time', y='latitude', ax=ax[1]))

(anom.sel(time=slice('2013', '2016'))
     .groupby('time.dayofyear')
     .mean(dim='time')
     .plot(x='dayofyear', y='latitude', ax=ax[2]))
ax[2].set_title('anomalies averaged over 2013-2016')

ax[0].set_xlabel('')
ax[1].set_xlabel('')
ax[1].set_title('')

plt.tight_layout()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC
#+CAPTION: Shortwave radiation anomalies w.r.t daily climatology [2001-2017]. Definitely see northward propagating anomalies along 90°E. Propagation is most evident for lat > 8°N. Winter is quite for lat > 10.
#+RESULTS:
[[file:images/90e-swr-anom.png]]

Let's try 10-80day filter like cite:Sengupta2001a
#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SWR.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

if 'swr' not in locals():
    swr = xr.open_mfdataset('../datasets/tropflux/swr*.nc')

swr['swr'].load()

bp = (
    swr['swr'].sel(longitude=[85, 90], method='nearest')
    .pipe(BandPassButter, freqs, dt=1, dim='time')
)

bp.sel(time='2014').plot(x='time', row='longitude')

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC
#+CAPTION: bandpass filter yields same results as above (slightly smoother).
#+RESULTS:
[[file:images/bandpass-SWR.png]]

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-spec.png
dcpy.ts.PlotSpectrum(swr['swr'].sel(latitude=[15, 12, 8], longitude=90, method='nearest'), multitaper=True, nsmooth=5, scale=5)
dcpy.plots.linex([1/10.0, 1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0, 1/120, 1/180, 1/360])
plt.title('Tropflux SWR spectra along 90E')
plt.legend(('15N', '12N', '8N'))
#+END_SRC
#+CAPTION: Spectra of SW radiation along 90°E. Seasonal cycle harmonics are very evident 360, 180, 90, 45. 120-day peak at 8N, 12N.
#+RESULTS:
[[file:images/90e-swr-spec.png]]

** SST analysis
*** test snapshot
#+CALL: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907o-U.png
mur['sst'].isel(time=1).plot()
#+END_SRC
#+CAPTION: Test snapshot
#+RESULTS:
[[file:../images//temp/img3907o-U.png]]
*** spec
#+call: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/mur-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

# psd = xrft.power_spectrum(mur['sst'].sel(lon=90, lat=12), dim=['time'], density=True, window=True, detrend='constant')
scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = mur.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('MUR SST spectra along RAMA line')
plt.legend()
#+END_SRC
#+CAPTION: MUR SST spectra 2013-2016
#+RESULTS:
[[file:images/mur-spectra-RAMA-line.png]]


#+BEGIN_SRC ipython :session :ipyfile images/cmc-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = cmc.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('CMC SST spectra along RAMA line (2007-2017)')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:images/cmc-spectra-RAMA-line.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SST.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]


(cmc['sst'].sel(lon=[85, 90], method='nearest')
           .where(cmc.mask == 1)
           .pipe(BandPassButter, freqs, dt=1, dim='time')
           .sel(time='2014')
           .plot(x='time', row='lon'))

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC

#+RESULTS:
[[file:images/bandpass-SST.png]]
*** SST variance map
#+BEGIN_SRC ipython :session :results none
freqs = [1/30.0, 1/90.0]

bp = dcpy.ts.BandPassButter(sst, freqs=freqs, dim=['time'])
bp = bp.dropna(dim='time', how='all')

# dcpy.ts.PlotSpectrum(mur['sst'].sel(lon=90, lat=12))
# dcpy.plots.linex(freqs)
# dcpy.ts.PlotSpectrum(bp.sel(lon=90, lat=12))
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907dce.png]]
#+BEGIN_SRC ipython :session :results none
import matplotlib.animation

def animate(i):
    import matplotlib.pyplot as plt
    plt.clf()
    hdl = bp.isel(time=i).plot()
    return hdl

anim = mpl.animation.FuncAnimation(plt.gcf(), animate)

anim.save('sst-iso.mp4', fps=5)
#+END_SRC
** scalogram?
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgu5NuXe.png
dcpy.ts.plot_detailed_scalogram(m.tropflux.swr.dropna(dim='time'))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[336]:
#+BEGIN_EXAMPLE
  array([<matplotlib.axes._subplots.AxesSubplot object at 0x7f1822c49978>,
  <matplotlib.axes._subplots.AxesSubplot object at 0x7f1822bf5a20>],
  dtype=object)
#+END_EXAMPLE
:END:

* vel spectra
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907nzu.png
u = rama.SelectVar('u', region=dict(lon=90, lat=12))
v = rama.SelectVar('v', region=dict(lon=90, lat=12))
KE = 0.5*np.hypot(u,v)

dcpy.ts.PlotSpectrum(KE)
dcpy.ts.PlotSpectrum(KE, multitaper=True)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907nzu.png]]


#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907fRQ.png
np.sqrt(N2).plot()
plt.ylabel('N (1/s)')
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907fRQ.png]]

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907mHE.png
KE = np.hypot(ra12.vel.u, ra12.vel.v)*2

dcpy.ts.PlotSpectrum(KE, dt=30*60.0, multitaper=False, label='KE 10m')

# figure out N²
woa = dcpy.oceans.ReadWoa(lon=90, lat=12, return_xr=True)
N2, _, pn2 = sw.bfrq(woa['S'], woa['T'], woa['depth'], lat=12)

N2 = xr.DataArray(np.squeeze(N2), coords=[np.squeeze(pn2)], dims=['depth'])
N = np.sqrt(N2)
omg, K_omg, P_omg, _, _, _ = dcpy.oceans.GM(lat=12.0,
                                            N=N.sel(depth=10, method='nearest').values,
                                            N0=N.sel(depth=50, method='nearest').values)

# plot frequency spectra
ax = plt.gca()
ax.loglog(omg/(2*np.pi), 2*np.pi*K_omg, label='GM81 KE')
ax.loglog(omg/(2*np.pi), 2*np.pi*P_omg, label='GM81 PE')
ax.legend(frameon=False)
ax.set_title('energy spectra')
ax.set_xlabel('frequency (cps)')
ax.set_ylabel('power spectral density (m^2/s^2/cps)')

#+END_SRC
#+CAPTION: Attempt at GM spectra for KE
#+RESULTS:
[[file:../images//temp/img3907mHE.png]]

* TS plots

#+BEGIN_SRC ipython :session :ipyfile images/TS.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.TSPlot(ax=ax3)
nrl5.TSPlot(ax=ax1)
ra12.TSPlot(ax=ax2)

ax1.set_xlim([32, 36])
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//TS.png]]

#+BEGIN_SRC ipython :session :ipyfile images/KT-seasonal.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.ChipodSeasonalSummary(ax=ax3)
nrl5.ChipodSeasonalSummary(ax=ax1)
ra12.ChipodSeasonalSummary(ax=ax2)

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//KT-seasonal.png]]
* MLD climatology

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907e_A.png
mld = dcpy.oceans.argo_mld_clim()

ax = plt.gca()
for lat in range(0, 22, 2):
    mld.mld_da_mean.sel(lon=90, lat=lat,
                        method='nearest', tolerance=1).plot(ax=ax, label=str(lat))

plt.title('lon=90.5')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907e_A.png]]

* [#B] ARGO data : S_min and S_max
[[file:../images//argo-smin-smax.png]]
* code tests
** MLD calc
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgJlnzfg.png
f, ax = plt.subplots(1,3)

it = 35000
ra15.ctd['T'].isel(time=it).plot(ax=ax[0])
dcpy.plots.linex(ra15.ild.isel(time=it), ax=ax[0])

ra15.ctd['S'].isel(time=it).plot(ax=ax[1])
dcpy.plots.linex(ra15.sld.isel(time=it), ax=ax[1])

ra15.ctd['ρ'].isel(time=it).plot(ax=ax[2])
dcpy.plots.linex(ra15.mld.isel(time=it), ax=ax[2])
#+END_SRC

#+RESULTS:
:RESULTS:
:END:
* OSM 2018 figures
** rama vs nrl | met & K_T
#+BEGIN_SRC ipython :session :results none
def full_extent(ax, pad=0.0):
    """Get the full extent of an axes, including axes labels, tick labels, and
    titles."""

    from matplotlib.transforms import Bbox
    # For text objects, we need to draw the figure first, otherwise the extents
    # are undefined.
    ax.figure.canvas.draw()
    items = [ax, ax.title, ax.xaxis.label, ax.yaxis.label]
    items += (ax.get_xticklabels() + ax.get_yticklabels())
    bbox = Bbox.union([item.get_window_extent() for item in items])

    return bbox.expanded(1.0 + pad, 1.0 + pad)

ax, hkr = ra12.met_turb_summary(region={'time': '2014', 'depth': 15}, naxes=2)
ax['met'].set_xlabel('')
plt.gcf().set_size_inches((6, 3.25))

ktrama = (ra12.KT.sel(time='2014')
         .dropna(dim='depth', how='all')
         .resample(time='D').mean(dim='time')
         .isel(depth=0))
hdl_pointr = ax['Kt'].plot(ktrama.time[-1], ktrama[-1],
                           'o', ms=4, color=hkr[0].get_color(), clip_on=False)
hdl_textr = ax['Kt'].text('2014-12-31', ktrama[-1], '  12N 15m', ha='left',
                          clip_on=False, color=hkr[0].get_color())

arrowprops = dict(arrowstyle="<->", connectionstyle="arc3")
ha1 = ax['Kt'].annotate("",
                        xy=('2014-04-15', 5e-5), xycoords='data',
                        xytext=('2014-04-15', 1), textcoords='data',
                        arrowprops=arrowprops)
ha2 = ax['Kt'].annotate("",
                        xy=('2014-07-15', 5e-3), xycoords='data',
                        xytext=('2014-07-15', 1), textcoords='data',
                        arrowprops=arrowprops)
ha3 = ax['Kt'].annotate("",
                        xy=('2014-10-9', 5e-2), xycoords='data',
                        xytext=('2014-10-9', 10), textcoords='data',
                        arrowprops=arrowprops)

htxt = []
htxt.append(
    ax['met'].text('2014-02-01', 0.35, 'NE', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-04-15', 0.35, 'NESW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-07-16', 0.35, 'SW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-10-20', 0.35, 'SWNE', va='bottom', zorder=-1)
)

ax['met'].set_xlim(('2014-01', '2015-01'))
ax['met'].set_ylim([0, 0.35])
ax['Kt'].xaxis.set_major_formatter(mpl.dates.DateFormatter('%b-%d'))
ax['Kt'].set_xlabel('2014')
ax['Kt'].set_ylabel('Daily avg. $K_T$ (m²/s)')
ax['Kt'].xaxis.set_tick_params(rotation=0)
plt.tight_layout()
plt.savefig('images/rama-vs-nrl-0.png', bbox_inches='tight')

ktnrl = (nrl5.KT.sel(time='2014')
         .dropna(dim='depth', how='all')
         .resample(time='D').mean(dim='time')
         .isel(depth=1))
hdl = ax['Kt'].plot(ktnrl.time, ktnrl, lw=0.75)
hdl_pointn = ax['Kt'].plot(ktnrl.time[-1], ktnrl[-1],
                           'o', ms=4, color=hdl[0].get_color(), clip_on=False)
hdl_textn = ax['Kt'].text('2014-12-31', ktnrl[-1], '  8N 100m', ha='left',
                          clip_on=False, color=hdl[0].get_color())

for ha in [ha1, ha2, ha3]:
    ha.set_visible(False)

ha = []
arrowprops = dict(arrowstyle="->", connectionstyle="arc3")
ha.append(ax['Kt'].annotate("near-molecular!",
                       xytext=('2014-04-01', 7e-6), xycoords='data',
                       xy=('2014-04-15', 2e-7), textcoords='data',
                            arrowprops=arrowprops, ha='right'))

plt.gcf().set_size_inches((6, 3.25))
plt.savefig('images/rama-vs-nrl-1.png', bbox_inches='tight')

# extent = full_extent(ax['Kt']).transformed(f.transFigure.inverted())
# # We can now make the rectangle in figure coords using the "transform" kwarg.
# rect = mpl.patches.Rectangle([extent.xmin, extent.ymin],
#                              extent.width, extent.height,
#                              facecolor='yellow', edgecolor='none', zorder=-1,
#                              transform=fig.transFigure)
# f.patches.append(rect)

ax['Jq0'].set_visible(False)
ax['met'].set_visible(False)

plt.savefig('images/rama-vs-nrl-KT.png', bbox_inches='tight')

hkr[0].set_visible(False)
hdl_textr.set_visible(False)
hdl_pointr[0].set_visible(False)

ha.append(ax['Kt'].annotate("Arabian Sea water arrives",
                       xytext=('2014-06-01', 1e-3), xycoords='data',
                       xy=('2014-07-01', 5e-7), textcoords='data',
                            arrowprops=arrowprops, ha='right'))

ha.append(ax['Kt'].annotate("Near-inertial wave burst",
                       xytext=('2014-09-01', 1e-2), xycoords='data',
                       xy=('2014-07-27', 1e-3), textcoords='data',
                            arrowprops=arrowprops, ha='center'))

plt.savefig('images/nrl5-KT-labels.png', bbox_inches='tight')

#ax['met'].set_visible(True)

# (turb.S.sel(**nrlregion)
#  .dropna(dim='depth', how='all')
#  .resample(time='D').mean(dim='time')
#  .isel(depth=0)).plot.line(x='time', ax=ax['met'],
#                            color=hdl[0].get_color())

# ax['met'].set_ylim([34, 36])
# ax['met'].set_title('')
# ax['Kt'].xaxis.set_tick_params(rotation=0)
# plt.savefig('images/rama-vs-nrl-KT-nrl-sal.png', bbox_inches='tight')

#+END_SRC
[[file:images/rama-vs-nrl-1.png]]
** rama vs nrl | K_T distributions
#+BEGIN_SRC ipython :session :ipyfile images/rama-vs-nrl-kt-violin.png
<<define-vert_distrib>>

moor_mask = np.logical_or(
    np.logical_and(KTdf.moor == 'RAMA12', np.round(KTdf.depth)==15),
    np.logical_and(KTdf.moor == 'NRL5', np.round(KTdf.depth) == 104))
new_deep_mask = np.logical_and(mask_deep, moor_mask)
subset = KTdf[moor_mask]

bins = [1018, 1022.5, 1026]
subset = bin_ktdf(subset, bins)

subset.loc[subset.moor == 'NRL5', 'z'] -= 85
subset.loc[subset.bin == 'ML', 'z'] -= 10
subset.loc[subset.bin == 'BL', 'z'] -= 5

with plt.rc_context({'font.size': 8}):
    f, ax = vert_distrib(subset, subset.bin, varname='KT',
                         label_moorings=False, label_bins=True, adjust_fig=False,
                         width=8, percentile=False, add_offset=False)

    for aa in ax:
         ax[aa].yaxis.set_visible(True)
         ax[aa].spines['left'].set_visible(True)

    ax['NE'].set_yticklabels(['', '', '15', '//', '', '100'])
    ax['NE'].set_ylim([28, 0])
    plt.gcf().set_size_inches((6.2, 1.8))
    plt.suptitle('$\log_{10}$ hourly averaged $K_T$ (m²/s)', y=-0.15, va='baseline')
    plt.subplots_adjust(wspace=0.07)
    sns.despine(fig=f, left=False, bottom=False, trim=True)

plt.savefig('images/rama-vs-nrl-kt.svg')
# plt.tight_layout(w_pad=-1)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1754]:
:END:

** nrl5 adcp near-inertial
#+BEGIN_SRC ipython :session :ipyfile images/nrl5-near-inertial-adcp.png
#from dcpy.ts import xfilter
#f,  axx = plt.subplots(3, 1, sharex=True)
# ax = dict(Kt=axx[0], u=axx[1], v=axx[2])
# (nrl5.KT.isel(depth=1)
# .sel(**nrl5.select_region(['Storm+IW'])).plot(ax=ax['Kt']))
# ax['KT'].set_yscale('log')
# axv
with plt.rc_context({'font.size': 14}):
    ax, hc = nrl5.PlotVel(region='Storm+IW')
    ax['u'].set_ylim([250, 0])
    ax['v'].set_ylim([250, 0])
    ax['v'].set_xlabel('')

arrowprops = dict(arrowstyle="<-", connectionstyle="arc3")

hanno.remove()
hanno = ax['v'].annotate("",
                       xy=('2014-07-18', 70), xycoords='data',
                       xytext=('2014-08-7', 150), textcoords='data',
                       arrowprops=arrowprops)
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[1681]:
[[file:images/nrl5-near-inertial-adcp.png]]
:END:

** χpod depths on ARGO climatology
#+BEGIN_SRC ipython :session :ipyfile images/argo-clim-χpod-depths.png
with plt.rc_context({'font.size': 15,
                     'axes.facecolor': 'white',
                     'savefig.transparent': False}):

   bay.mark_χpod_depths_on_clim()
   plt.gcf().set_size_inches(8, 6)
   plt.savefig('images/argo-clim-χpod-depths.svg')

#+END_SRC
#+RESULTS:
:RESULTS:
# Out[16]:
[[file:images/argo-clim-χpod-depths.png]]
:END:

* sampling considerations
** ISO signals
Can I  see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907IKt.png
dt = 1  # day
N = 365  # number of days
smth = [1, 2, 3, 4, 5]  # nsmooth
periods = np.array([10.0, 20.0, 30.0, 50.0, 60.0, 90.0])  # peaks

ax = []
ax.append(plt.subplot(211))
ax.append(plt.subplot(212))

t = np.arange(N)
ts = dcpy.ts.synthetic(N, dt, 1, -3)

for tt in periods:
    ts += 1e3 * np.sin(2*3.14/tt * t)

for ss in smth:
    dcpy.ts.PlotSpectrum(ts, ax=ax[0], scale=5**-ss,
                         nsmooth=ss, label=str(ss))
    dcpy.ts.PlotSpectrum(ts, ax=ax[1], scale=5**-ss,
                         nsmooth=ss, label=str(ss),
                         multitaper=True)

ax[0].set_title('Varying smoothing | ' + str(N) + ' day daily timeseries')
ax[1].set_title('multitaper')
plt.legend()
# dcpy.ts.PlotSpectrum(ts, nsmooth=smth, multitaper=True)
dcpy.plots.linex(1/periods)
#+END_SRC
#+CAPTION: Can I see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+RESULTS:
[[file:../images//temp/img3907IKt.png]]o
** χpod depths for RAMA17

#+name: read-rama-10m
#+BEGIN_SRC ipython :session :results none
import xarray as xr
import pandas as pd

rama10 = xr.open_mfdataset('rama/data/t*90e_10m.cdf')
salhr = xr.open_mfdataset('rama/data/s[0-9]*90e_hr.cdf')

newtrange = pd.date_range(start=rama10.time.values.min(),
                          end=rama10.time.values.max(), freq='10min')
#+END_SRC

#+call: read-rama-10m()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427kYC.png
# ra12 = xr.open_dataset('rama/data/t12n90e_10m.cdf')
T = rama10.T_20.sel(depth=[10, 20, 40, 60])
T = T.reindex({'time': newtrange})
T = T.where(T < 40).squeeze()
Tz = -T.diff(dim='depth')/T.depth.diff(dim='depth')
Tz['depth'] = (T.depth.values[:-1] + T.depth.values[1:])/2
Tz.name = '$T_z$'

S = salhr.S_41.sel(lat=12, depth=[10, 20, 40, 60])
S = S.reindex({'time': pd.date_range(start=S.time.values.min(),
                                     end=S.time.values.max(), freq='1H')})
S = S.where(S < 40).squeeze()
Sz = -S.diff(dim='depth')/S.depth.diff(dim='depth')
Sz.name = '$S_z$'

N2 = -9.81 * (-1.7e-4 * Tz + 7.6e-4 * Sz)
#+END_SRC

#+RESULTS:
[[file:images/temp/img10427kYC.png]]

#+BEGIN_SRC ipython :session :ipyfile images/min-Tz-rama.png
min_Tz = 1e-3

def count(x):
    return (x.where(np.abs(x) < 1e-3).count(dim='time'))/x.count(dim='time')*100

lat = [15, 12, 8, 4, 0]

f, ax = plt.subplots(len(lat), 1, sharex=True, sharey=True)

for (axx, ll) in zip(ax, lat):
    dcpy.plots.offset_line_plot(Tz.sel(lat=ll)
                                .groupby('time.dayofyear')
                                .apply(count),
                                x='dayofyear', y='depth',
                                offset=0, remove_mean=False, ax=axx)
    axx.set_title(str(ll)+'N')

f.suptitle('% observations in a day with $T_z$ < 1e-3', y=1.05)
ax[0].set_ylim([0, 100])

ax[-1].set_xlabel('day of year')

plt.tight_layout()
plt.gcf().set_size_inches((6.5, 6.5))
#+END_SRC
#+CAPTION: How likely is it that we can compute χ for an instrument at 30m vs instrument at 45m
#+RESULTS:
[[file:images/min-Tz-rama.png]]

[[file:images/li-et-al-may-oct-mld.png]]

#+call: read-ra12()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427SMu.png

#+END_SRC
* χ processing
** Winters & D'Asaro methodology
*** Smyth et al 2001
As of now, it looks like the Smyth approach is to use a single value for a patch. The Winters & D'Asaro approach is the "high resolution" version I guess.
*** Convection
*** determining sign
1. Use mooring dT/dz (10-20m scale)
2. Use sign of hourly moving median (6 points).
3. For |dT/dz| < 1e-3; use sign of two hourly median

[[file:~/work/bay/images/wda-tz-sign.png]]

[[file:~/work/bay/images/wda-tz-sign-2.png]]

*** noise levels
The differentiator uses the /analog/ signal as input; so it never differentaties bit-noise in T. i.e. the noise floor in Tp and T are _different._

~chi_chi_proc~ checks for Tp noise floor.

When doing the WDA estimate, I need to check for the T noise floor when sorting temperature.
*** Use just the sorted gradient or re-evalute with mooring gradient?
[[file:images/wda-Jq-comparison.png]]
** really low turbulence

- instrument is being pumped through what looks like really quiet layers.
- 15 sec period roughly : signal is also seen in pressure time series.

[[file:images/518-low-turbulence.png]]
#+CAPTION: zoom-in of first image
[[file:images/518-low-turbulence-zoom-1.png]]
#+CAPTION: zoom-in of first image
[[file:images/518-low-turbulence-zoom-2.png]]
** 1 sec IC fits
Use 526 2017-07-06 to test: this has kstart, kstop, ki saved for the entire year.

1. I can get ~k_stop~ decently well in ~combine_turbulence~. Not doing that well with ~k_start.~
2. Part of the reason is that I'm not actually getting k_b right which is mystifying.
3. If I can do ~k_start~ I can also check how many points are in fitting range.
   1. Though really, I should redo all calculations :(.

#+CAPTION: Comparing estimated k_b with saved k_b. Why is this wrong?!  This might be because chi, epsilon is recalculated right at the end but the k_b I saved was not.
[[file:images/526-k_b-est-saved.png]]

#+CAPTION: This figure show histograms of ε when k_i > k_{stop}. It compares one where I estimate kstop and other where kstop was saved during iterations.
[[file:images/526-eps-ki-filter-hist.png]]

#+CAPTION: Here I compare ε distributions after when k_i < k_stop (straddling the transition) and k_i < k_start (always in vc range). These use the saved ranges.
[[file:images/526-chi-ki-filtering.png]]
** using pressure instead of accelerometer

Tested with RAMA14-810
#+CAPTION: Δp is quantized! Bit resolution ≈ 2 cm. I smooth over 0.5 seconds.
[[file:images/810-p-velz-a-velz.png]]

#+ATTR_HTML: :width 50%
#+CAPTION: Agrees with Perlin & Moum (2012), though here $dp/dt$ is smaller.
[[file:images/810-compare-spd.png]]
#+CAPTION: mean/median larger by a factor of 2 (only tested for 20-Feb-2015)
[[file:images/810-compare-chi-eps.png]]

#+CAPTION: slope ≈ 1.5 (only tested for 20-Feb-2015)
[[file:images/810-compare-hist2-chi-eps.png]]

bibliography:~/Papers/bibtexLibrary.bib
* Masking stuff
N², IC fits get rid of questionable fits.
Question: How much does an IC fit contaminate χ?
* Paper figures
** summary paper
*** Figure 1: map + depths on argo climatology
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgeMzvg3.png
import cartopy.crs as ccrs

with plt.rc_context({'font.size': 11,
                     'axes.facecolor': 'white',
                     'savefig.transparent': False}):

    f = plt.figure(constrained_layout=True)

    n=3
    n0=2
    # gs = mpl.gridspec.GridSpec(2, n, figure=f)
    # ax1 = f.add_subplot(gs[:, :n0], projection=ccrs.PlateCarree())
    # ax2 = f.add_subplot(gs[0, n0:])
    # ax3 = f.add_subplot(gs[1, n0:])

    gs = mpl.gridspec.GridSpec(n, 2, figure=f)
    ax1 = f.add_subplot(gs[:n0, :], projection=ccrs.PlateCarree())
    ax2 = f.add_subplot(gs[n0:, 0])
    ax3 = f.add_subplot(gs[n0:, 1])

    f.set_size_inches((4.75, 8))

    bay.make_labeled_map(ax=ax1)
    bay.mark_χpod_depths_on_clim(ax=[ax2, ax3])

    for label, ax in zip(['a', 'b', 'c'], [ax1, ax2, ax3]):
        ax.text(0.025, 0.05, label+')', transform=ax.transAxes,
                fontsize='medium')

    [tt.set_rotation(30) for tt in ax1.get_xticklabels()]
    ax3.set_ylabel('')
    ax3.set_yticklabels([])

    plt.savefig('images/paper1/map.pdf', bbox_inches='tight')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[140]:
:END:
*** RAMA vs NRL
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgcqnSXp.png
# def full_extent(ax, pad=0.0):
#     """Get the full extent of an axes, including axes labels, tick labels, and
#     titles."""

#     from matplotlib.transforms import Bbox
#     # For text objects, we need to draw the figure first, otherwise the extents
#     # are undefined.
#     ax.figure.canvas.draw()
#     items = [ax, ax.title, ax.xaxis.label, ax.yaxis.label]
#     items += (ax.get_xticklabels() + ax.get_yticklabels())
#     bbox = Bbox.union([item.get_window_extent() for item in items])

#     return bbox.expanded(1.0 + pad, 1.0 + pad)

from dcpy.plots import annotate_end

def int_spec(spec, lofreq, hifreq):
    ''' Integrate spectrogram between lofreq, hifreq.
        Returns time series.'''

    subset = (spec.where(np.logical_and(spec.freq > lofreq,
                                        spec.freq < hifreq))
              .dropna(dim='freq', how='all'))

    timeseries = xr.DataArray(np.trapz(subset, subset.freq),
                              dims='time', coords={'time': subset.time})

    return timeseries


f, axx = plt.subplots(5, 1, sharex=True, constrained_layout=True)
f.set_constrained_layout_pads(hspace=0.001)
axes = dict(met12=axx[0], met8=axx[2],
            KT=axx[1], Tz=axx[3], shear=axx[4])

ax, hkr = ra12.met_turb_summary(region={'time': '2014', 'depth': 15},
                                ax=axx[:2])
axn, hkn = nrl5.met_turb_summary(region={'time': '2014', 'depth': 104.0},
                                 ax=[axx[2], axx[1]])

hdl_pointr, hdl_textr = annotate_end(hkr[0], label='12N 15m')

hdl_pointn, hdl_textb = annotate_end(hkn[0], label='8N 104m')

htxt = [axes['met12'].text(time, 0.35, season, va='bottom', zorder=-1)
        for time, season
        in zip(['2014-02-01', '2014-04-15', '2014-07-16', '2014-10-20'],
               ['NE', 'NESW', 'SW', 'SWNE'])]

axes['met12'].set_xlim(('2014-01', '2015-01'))
axes['met12'].set_ylim([0, 0.35])
axes['KT'].grid(False, axis='x')
axes['KT'].grid(True, which='both', axis='y')

plt.sca(axes['shear'])
plt.cla()
shear_pod = interp_shear(nrl5.vel.uz) + 1j*interp_shear(nrl5.vel.vz)
shearspec = (dcpy.ts.Spectrogram(np.abs(shear_pod), dim='time',
                                nfft=30*24, shift=2*24,
                                multitaper=True, decimate=False, dt=1/24)
             .sel(time='2014'))

hm2 = (int_spec(shearspec, 0.9*(fM2-f0), 1.1*(fM2+f0))
       .plot(ax=axes['shear'], label='$M_2$'))
hm4 = (int_spec(shearspec, 0.9*(fM2*2-f0), 1.1*(fM2*2-f0))
       .plot(ax=axes['shear'], label='$M_4$'))
hf0 = (int_spec(shearspec, 0.6*f0, 1.5*f0)
       .plot(ax=axes['shear'], label='$f_0$', color='k'))
_, htm2 = annotate_end(hm2[0], '$M_2$')
_, htm4 = annotate_end(hm4[0], '$M_4$')
_, htf0 = annotate_end(hf0[0], '$f_0$')
htm4.set_va('top')

(ra12.Tz.isel(depth=0)
 .resample(time='D').mean(dim='time')
 .plot(ax=axes['Tz'], _labels=False))
(nrl5.Tz.isel(depth=1)
 .resample(time='D').mean(dim='time')
 .plot(ax=axes['Tz'], _labels=False))

[aa.set_xlabel('') for aa in axx]
[aa.set_title('') for aa in axx]
axes['shear'].xaxis.set_tick_params(rotation=0)
axes['shear'].xaxis.set_major_formatter(mpl.dates.DateFormatter('%b-%d'))
axes['shear'].set_xlabel('2014')

fmt = axes['shear'].yaxis.get_major_formatter()
fmt.set_scientific(True)
axes['shear'].yaxis.set_major_formatter(fmt)

x0 = 0.025
y0 = 0.8
axes['shear'].text(x0, y0, 'Shear variance at 8N', transform=axes['shear'].transAxes)
axes['Tz'].text(x0, y0, '$T_z$ [C/m]', transform=axes['Tz'].transAxes)
axes['met12'].text(x0, y0, 'Forcing at 12N', transform=axes['met12'].transAxes)
axes['KT'].text(x0, y0, 'Daily avg. $K_T$ [m$^2$/s]', transform=axes['KT'].transAxes)
axes['met8'].text(x0, y0, 'Forcing at 8N', transform=axes['met8'].transAxes)

dcpy.plots.liney(0, ax=axes['Tz'])
axes['Tz'].set_ylim([-0.1, 0.3])
axes['KT'].set_ylabel('')
f.set_size_inches((7, 6))

f.savefig('images/paper1/rama-vs-nrl.pdf')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[757]:
[[file:images/temp/imgcqnSXp.png]]
:END:

*** Vertical profile
*** Seasonal spatial variations
#+BEGIN_SRC ipython :session :results none
import cartopy.crs as ccrs

if 'oscar' not in locals():
    oscar = (xr.open_mfdataset('/home/deepak/work/datasets/oscar/oscar_vel*.nc',
                              concat_dim='time')
             .sel(latitude=slice(bay.region['lat'].stop, bay.region['lat'].start),
                  longitude=bay.region['lon'],
                  time=slice('2013-12-01', '2014-11-30')))
    oscar = (oscar
             .groupby(oscar.time.monsoon.labels).mean('time')
             .load().squeeze()
             .sortby('latitude'))

if 'ssha' not in locals():
    ssha = (xr.open_dataset('../datasets/ssh/'
                            + 'dataset-duacs-rep-global-merged-allsat-phy-l4-v3_1522711420825.nc',
                            autoclose=True)
            .sel(time=slice('2013-12-01', '2014-11-30'))
            .load())
    ssha['EKE'] = 0.5 * (ssha.ugosa**2 + ssha.vgosa**2)
    eke = (ssha.EKE.groupby(ssha.EKE.time.monsoon.labels)
           .mean(dim='time'))

if 'tropflux' not in locals():
    tropflux = (xr.open_mfdataset('../datasets/tropflux/tau*_tropflux_1d_*.nc')
                .drop('tau')
                .sel(time=slice('2013-12-01', '2014-11-30'),
                     latitude=slice(2, 25),
                     longitude=slice(78, 96))
                .load())
    tropflux = (tropflux.groupby(tropflux.time.monsoon.labels)
                .mean(dim='time'))

if 'trmm' not in locals():
    trmm = (dcpy.oceans.read_trmm()
            .sel(time='2014',
                 lat=slice(2, 25),
                 lon=slice(78, 96)))
    trmm = (trmm.groupby(trmm.time.monsoon.labels)
            .sum(dim='time')
            .load())

if 'sss' not in locals():
    aq = dcpy.oceans.read_aquarius()
    sss = aq.sss.sel(latitude=slice(2, 25),
                     longitude=slice(78, 96))
    sss = (sss.groupby(sss.time.monsoon.labels)
           .mean(dim='time')
           .load())

# N = 200
# cmap = mpl.cm.GnBu(np.arange(N))
# cmap[:, -1] = np.linspace(0.25, 0.5, N)
# ppt_cmap = mpl.colors.ListedColormap(cmap[60:])

raincolor = '#3BBBC5'
cmap = np.asarray(sns.light_palette(raincolor, n_colors=10))
cmap[:, -1] = 0.35
ppt_cmap = mpl.colors.ListedColormap(cmap)

seasons = ['NE', 'NESW', 'SW', 'SWNE']

g = xr.plot.FacetGrid(eke, col='monsoon',
                      figsize=(8, 5),
                      subplot_kws=dict(projection=ccrs.PlateCarree()),
                      constrained_layout=True)

axes = dict(zip(seasons, g.axes.flat))

g.map_dataarray(xr.plot.contourf,
                'longitude', 'latitude',
                cmap=mpl.cm.OrRd,
                levels=np.linspace(8e-3, 0.3, 40),
                add_colorbar=False)

g.map_dataarray(xr.plot.contour,
                data=sss,
                x='longitude', y='latitude',
                levels=[29, 30, 31, 32, 33, 34],
                colors='k', linewidths=1.5,
                add_colorbar=False)

for idx, aa in enumerate(ax.flat):
    hlabs = aa.clabel(g._mappables[4+idx], fmt='%2.f', fontsize='smaller')

g.map(bay.plot_coastline)

g.set_xlabels('Longitude')
g.set_ylabels('Latitude')
g.set_titles('')
[aa.set_xticks(range(80, 96, 4)) for aa in g.axes.flat]
[aa.set_yticks(range(4, 24, 4)) for aa in g.axes.flat]

tflux = tropflux.sel(latitude=slice(None, None, 3),
                     longitude=slice(None, None, 3))

osc = oscar.sel(latitude=slice(None, None, 2),
                longitude=slice(None, None, 2))

for season in axes:
    axes[season].set_extent([80, 94, 4, 24])

    # htflux = axes[season].quiver(tflux.longitude, tflux.latitude,
    #                              tflux.taux.sel(monsoon=season),
    #                              tflux.tauy.sel(monsoon=season),
    #                              scale=0.7, zorder=5)

    hoscar = axes[season].quiver(osc.longitude, osc.latitude,
                                 osc.u.sel(monsoon=season),
                                 osc.v.sel(monsoon=season),
                                 width=0.006,
                                 scale=4)

    axes[season].text(0.05, 0.875, season,
                      transform=axes[season].transAxes,
                      color='k', zorder=10)

g.map(bay.mark_moors,
      color='black', colortext='white',
      fontsize=7.5, markersize=9)

plt.savefig('images/paper1/spatial-maps.pdf', transparent=False,
            bbox_inches='tight')

# clim = (aq.sss.sel(longitude=slice(75, 98),
#                    latitude=slice(0, 24))
#         .groupby('time.month').mean(dim='time'))
# clim.plot(col='month', col_wrap=3, robust=True)
# hc = clim.plot.contour(col='month', col_wrap=3, levels=np.arange(29, 36), Colors='k')
# plt.clabel(hc, fmt='%2.0f')
# pptlevels=[600,  1200, 1800]
# ppt = trmm.sel(monsoon=season).precipitation
# hppt = (ppt.where(ppt > pptlevels[0]-2)
#         .plot.contourf(ax=axes[season], x='lon', y='lat',
#                        levels=pptlevels,
#                        cmap=ppt_cmap, zorder=4,
#                        add_colorbar=False))
# (ppt.where(ppt > pptlevels[0]-2)
#  .plot.contour(ax=axes[season], x='lon', y='lat',
#                levels=pptlevels, zorder=4,
#                colors=raincolor, linewidths=1))

# cmap = (sns.blend_palette(
#     [[0.988235, 0.988235, 0.992157],
#      [0.811765, 0.831373, 0.886275],
#      [0.627451, 0.678431, 0.788235],
#      [0.521569, 0.615686, 0.729412],
#      [0.584314, 0.698039, 0.749020],
#      [0.690196, 0.803922, 0.772549],
#      [0.847059, 0.905882, 0.796078],
#      [1.000000, 0.980392, 0.756863],
#      [0.996078, 0.839216, 0.447059],
#      [0.996078, 0.670588, 0.286275],
#      [0.992157, 0.501961, 0.219608],
#      [0.968627, 0.270588, 0.152941],
#      [0.835294, 0.070588, 0.125490],
#      [0.674510, 0.000000, 0.149020],
#      [0.509804, 0.000000, 0.149020]],
#     n_colors=21, as_cmap=True))

#+END_SRC


**** old one
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgRUuf4A.png
bay = importlib.reload(bay)

moor_names = {
'ra12': 'RAMA 12N',
'ra15': 'RAMA 15N',
'nrl1': 'NRL 1',
'nrl3': 'NRL 3',
'nrl4': 'NRL 4',
'nrl5': 'NRL 5',
}

import cartopy.crs as ccrs

if 'ssha' not in locals():
    ssha = (xr.open_dataset('../datasets/ssh/'
                            + 'dataset-duacs-rep-global-merged-allsat-phy-l4-v3_1522711420825.nc',
                            autoclose=True)
            .sel(time='2014')
            .load())
    ssha['EKE'] = 0.5 * (ssha.ugosa**2 + ssha.vgosa**2)
    eke = (ssha.EKE.groupby(ssha.EKE.time.monsoon.labels)
           .mean(dim='time'))

if 'tropflux' not in locals():
    tropflux = (xr.open_mfdataset('../datasets/tropflux/tau*_tropflux_1d_*.nc',
                                  autoclose=True)
                .drop('tau')
                .sel(time='2014',
                     latitude=slice(2, 25),
                     longitude=slice(78, 96))
                .load())
    tropflux = (tropflux.groupby(tropflux.time.monsoon.labels)
                .mean(dim='time'))

if 'trmm' not in locals():
    trmm = (dcpy.oceans.read_trmm()
            .sel(time='2014',
                 lat=slice(2, 25),
                 lon=slice(78, 96)))
    trmm = (trmm.groupby(trmm.time.monsoon.labels)
            .sum(dim='time')
            .load())

if 'sss' not in locals():
    aq = dcpy.oceans.read_aquarius()
    sss = aq.sss.sel(latitude=slice(2, 25),
                     longitude=slice(78, 96))
    sss = (sss.groupby(sss.time.monsoon.labels)
           .mean(dim='time')
           .load())

def clean_inset_axes(ax):
    ax.set_ylabel('')
    ax.set_xlabel('')
    ax.set_title('')

    ax.grid(True, axis='x', which='both',
            color='w', lw=1)
    ax.grid(False, axis='y', which='major')
    ax.set_axisbelow(True)


# N = 200
# cmap = mpl.cm.GnBu(np.arange(N))
# cmap[:, -1] = np.linspace(0.25, 0.5, N)
# ppt_cmap = mpl.colors.ListedColormap(cmap[60:])

raincolor = '#3BBBC5'
cmap = np.asarray(sns.light_palette(raincolor, n_colors=10))
cmap[:, -1] = 0.35
ppt_cmap = mpl.colors.ListedColormap(cmap)

def make_depth_cmap():

    cmap = dict()
    cmap['ra12'] = sns.color_palette('GnBu', 4)[1:]
    cmap['ra15'] = sns.dark_palette('darkorange', 3)[1:]

    cmap['ra15'].reverse()

    paired = sns.color_palette('Paired')
    del paired[6:8] # orange clashes
    for idx, name in enumerate(['nrl1', 'nrl3', 'nrl4', 'nrl5']):
        cmap[name] = paired[2*idx:2*idx+2]

    return cmap

depth_cmap = make_depth_cmap()

seasons = ['NE', 'NESW', 'SW', 'SWNE']

f = plt.figure(constrained_layout=True)
gs = mpl.gridspec.GridSpec(12, 3, figure=f)

axes = dict()
insets = dict()
for idx, seas in enumerate(seasons):
    axes[seas] = f.add_subplot(gs[slice(idx*3, idx*3+3), 1],
                               projection=ccrs.PlateCarree())
    itop = idx*3
    insets[seas] = dict()
    insets[seas]['ra15'] = f.add_subplot(gs[itop, 2])
    insets[seas]['nrl5'] = f.add_subplot(gs[itop+2, 2])
    insets[seas]['ra12'] = f.add_subplot(gs[itop+1, 2])

    insets[seas]['nrl4'] = f.add_subplot(gs[itop, 0])
    insets[seas]['nrl3'] = f.add_subplot(gs[itop+1, 0])
    insets[seas]['nrl1'] = f.add_subplot(gs[itop+2, 0])

    for m in insets[seas]:
        insets[seas][m].text(0.95, 0.95, moor_names[m],
                             transform=insets[seas][m].transAxes,
                             ha='right', va='top', fontsize=9)
        insets[seas][m].spines['left'].set_visible(False)
        insets[seas][m].tick_params(direction='in', pad=2)


for season in axes:
    bay.plot_coastline(ax=axes[season])
    axes[season].set_extent([78, 96, 2, 20])
    bay.mark_moors(ax=axes[season],
                   color='black', colortext='white',
                   fontsize=8.5, markersize=9)
    # bay.mark_moors(ax=axes[season], color='k')

    hdl = (eke.sel(monsoon=season)
           .plot.contourf(ax=axes[season], x='longitude', y='latitude',
                          cmap=mpl.cm.OrRd,
                          levels=np.linspace(8e-3, 0.3, 40),
                          add_colorbar=False))

    hq = axes[season].quiver(tropflux.longitude, tropflux.latitude,
                             tropflux.taux.sel(monsoon=season),
                             tropflux.tauy.sel(monsoon=season),
                             scale=1, zorder=5)

    pptlevels=[600,  1200, 1800]
    ppt = trmm.sel(monsoon=season).precipitation
    hppt = (ppt.where(ppt > pptlevels[0]-2)
            .plot.contourf(ax=axes[season], x='lon', y='lat',
                           levels=pptlevels,
                           cmap=ppt_cmap, zorder=4,
                           add_colorbar=False))
    (ppt.where(ppt > pptlevels[0]-2)
     .plot.contour(ax=axes[season], x='lon', y='lat',
                   levels=pptlevels, zorder=4,
                   colors=raincolor, linewidths=1))

    hsss = (sss.sel(monsoon=season)
            .plot.contour(ax=axes[season],
                          x='longitude', y='latitude',
                          levels=[29, 30, 31, 32, 33, 34],
                          colors='k', linewidths=1))
    plt.clabel(hsss, fontsize='smaller', fmt='%2.0f')

    axes[season].set_title('')

    axes[season].text(0.05, 0.875, season,
                      transform=axes[season].transAxes,
                      color='k', zorder=10)

# axes[season].quiverkey(hq, 0.1, 0.01, 0.1, label='0.1 N/m²',
#                        coordinates='figure')

def map_insets(func, grouped, mname):
    for season, subset in grouped:
        ax = insets[season][mname]
        for iz, zz in enumerate(subset.depth):
            if subset.lon == 90:  # RAMA
                zval = zz
            else:
                zval = subset.z.sel(depth=zz).mean()

            label = '{0:.0f}'.format(zval.values)
            color = depth_cmap[mname][iz]

            func(subset.sel(depth=zz), ax=ax, color=color)

            ax.text(0.95, 0.75-0.23*iz, label+'m', color=color,
                    transform=ax.transAxes, ha='right', va='top',
                    fontsize=9)

        clean_inset_axes(ax)

    return hdl

def hist(subset, ax, color):
    data = (np.log10(subset)
            .resample(time='H').mean(dim='time'))

    # hdl = (data.plot.hist(ax=ax,
    #                       density=True,
    #                       bins=60,
    #                       histtype='step'))

    df = (data.drop(['lat', 'lon'])
          .to_dataframe()
          .reset_index())

    sns.kdeplot(df.KT.dropna(), ax=ax,
                legend=False, color=color)

    ax.set_xlim([-7, -1])
    ax.set_xticks(np.arange(-7, -1, 1))
    ax.set_yticks([])
    ax.set_yticklabels([])

def timeseries(subset, ax):
    hdl = (subset
           .resample(time='D').mean(dim='time')
           .plot.line(x='time', ax=ax,
                      yscale='log'))

for mname, moor in zip(['ra12', 'ra15',
                        'nrl1', 'nrl3', 'nrl4', 'nrl5'],
                       [ra12, ra15, nrl1, nrl3, nrl4, nrl5]):
    grouped = moor.KT.groupby(moor.KT.time.monsoon.labels)
    map_insets(hist, grouped, mname)

for season in ['NE', 'NESW', 'SW', 'SWNE']:
    insets[season]['ra15'].set_xticklabels([])
    insets[season]['ra12'].set_xticklabels([])
    insets[season]['nrl3'].set_xticklabels([])
    insets[season]['nrl4'].set_xticklabels([])

insets['SWNE']['nrl5'].set_xlabel('Hourly averaged $K_T$ [m²/s]')
insets['SWNE']['nrl1'].set_xlabel('Hourly averaged $K_T$ [m²/s]')

insets['NE']['nrl5'].set_ylim([0, 4])
insets['NESW']['nrl5'].set_ylim([0, 4])
for hh in [insets['NE']['nrl5'].get_children()[1],
           insets['NESW']['nrl5'].get_children()[1]]:
    hh.set_in_layout(False)
    hh.set_clip_on(False)

f.set_constrained_layout_pads(wspace=0., hspace=0.,
                              h_pad=0.0, w_pad=-0.1)
f.set_size_inches((6.0, 8.5))

plt.savefig('images/paper1/spatial-maps.pdf',
            transparent=False, pad_inches=0)

# clim = (aq.sss.sel(longitude=slice(75, 98),
#                    latitude=slice(0, 24))
#         .groupby('time.month').mean(dim='time'))
# clim.plot(col='month', col_wrap=3, robust=True)
# hc = clim.plot.contour(col='month', col_wrap=3, levels=np.arange(29, 36), Colors='k')
# plt.clabel(hc, fmt='%2.0f')


cmap = (sns.blend_palette(
    [[0.988235, 0.988235, 0.992157],
     [0.811765, 0.831373, 0.886275],
     [0.627451, 0.678431, 0.788235],
     [0.521569, 0.615686, 0.729412],
     [0.584314, 0.698039, 0.749020],
     [0.690196, 0.803922, 0.772549],
     [0.847059, 0.905882, 0.796078],
     [1.000000, 0.980392, 0.756863],
     [0.996078, 0.839216, 0.447059],
     [0.996078, 0.670588, 0.286275],
     [0.992157, 0.501961, 0.219608],
     [0.968627, 0.270588, 0.152941],
     [0.835294, 0.070588, 0.125490],
     [0.674510, 0.000000, 0.149020],
     [0.509804, 0.000000, 0.149020]],
    n_colors=21, as_cmap=True))

# eke.sel(monsoon='SW').plot.contourf(levels=120, cmap=cmap)
# eke.sel(monsoon='SW').plot.contour(ax=plt.gca(), levels=12,
#                                    colors='#E0E1B8',
#                                    linewidths=0.4)
#+END_SRC

Divide up depths per season
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgXx7AIu.png

plt.figure();
nrl4.KT.z.resample(time='D').mean(dim='time').plot.line(x='time')
nrl4.MarkSeasonsAndEvents()
#+END_SRC
*** tidal shear at NRL5
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgfJCfCZ.png
tidal_shear = dcpy.ts.xfilter(nrl5.vel.shear.interpolate_na('time'),
                              kind='bandpass',
                              flen=np.array([0.8, 1.2]) * 12.42 * 3600)

tidal_temp = dcpy.ts.xfilter(nrl5.ctd['T'],
                             kind='bandpass',
                             flen=np.array([0.9, 1.1]) * 12.42 * 3600)

f, ax = plt.subplots(2, 1, sharex=True)
(tidal_shear.sel(depth=120, method='nearest')
 .resample(time='H').mean(dim='time')
 .plot(x='time', yincrease=False, ax=ax[0]))
(nrl5.KT.resample(time='H').mean(dim='time')
 .plot.line(ax=ax[1], yscale='log', x='time'))

f, ax = plt.subplots(2, 1, sharex=True, constrained_layout=True,
                     gridspec_kw={'height_ratios': [2, 1]})
(tidal_shear.sel(time='2014')
 .resample(time='H').mean(dim='time')
 .plot(x='time', yincrease=False, robust=True, ax=ax[0]))
(nrl5.zχpod.plot.line(x='time', color='k', ax=ax[0]))
(nrl5.KT.sel(time='2014')
 .resample(time='D').mean(dim='time')
 .plot.line(ax=ax[1], yscale='log', x='time'))

f, ax = plt.subplots()
(tidal_temp.sel(time='2014')
 .resample(time='H').mean(dim='time')
 .plot.contour(x='time', yincrease=False, levels=20))
(nrl5.zχpod.resample(time='D').mean(dim='time')
 .plot.line(x='time', color='k'))

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[123]:
:END:

*** NRL5 shear time series
#+BEGIN_SRC ipython :session :ipyfile images/temp/img68tfyk.png

uz, vz = ((nrl5.vel[shear].sel(depth=slice(90, 140))
           .mean('depth')
           .interpolate_na(dim='time'))
          for shear in ['uz', 'vz'])

inertial_uz, inertial_vz = (uz.copy(data=dcpy.ts.BandPassButter(
    shear.values,
    freqs=nrl5.inertial.values*np.array([0.95, 1.05]),
    dt=1/24)).sel(time='2014')
                            for shear in [uz, vz])

inertial_shear = inertial_uz.copy(data=np.hypot(inertial_uz, inertial_vz))

shear = nrl5.vel.shear.sel(depth=slice(90, 140)).mean('depth')
N2 = nrl5.N2.isel(depth=1).interp(time=inertial_shear.time)

f, ax = plt.subplots(2, 1, constrained_layout=True, sharex=True)
(shear**2 - 4*N2).plot(ax=ax[0], ylim=(0, None))
(nrl5.KT.resample(time='D').mean(dim='time')
 .plot.line(x='time', yscale='log', ax=ax[1]))
ax[0].set_xlabel('')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[343]:
: Text(0.5, 0, '')
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgcXpGjd.png
fM2 = 24/12.42

def plot_spec(spec, ax=None, levels=20):
    if ax is None:
        _, _ax = plt.subplots()

    var = (spec*spec.freq)
    # var = np.log10(spec)
    hdl = var.plot.contourf(levels=levels, yscale='log',
                            x='time', robust=True, ax=ax,
                            cmap=mpl.cm.RdPu, add_colorbar=True)

    var.plot.contour(
        levels=np.linspace(hdl.levels[-1], var.max(), 6)[1:],
        yscale='log', x='time', ax=ax, colors='w',
        linewidths=0.5)


goodt = slice(nrl5.KT.time[0], nrl5.KT.time[-1])
zpod = nrl5.zχpod.sel(num=2).interp(time=nrl5.vel.time.sel(time=goodt))

def interp_shear(shear):
    z = nrl5.zχpod.isel(num=1).median().values + 10
    return (shear.sel(depth=z, method='nearest')
            .interpolate_na(dim='time')
            .dropna('time'))



f0 = nrl5.inertial
fM2 = 24/12.42
plot_spec(shear.sel(time='2014'))
dcpy.plots.liney([0.9*(fM2-f0), 1.1*(fM2+f0),
                  0.9*(fM2*2-f0), 1.1*(fM2*2+f0),
                  0.9*(fM2*3-f0), 1.1*(fM2*3+f0),
                  0.6*f0, 1.5*f0], zorder=10)

f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True)
int_spec(shear, 0.9*(fM2-f0), 1.1*(fM2+f0)).plot(ax=ax[0], label='$M_2$')
int_spec(shear, 0.9*(fM2*2-f0), 1.1*(fM2*2-f0)).plot(ax=ax[0], label='$2M_2$')
# int_spec(shear, 0.9*(fM2*3-f0), 1.1*(fM2*3-f0)).plot(ax=ax[0], label='$3M_2$')
(int_spec(shear, 0.6*f0, 1.5*f0)
 .plot(ax=ax[0], label='$f_0$'))
ax[0].legend()

(nrl5.ε.where(nrl5.ε > 0).sel(time='2014')
 .resample(time='D').mean('time')
 .plot.line(x='time', ax=ax[1], yscale='log'))
ax[0].set_xlabel('')
t518 = nrl5.χpod[518].convert_to_xarray('mmw')
t519 = nrl5.χpod[519].convert_to_xarray('mmw')
t518['T'].plot(x='time', ax=ax[2])
t519['T'].plot(x='time', ax=ax[2])

plt.gca().set_xlim(['2014-01-01', '2014-12-31'])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[18]:
: (735234.0, 735598.0)
:END:
*** TS plots
#+BEGIN_SRC ipython :session :results none
import pickle

ctd = dict([[m.short_name, m.ctd]
            for m in [ra12, ra15, nrl1, nrl2, nrl3, nrl4, nrl5]])
with open('all-ctd.pickle', 'wb') as f:
    pickle.dump(ctd, f, pickle.HIGHEST_PROTOCOL)
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgRzvj3C.png
if 'turb' not in locals():
    turb = xr.open_dataset('./bay_merged_10min.nc')

if 'ctd' not in locals():
    import pickle
    with open('all-ctd.pickle', 'rb') as f:
        ctd = pickle.load(f)

bay.plots.KT_TS(turb, ctd, 'all')
plt.savefig('images/KT-TS.png')

bay.plots.KT_TS(turb, ctd, 'rama')
plt.savefig('images/KT-TS-rama.png')

bay.plots.KT_TS(turb, ctd, 'ebob')
plt.savefig('images/KT-TS-ebob.png')

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[114]:
: [<matplotlib.lines.Line2D at 0x7f0d941785f8>]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgWOpRL6.png
import tqdm

f, ax = plt.subplots(3, 4, sharex=True, sharey=True, constrained_layout=True)
f.set_constrained_layout_pads(wpad=1/72, hpad=1/72, wspace=0.0, hspace=0.0)

seasons = ['NE', 'NESW', 'SW', 'SWNE']

axes = dict()
axes['KT'] = dict(zip(seasons, ax[0, :]))
axes['Jq'] = dict(zip(seasons, ax[1, :]))
axes['Js'] = dict(zip(seasons, ax[2, :]))

for var in tqdm.tqdm(['KT', 'Jq', 'Js']):
    bay.plots.KT_TS(turb, ctd, 'all', var, axes=axes[var],
                    cbar_kwargs={'orientation': 'vertical'})

[aa.set_xlabel('') for aa in ax[:-1, :].flat]
[aa.set_ylabel('') for aa in ax[:, 1:].flat]
[aa.set_xlabel('S') for aa in ax[-1, :].flat]
[aa.set_ylabel('T') for aa in ax[:, 0].flat]
plt.savefig('images/TS-all-turb.png')
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgiFb2lm.png
if 'turb' not in locals():
    turb = xr.open_dataset('./bay_merged_10min.nc')

# turb['season'] = turb.time.monsoon.labels
# ebob = (turb.where(turb.lat == 8, drop=True)
#         .drop(['mld', 'ild', 'mean_depth', 'season']))
# ebob['JqT'] = ebob['Jq'] * ebob['T']
# ebob['JsS'] = ebob['Js'] * ebob['S']
# ebob = ebob.where(np.abs(ebob['Jq']) < 1000)

# ρbins = np.array(bay.default_density_bins)
# to_merge = []
# to_merge2 = []
# for season in bay.seasons:
#     subset = ebob.where(turb.season == season, drop=True)
#     binned = (subset.drop(['T', 'S'])
#               .groupby_bins(subset.ρ, ρbins,
#                             labels=(ρbins[:-1] + ρbins[1:])/2))
# #    _, ρbins = pd.qcut(subset.ρ.values.ravel(), 7, retbins=True)
#     density_avg = binned.mean(xr.ALL_DIMS)
#     density_std = binned.std(xr.ALL_DIMS)
#     density_avg['season'] = season
#     density_std['season'] = season

#     to_merge.append(density_avg.expand_dims('season'))
#     to_merge2.append(density_std.expand_dims('season'))

# averaged = xr.concat(to_merge, dim='season')
# averaged['T'] = averaged['JqT'] / averaged['Jq']
# averaged['S'] = averaged['JsS'] / averaged['Js']

# stddev = xr.concat(to_merge2, dim='season')
stddev['T'] = 0
stddev['S'] = 0

# argo = (dcpy.oceans.read_argo_clim().sel(**bay.ebob_region))

# argo = (argo.drop(['Tmean', 'Tanom', 'BATHYMETRY_MASK',
#                   'Smean', 'Sanom'])
#         .groupby(argo.time.monsoon.labels).mean(dim='time')
#         .compute())
# argo = argo.mean(['lat', 'lon'])

# df = averaged.to_dataframe().reset_index()

# 1. make this a salt/heat/density flux weighted mean sal, temp, rho
# 2. add argo climatology profiles?
# 3.

varnames = ['T', 'S', 'ρ', 'KT', 'Jq', 'Js']
f, ax = plt.subplots(1, len(varnames), sharey=True, constrained_layout=True)
axes = dict(zip(varnames, ax.flat))

for var in varnames:
    for ss in averaged.season:
        avg = averaged.sel(season=ss).dropna('ρ_bins')
        avg = avg.sortby(avg.z)
        std = stddev.sel(season=ss).dropna('ρ_bins')
        std = std.sortby(std.z)
        axes[var].errorbar(avg[var].values,
                           avg.z.values,
                           xerr=std[var].values/10,
                           fmt='o-')

    axes[var].tick_params(which='both', labeltop=True, labelbottom=False,
                          top=True, bottom=False)
    axes[var].set_xlabel(var)
    axes[var].xaxis.set_label_position('top')
    axes[var].spines['top'].set_visible(True)
    axes[var].spines['bottom'].set_visible(False)

axes['KT'].set_xscale('log')
axes['KT'].set_ylim([110, 0])

axes['Js'].legend(averaged.season.values)

axes['Js'].set_xlim([0, 0.005])
axes['Jq'].set_xlim([-15, 5])

#+END_SRC

#+BEGIN_SRC ipython :session :results none
S = (ctd['nrl3']['S'].sel(time='2014-01')
     .dropna('z', how='all')
     .interpolate_na('time'))
t = xr.broadcast(S.time, S)[0]

plt.hexbin(mpl.dates.date2num(t.values.ravel()),
           S.depth.values.ravel(),
           C=S.values.ravel())
plt.gca().xaxis_date()
plt.colorbar()

#+END_SRC
