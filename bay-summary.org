#+TITLE: Bay of Bengal notes
#+SETUPFILE: ~/org/notebook.org

* Map
#+NAME: define-make_map
#+BEGIN_SRC ipython :session :results none
# markers = {'RAMA': 'o', 'NRL': '^', 'OMM/WHOI': 'o'}
# colors = {'RAMA': '#0074D9', 'NRL': '#3D9970', 'OMM/WHOI': '#FF4136'}
# colors = {'RAMA': '#1696A3', 'NRL': '#F89B1F', 'OMM/WHOI': '#EA4D5B'}
colors = {'RAMA': '#1696A3', 'NRL': '#F89B1F', 'OMM/WHOI': '#EA4D5B'}

def make_map(pods, DX=0.6, DY=0.55, add_year=True, highlight=[]):
    import cartopy.crs as ccrs
    from cartopy import feature
    from mpl_toolkits.basemap import cm
    labelargs = {'fontsize': 11.5,
                 'bbox': {
                     'alpha': 0.25,
                     'edgecolor': 'none',
                     'boxstyle' : 'round'}}

    ProjParams = {'min_latitude' : 0.0, # same as lat_0 in proj4 string
                  'max_latitude' : 30.0, # same as lat_0 in proj4 string
                  'central_longitude' : 88.0, # same as lon_0
    }
    proj = ccrs.PlateCarree()

    coastline = feature.NaturalEarthFeature(name='coastline',
                                            category='physical',
                                            scale='50m',
                                            edgecolor='black',
                                            facecolor='#b2ccba')

    etopo = xr.open_dataset('~/datasets/ETOPO2v2g_f4.nc4', autoclose=True)
    extract={'x': slice(60, 96), 'y': slice(-5, 25)}

    def get_color(name, highlight):
        if name in highlight or len(highlight) == 0:
            return colors[name]
        else:
            return '#888888'

    with plt.rc_context({'font.size': 14}):
        fig = plt.figure(figsize=(6, 8))
        ax = plt.axes(projection = proj)
        ax.set_extent([80, 96, 2, 24])
        ax.add_feature(coastline)
        # ax.coastlines('10m', color='slategray', facecolor='slategray', lw=1)

        etopo.z.sel(**extract).plot.contour(
            transform=ccrs.PlateCarree(),
            add_colorbar=False,
            levels=np.sort([-100, -500, -1000,
                            -2500, -4000, -5000]),
            colors=['gray'], linewidths=0.5)
        ax.set_xlabel('')
        ax.set_ylabel('')

        for name in pods:
            pod = pods[name]
            ax.plot(pod['lon'], pod['lat'], transform=ccrs.PlateCarree(),
                    linestyle='',
                    marker='o',
                    color=get_color(pod['label'], highlight),
                    label=pod['label'], zorder=10)

            text = ''
            if add_year:
                if pod['label'] == 'RAMA' and pod['lat'] == 15:
                    text += '2015\n\n'
                if pod['label'] == 'OMM/WHOI':
                    text += '2014-15\n\n'

            for z in pod['depths']:
                text += z
                if pod['label'] == 'RAMA' and pod['lat'] == 12 and add_year:
                    text += ' / ' + pod['depths'][z]

                text += '\n'

            text = text[:-1]

            dx=0; dy=0
            if pod['ha'] is 'left':
                dx = DX
            elif pod['ha'] is 'right':
                dx = -1 * DX
            if pod['va'] is 'bottom':
                dy = DY
            elif pod['va'] is 'top':
                dy = - DY

            if name == 'NRL3':
                dx += 0.6

            if pod['label'] == 'OMM/WHOI':
                dy += 1.25

            labelargs['bbox']['facecolor'] = get_color(pod['label'], highlight)

            ax.text(pod['lon']+dx, pod['lat']+dy, text,
                    transform=ccrs.PlateCarree(),
                    ha=pod['ha'], va=pod['va'],
                    multialignment='center', **labelargs)

        ax.set_facecolor(None)

    return ax
#+END_SRC

#+NAME: map
#+BEGIN_SRC ipython :session :results none
<<define-make_map>>
pods = {
    'RAMA12':
        {'lon': 90, 'lat': 12, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '15 m': '2014-15',
             '30 m': '2014-15',
             '45 m': '2015'}},
    'RAMA15':
        {'lon': 90, 'lat': 15, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '15 m': '2015',
             '30 m': '2015'}},
    'WHOI':
        {'lon': 90, 'lat': 18, 'label': 'OMM/WHOI',
         'ha': 'left', 'va': 'top',
         'depths': {
             '22 m': '2014-15',
             '30 m': '2014-15',
             '46 m': '2014-15',
             '55 m': '2014-15',
             '65 m': '2014-15'}},
    'NRL1':
        {'lon': 85.5, 'lat': 5.5, 'label': 'NRL',
         'ha': 'center', 'va': 'top',
         'depths': {
             '60 m (55-100)': '2015',
             '80 m (75-115)': '2015'}},
    'NRL3':
        {'lon': 85.5, 'lat': 8, 'label': 'NRL',
         'ha': 'right', 'va': 'top',
         'depths': {
             '32 m (28-78)': '2015',
             '52 m (48-100)': '2015'}},
    'NRL4':
        {'lon': 87, 'lat': 8, 'label': 'NRL',
         'ha': 'center', 'va': 'bottom',
         'depths': {
             '63 m (60-85)': '2015',
             '83 m (80-105)': '2015'}},
    'NRL5':
        {'lon': 88.5, 'lat': 8, 'label': 'NRL',
         'ha': 'left', 'va': 'top',
         'depths': {
             '  85 m': '2015',
             '105 m': '2015'}},
}

ax = make_map(pods, DX=0.6, DY=0.55, add_year=True, highlight=['RAMA', 'NRL'])

ax.text(87, 6.8, 'NRL\n(2014)',
        fontsize=14, color=colors['NRL'], ha='center', va='center')
ax.text(90-0.35, 18, 'OMM/WHOI',
        fontsize=14, color=colors['OMM/WHOI'], ha='right', va='center')
ax.text(90, 13.5, 'RAMA',
        fontsize=14, color=colors['RAMA'], ha='left', va='center')
ax.set_xticks([80, 82, 84, 85.5, 87, 88.5, 90, 92, 94, 96])
ax.set_yticks([2, 4, 5.5, 8.5, 12, 15, 18, 20, 22, 24])

plt.savefig('../images/map.svg')
plt.savefig('../images/map.png', bbox_inches='tight')
#+END_SRC
#+CAPTION: χ-pod locations.
#+ATTR_HTML: :width 55%
[[file:images/map.png]]

#+BEGIN_SRC ipython :session :results none
<<define-make_map>>
pods = {
    'RAMA67':
        {'lon': 67, 'lat': 0, 'label': 'RAMA',
         'ha': 'center', 'va': 'bottom',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA80':
        {'lon': 80, 'lat': 0, 'label': 'RAMA',
         'ha': 'center', 'va': 'bottom',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA90':
        {'lon': 90, 'lat': 0, 'label': 'RAMA',
         'ha': 'left', 'va': 'center',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA4':
        {'lon': 90, 'lat': 4, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '45 m': ''}},
    'RAMA12':
        {'lon': 90, 'lat': 12, 'label': 'RAMA',
         'ha': 'center', 'va': 'top',
         'depths': {
             '15 m': '',
             '45 m': ''}},
    'RAMA15':
        {'lon': 90, 'lat': 15, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '15 m': '2018, 19',
             '30 m': '2018, 19',
             '45 m': '2018, 19',
             '55 m': '2018, 19',
             '65 m': '2018, 19'}},
}

ax = make_map(pods, DX=1, DY=1, add_year=False)

ax.set_xlim([65, 96])
ax.set_ylim([-2, 24])
ax.set_xticks([65, 67, 70, 75, 80, 85, 90, 95])
ax.set_yticks([0, 4, 8, 12, 15, 18, 20, 22, 24])

ax.set_title('MISOBOB $χ$pod deployments (2018, 19)')
plt.savefig('../images/map-misobob.svg')
plt.savefig('../images/map-misobob.png', bbox_inches='tight')
#+END_SRC
#+ATTR_HTML: :width 55%
[[file:images/map-misobob.png]]

** emily :noexport:
#+CAPTION: χpod locations for ASIRI/EBOB/MISOBOB
#+ATTR_HTML: :width 55%
[[file:../images/MixingmapASIRIPiston.png]]
* All χpods
** RAMA
#+ATTR_HTML: :class full-width
[[file:images/ra12-2014-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/ra12-2015-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/ra15-summary.png]]

** EBOB

#+ATTR_HTML: :class full-width
[[file:images/nrl1-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/nrl2-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/nrl3-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/nrl4-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/nrl5-summary.png]]

* vertical distribution of $K_T$
** Make plot
*** Mangle together and change to dataframe
#+CALL: read-all-moorings()
#+NAME: make-merged-KT
#+BEGIN_SRC ipython :session :results none
import bay

moorings = [ra12, ra15, nrl1, nrl3, nrl4, nrl5]
bay.make_merged_nc(moorings)

# KTm = xr.open_dataset('merged_KT.nc', autoclose=True)
#ρbins = histedges_equalN(np.ravel(KTm.ρ), 11)
#Sbins = histedges_equalN(np.ravel(KTm.S), 11)

#KTdf = bin_and_to_dataframe(KTm, ρbins)
#+END_SRC
*** means/medians profile
#+NAME: define-vert_distrib
#+BEGIN_SRC ipython :session :results none
def bin_ktdf(KTdf, bins):

    error_depth = 5

    depth_minus_mld = (KTdf.z - KTdf.mld)
    depth_minus_ild = (KTdf.z - KTdf.ild)
    mask_ml = depth_minus_mld <= error_depth
    mask_bl = np.logical_and(np.logical_not(mask_ml),
                             depth_minus_ild <= error_depth)
    mask_ml_plus = np.logical_and(
        np.logical_not(np.logical_or(mask_ml, mask_bl)),
        depth_minus_mld <= 15)
    mask_ml_plus = np.zeros_like(mask_ml).astype('bool')
    mask_deep = np.logical_not(np.logical_or(
        np.logical_or(mask_ml, mask_bl),
        mask_ml_plus))

    KTdf['bin'] = ''
    KTdf.bin[mask_ml] = 'ML'
    KTdf.bin[mask_bl] = 'BL'
    # KTdf.bin[mask_ml_plus] = 'ML+'
    # bins = get_kmeans_bins(7, KTdf['ρ'][mask_deep])
    #KTdf.bin = pd.qcut(KTdf.ρ, 10, precision=1)
    KTdf.bin[mask_deep] = pd.cut(KTdf.ρ[mask_deep],
                                 bins,
                                 precision=1)
    KTdf['bin'] = KTdf['bin'].astype('category')
    assert(np.sum(KTdf.bin == '') == 0)

    return KTdf

def get_kmeans_bins(k, data):
    centroids, _ = sp.cluster.vq.kmeans(data, k)
    cent = np.sort(centroids)
    bins = np.hstack([data.min(), (cent[:-1]+cent[1:])/2])
    return bins

def trim_horiz_violin(hdl):
    # halve the voilin
    for b in hdl['bodies']:
        m = np.mean(b.get_paths()[0].vertices[:, 1])
        b.get_paths()[0].vertices[:, 1] = np.clip((b.get_paths()[0]
                                                   .vertices[:, 1]),
                                                  -np.inf, m)

def format_moor_names(names):
    rama = []
    nrl = []

    for nn in names:
        if nn[0:4] == 'RAMA':
            rama.append(nn[4:])
        elif nn[0:3] == 'NRL':
            nrl.append(nn[3])

    string = ''
    if rama != []:
        string += 'R' + ','.join(rama)

    if nrl != []:
        if string is not '':
            string += '\n'

        string += 'N' + ','.join(nrl)

    return string

def _get_color_from_hdl(hdl):
    try:
        facecolor = hdl['bodies'][0].get_facecolor()[0]
    except TypeError:
        facecolor = hdl[2][0].get_facecolor()

    return facecolor[:-1]

def plot_distrib(ax, plotkind, var, zloc, zstd, width=12, percentile=False):
    ''' Actually plot the distribution '''

    base_marker_size = 5

    if np.all(var < 1):
        # if in log-space transform out and back
        median = np.log10(np.median(10**var))
        mean = np.log10(np.mean(10**var))
        if percentile:
            prc = np.log10(np.percentile(10**var, 99.5))
    else:
        median = np.median(var)
        mean = np.mean(var)
        if percentile:
            prc = np.percentile(var, 99.5)

    if plotkind is 'violin':
        if percentile:
            var[var > prc] = np.nan

        hdl = ax.violinplot(var[~np.isnan(var)], positions=[zloc],
                            widths=[width],
                            vert=False, showmedians=False)

        for pc in hdl['bodies']:
            pc.set_alpha(0.55)

        trim_horiz_violin(hdl)
        hdl['cmaxes'].set_visible(False)
        hdl['cmins'].get_paths()[0].vertices[:, 1] = (zloc +
                                                      np.array([-1,1])
                                                      ,*zstd)
        if percentile:
            # use percentile instead of max
            hdl['cbars'].get_paths()[0].vertices[1, 0] = prc

    elif plotkind is 'hist':
        hdl = ax.hist(var, bottom=zloc, density=True)

    color = _get_color_from_hdl(hdl)

    ax.plot(median, zloc, 'o',
            color=color, zorder=12, ms=base_marker_size-1)
    ax.plot(median, zloc, 'o',
            color='w', zorder=11, ms=base_marker_size+1)
    ax.plot(mean, zloc, '^',
            color=color, zorder=12, ms=base_marker_size)
    ax.plot(mean, zloc, '^',
            color='w', zorder=12, ms=base_marker_size+2,
            fillstyle='none')

    return hdl, median, mean

def vert_distrib(KTdf, bins, varname='KT', pal=None, f=None, ax=None,
                 label_moorings=True, label_bins=True, adjust_fig=True,
                 width=12, percentile=False, add_offset=True, **kwargs):

    plotkind = 'violin'
    nadd = 3 # number of extra colors to generate
    pal_dist = sns.color_palette("GnBu_d", n_colors=len(bins.unique())+nadd)
    pal_dist.reverse()
    pal_dist = pal_dist[0:-(nadd)]
    if 'ML' in bins.cat.categories:
        pal_dist = np.roll(pal_dist, -1, axis=0)
    # if 'ML+' in bins.cat.categories:
    #     pal_dist = np.roll(pal_dist, -1, axis=0)
    if 'BL' in bins.cat.categories:
        pal_dist = np.roll(pal_dist, -1, axis=0)
        if 'ML' in bins.cat.categories:
            temp = pal_dist[-2,:].copy()
            pal_dist[-2,:] = pal_dist[-1,:]
            pal_dist[-1,:] = temp

    map_kind = {'NRL1': 'NRL',
                'NRL2': 'NRL',
                'NRL3': 'NRL',
                'NRL4': 'NRL',
                'NRL5': 'NRL',
                'RAMA12': 'RAMA',
                'RAMA15': 'RAMA'}

    if pal is None:
        pal = pal_dist

    if f is None:
        f, axx = plt.subplots(1, 4, sharex=True, sharey=True)
        ax = {'NE': axx[0], 'NESW': axx[1], 'SW': axx[2], 'SWNE': axx[3]}

    if varname is 'KT':
        title = '$\log_{10}$ hourly averaged $K_T$ (m²/s)'
        xlim = kwargs.pop('xlim', [-7.5,2])
        xlines = kwargs.pop('xlines', [-5, -4, -1])
    else:
        title = varname
        xlim = kwargs.pop('xlim', None)
        xlines = kwargs.pop('xlines', [])

    months = {'NE': 'Dec-Feb', 'NESW': 'Mar-May',
              'SW': 'Jun-Sep', 'SWNE': 'Oct-Nov'}

    for seas in ax:
        aa = ax[seas]
        from cycler import cycler
        aa.set_prop_cycle(cycler('color', pal))
        aa.set_title(seas + '\n(' + months[seas] +')')
        if xlim is not None:
            aa.set_xlim(xlim)
            aa.set_xticks(range(-7, 0))

    # for plotting mean, median profile
    zvec = dict()
    mdnvec = dict()
    meanvec = dict()
    for seas in months.keys():
        zvec[seas] = []
        mdnvec[seas] = []
        meanvec[seas] = []

    # seaborn treats things as categoricals booo...
    # do things the verbose matplotlib way
    for index, (label, df) in enumerate(KTdf.groupby([bins, 'season'])):
        interval = label[0]
        season = label[1]
        zloc = sp.stats.trim_mean(df.z, 0.1)

        if add_offset:
            if type(interval) != str and interval.mid < 1020:
                if season == 'SWNE':
                    zloc += 5
            elif interval == 'BL':
                if season == 'NESW':
                    zloc -= 5
                else:
                    zloc -= 10
            elif interval == 'ML':
                zloc -= 5

        bin_name = (np.round(interval.mid-1000, 1).astype('str')
                    if isinstance(interval, pd.Interval)
                    else interval)

        var = df[varname]
        if varname == 'ρ':
            var -= 1000

        for mm in df['moor'].unique():
            if len(df['moor'].ix[df['moor'] == mm])/len(df) <= 0.10:
                df = df[df['moor'] != mm]

        hdl, median, mean = plot_distrib(ax[season], plotkind, var,
                                         zloc, df.z.std(), width, percentile)
        color = _get_color_from_hdl(hdl)

        zvec[season].append(zloc)
        mdnvec[season].append(median)
        meanvec[season].append(mean)

        try:
            xtxt = hdl['cbars'].get_paths()[0].vertices[1, 0]
            ytxt = zloc

            if label_bins:
                ax[season].text(xtxt, ytxt, '     '+ bin_name,
                                color=color, ha='left', va='center',
                                fontsize=7)
            if label_moorings:
                ax[season].text(2, ytxt, format_moor_names(df['moor'].unique()),
                                color=color, ha='left', va='center', fontsize=6)
        except TypeError:
            pass


    ax['NE'].set_ylabel('depth (m)')
    ax['NE'].set_ylim([120, 0])
    # ax['NE'].set_yticks(np.arange(120,0,-20))
    # ax['NE'].set_yticklabels(np.arange(120,0,-10).astype('str'))

    for season in ax:
        args={'linestyle': '--', 'color': 'dimgray'}
        idx = np.argsort(zvec)
        ax[season].plot(np.array(mdnvec[season])[idx],
                        np.array(zvec[season])[idx], **args)
        ax[season].plot(np.array(meanvec[season])[idx],
                        np.array(zvec[season])[idx], **args)
        aa = ax[season]
        for xx in xlines:
            aa.axvline(xx, lw=0.5, ls='dotted', zorder=-50, color='gray')


    if adjust_fig:
        sns.despine(fig=f, left=False, bottom=False, trim=True)
        f.set_size_inches((8.5, 5.5))
        f.suptitle(title, y=0.03, va='baseline')
        plt.subplots_adjust(wspace=0.25)

    return f, ax
#+END_SRC

#+NAME: vert-profile
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-profile.png :results drawer
<<define-vert_distrib>>

if 'KTm' not in locals():
    KTm = xr.open_dataset('merged_KT_hourly.nc', autoclose=True).load()
    if np.all(KTm['KT'].values[np.logical_not(KTm.KT.isnull().values)] > 0):
        KTm['KT'].values = np.log10(KTm['KT'].values)

    KTm['season'] = KTm.time.monsoon.labels
    KTdf = (KTm[['KT', 'T', 'S', 'z', 'ρ', 'mld', 'ild', 'season']]
            .to_dataframe()
            .dropna(axis=0, subset=['KT'])
            .reset_index())
    KTdf['latlon'] = (KTdf['lat'].astype('float32').astype('str') + 'N, '
                      + KTdf['lon'].astype('float32').astype('str')
                      + 'E').astype('category')
    KTdf['season'] = KTdf['season'].astype('category')

    moornames = {'RAMA12': '12.0N, 90.0E',
                 'RAMA15': '15.0N, 90.0E',
                 'NRL1': '5.0N, 85.5E',
                 'NRL2': '6.5N, 85.5E',
                 'NRL3': '8.0N, 85.5E',
                 'NRL4': '8.0N, 87.0E',
                 'NRL5': '8.0N, 88.5E'}
    KTdf['moor'] = (KTdf['latlon']
                    .map(dict(zip(moornames.values(),
                                  moornames.keys())))
                    .astype('category'))

bins = [1018, 1021, 1022, 1022.5, 1023, 1023.5, 1024.25, 1029]
KTdf = bin_ktdf(KTdf, bins)

f, ax = vert_distrib(KTdf, KTdf.bin, label_moorings=False, percentile=True)

plt.subplots_adjust(wspace=-0.06)
# sns.despine(fig=f, left=False, bottom=False, trim=True)
plt.savefig('images/vert-profile.svg', bbox_inches='tight')
#+END_SRC
#+ATTR_HTML: :class full-width
#+RESULTS: vert-profile
:RESULTS:
# Out[1435]:
[[file:images/bay-KT-vert-profile.png]]
:END:

1. High mixing at 70-100m depth in SW monsoon, compared to NE monsoon.
   1. Connected to SMC/SLD?
   2. Near-inertial waves from storms could be a thing
   3. Something happens in NRL5, around SW monsoon start to see temperature inversions semi-regularly (rare, but regular)

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgrtIJ8z.png
<<define-vert_distrib>>
season = 'SW'
bin_name = 24.0

ρmid = (KTdf.bin
        .apply(lambda x: x.mid-1000 if type(x) is not str else None))

if type(bin_name) is str:
    mask = KTdf.bin == bin_name
else:
    mask = (abs(ρmid - bin_name) < 0.2)

# mask = np.logical_and(mask, KTdf.season == season)
subset = KTdf[mask]
f, ax = vert_distrib(subset, subset.moor, varname='ρ')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[702]:
:END:

#+NAME: sal-distrib
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgbp6rfN.png :results drawer
<<define-vert_distrib>>

Sbins = pd.qcut(KTdf.S, 11)

f, ax = plot_distrib(KTdf, bins, varname='S', xlines=[32, 35])
# plot_distrib(KTdf.where(KTdf.S > 34.9), bins, pal=[[0.5,0.5,0.5]]*13, f=f, ax=ax)
#+END_SRC
#+RESULTS: sal-distrib
:RESULTS:
[[file:images/temp/imgbp6rfN.png]]
:END:
*** full distrib seaborn
#+NAME: define-seaborn_vert_distrib
#+BEGIN_SRC ipython :session :results none
pal_dist = sns.color_palette("GnBu_d", n_colors=13)
pal_dist.reverse()

def seaborn_vert_distrib(KTdf, category, kind='kde'):
    stylekwargs = dict(style="ticks",
                       rc={'axes.facecolor': 'None',
                           'figure.facecolor': 'None'})
    bandwidth = 'scott'
    # pal_dist=sns.cubehelix_palette(11, rot=-.25, light=.7)
    # pal_dist = [pal_dist[0]]*13

    pal_boxplot = sns.color_palette("muted",
                                    n_colors=len(KTdf['latlon'].unique()))
    pal_boxplot[1] = (0,0,0)
    pal_boxdict = dict(zip(KTdf['latlon'].unique(), pal_boxplot))

    # pal = sns.cubehelix_palette(11, rot=-.25, light=0.7)

    def label(x, color, label):
        def stat_label(name, x, fmt, suffix=''):
            q75, q25 = np.percentile(x, [75, 25])
            return ((name+': {0:'+fmt+'}'+suffix
                     +', {1:'+fmt+'}'+suffix
                     +', {2:'+fmt+'}'+suffix)
                    .format(q25, x.mean(), q75))

        extract = KTdf.take(x.index)
        ax = plt.gca()
        label = float(label)
        if category == 'ρbinned':
            lab = (stat_label('S', extract.S, '.1f') + '\n'
                   + stat_label('z', extract.z, '.0f', 'm') + '\n'
                   +'σ: {0:2.1f}kg/m³'.format(label-1000))
        elif category == 'Sbinned':
            lab = '{0:2.1f}'.format(label)
        elif category == 'mean_depth':
            lab = '{0:.0f}m'.format(label)

        ax.text(1, 0.05, lab,
                color=(sns.light_palette((210, 90, 20), input="husl"))[3],
                fontsize=8,
                ha="right", va="bottom", transform=ax.transAxes)

    def mark_distributions_by_location(x, color, label):
        ax = plt.gca().twinx()
        gby = KTdf.take(x.index).groupby('latlon');

        for index, (name, grp) in enumerate(gby):
            props = {'linewidth': 1, 'color': pal_boxdict[name]}
            ax.boxplot(grp['KT'], vert=False, sym='', widths=0.08,
                       showbox=False,
                       showmeans=False, positions=[0.2+0.1*index],
                       boxprops={**props}, whiskerprops={**props},
                       medianprops={**props}, capprops={**props})

        ax.set_ylim([0, 2])
        ax.set_yticks([])

        # with sns.axes_style(**stylekwargs):
        #     sns.boxplot(data=KTdf.take(x.index), x='KT', hue='latlon',
        #                 ax=ax, orient='h', width=0.1)

    def mark_mean_mdn(x, color, label):
        ax = plt.gca()

        mean = np.log10(np.nanmean(10**x))
        median = np.log10(np.nanmedian(10**x))
        yloc = 0.5
        plt.plot(mean, yloc, color=color, marker='x')
        # plt.plot(mean, yloc, color='w', marker='x', fillstyle='none')
        plt.plot(median, yloc, color=color, marker='o', ms=10)
        plt.plot(median, yloc, color='w', marker='o', ms=11, fillstyle='none')

    with sns.axes_style(**stylekwargs):
        g = sns.FacetGrid(KTdf, row=category, col="season",
                          col_order=['NE', 'NESW', 'SW', 'SWNE'],
                          hue=category, xlim=[-7, 0],
                          sharex=True, sharey=True, palette=pal_dist,
                          aspect=4, size=1)


        kdekwargs = {'clip': [-8, 0],
                     'clip_on': False,
                     'cut': 0,
                     'bw': bandwidth}

        distkwargs = {'bins': 50, 'hist':True, 'rug':False, 'norm_hist':True,
                      'kde':False, 'kde_kws':{'lw': 1, **kdekwargs}}
        if kind == 'kde':
            g.map(sns.kdeplot, "KT", shade=True, alpha=0.6, lw=1.5, **kdekwargs)
            g.map(sns.kdeplot, "KT", color="w", lw=2, **kdekwargs)

        elif kind == 'dist':
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'alpha': 1})
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'histtype': 'step', 'color': 'w',
                            'lw': 1, 'alpha': 1})

        g.map(plt.axhline, y=0, lw=2, clip_on=False)

        g.map(label, "KT")
        g.map(mark_mean_mdn, "KT")
        g.map(mark_distributions_by_location, "KT")
        g.fig.subplots_adjust(hspace=-0.58)
        g.set_xlabels('$K_T$')
        g.set_titles('')
        g.set(yticks=[], ylim=[0, 2])
        _ = g.despine(left=True)

        g.axes[1,0].set_title('NE\n(Dec-Mar)')
        g.axes[1,1].set_title('NE → SW\n(Apr-May)')
        g.axes[1,2].set_title('SW\n(Jun-Sep)')
        g.axes[1,3].set_title('SW → NE\n(Oct-Nov)')

        for index, tt in enumerate(KTdf['latlon'].unique()):
            plt.gcf().text(0.98,0.97-index*0.015, tt,
                           color=pal_boxplot[index],
                           ha='right', va='top')
            plt.suptitle('Columns are seasons, rows are density bins', y=0.95)

        return g

#+END_SRC

#+NAME: KT-vert-hist
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist.png :results drawer
<<define-seaborn_vert_distrib>>
KTdf['ρbinned'] = pd.qcut(KTdf.ρ, 11, precision=1)
KTdf.ρbinned = KTdf.ρbinned.apply(lambda x: x.mid)
g = seaborn_vert_distrib(KTdf, "ρbinned", 'dist')
#+END_SRC
#+RESULTS: KT-vert-hist
:RESULTS:
# Out[24]:
[[file:images/bay-KT-vert-hist.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/bay-sampling-hist.png :results drawer
<<define-seaborn_vert_distrib>>
KTdf.bin = pd.qcut(KTdf.ρ, 11, precision=1)
g = seaborn_vert_distrib(KTdf, "bin", 'dist')
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist-depths.png
<<define-seaborn_vert_distrib>>
seaborn_vert_distrib(KTdf, 'mean_depth', 'kde')
#+END_SRC
#+RESULTS:
[[file:images/bay-KT-vert-hist-depths.png]]
*** old attempts
**** without MLD binning : only ρ binning
#+CAPTION: After extending unit 814 with pitot
[[file:images/bay-KT-vert-profile-pre-mld-bin.png]]

**** by latitude
#+NAME: kt-by-lat
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-by-lat.png
KTdf.loc[KTdf['depth'] == 43.0, 'depth'] = 45.0
KTdf.loc[KTdf['depth'] == 68.5, 'depth'] = 69.0
KTdf.loc[KTdf['depth'] == 89.4, 'depth'] = 88.2
g = sns.FacetGrid(KTdf, row='depth', col='lat', hue='season',
                  sharex=True, sharey=True,
                  hue_order=['NE', 'NESW', 'SW', 'SWNE'],
                  col_order=[5., 8., 12.0, 15.0],
                  margin_titles=True, legend_out=False,
                  size=1.2, aspect=2)

kdekwargs = {'clip': [-8, 0],
             'clip_on': False,
             'bw': 0.2}

g.map(sns.kdeplot, "KT", shade=False, lw=1.5, **kdekwargs)
g.add_legend()
g.set(xlim=[-8,0], ylim=[0, 1], yticks=[])
sns.despine(left=True)
plt.subplots_adjust(hspace=-0.15)
#+END_SRC
#+RESULTS: kt-by-lat
[[file:images/bay-KT-by-lat.png]]
** Bin testing

Test out binning so that there are equal number of observations (NaN filtered) in each bin
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgSAH1E0.png :results drawer
def histedges_equalN(x, nbin):
    # from https://stackoverflow.com/questions/39418380/histogram-with-equal-number-of-points-in-each-bin
    x = x[np.logical_not(np.isnan(x))]
    npt = len(x)
    return np.interp(np.linspace(0, npt, nbin + 1),
                     np.arange(npt),
                     np.sort(x))

KTm.ρ.plot.hist(bins='fd', density=True)
ρbins = histedges_equalN(np.ravel(KTm.ρ), 12)
_ = KTm.ρ.plot.hist(bins=ρbins, density=True, edgecolor='k', facecolor='none')
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/temp/imgSAH1E0.png]]
:END:


#+NAME: argo-clim-density
#+BEGIN_SRC ipython :session :ipyfile images/mean-density-at-moorings.png
import dcpy.oceans
import seawater as sw

latitude = [12, 15, 5, 6.5, 8, 8, 8]
longitude = [90, 90, 85.5, 85.5, 85.5, 87, 88.5]
name = ['RA12', 'RA15', 'NRL1', 'NRL3', 'NRL4', 'NRL5']

_, ax = plt.subplots(1, 3, sharey=True)
if 'argoS' not in locals():
    argoS = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Salinity_2016.nc',
                            decode_times=False, autoclose=True)
    argoT = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Temperature_2016.nc',
                            decode_times=False, autoclose=True)

for (lon, lat, moorname) in zip(longitude, latitude, name):
    S = argoS.ARGO_SALINITY_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    T = argoT.ARGO_TEMPERATURE_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    ρ = sw.pden(S, T, argoS.PRESSURE)

    ax[0].plot(S, argoS.PRESSURE, label=moorname)
    ax[1].plot(T, argoS.PRESSURE, label=moorname)
    ax[2].plot(ρ, argoS.PRESSURE, label=moorname)

plt.ylim([120, 0])
plt.gcf().legend()
dcpy.plots.linex(Sbins, ax=ax[0])
dcpy.plots.linex(ρbins, ax=ax[2])
ax[0].set_ylabel('Pressure')
ax[0].set_xlabel('S')
ax[1].set_xlabel('T')
ax[1].set_xlim([20, 30])
ax[2].set_xlabel('ρ')
plt.gcf().suptitle('Roemmich & Gilson ARGO Climatology')
plt.gcf().set_size_inches((5.5, 2.5))
#+END_SRC
#+CAPTION: Mark density bins on ARGO climatology density profile
#+RESULTS: argo-clim-density
[[file:images/mean-density-at-moorings.png]]

#+NAME: TS-sampled-distribution
#+BEGIN_SRC ipython :session :ipyfile images/TSρ-sampled-by-χpod.png :results drawer
f, ax = plt.subplots(2,1)
sns.violinplot(data=KTdf.dropna(), x="depth", y="ρ", ax=ax[0])
sns.violinplot(data=KTdf.dropna(), x="depth", y="S", ax=ax[1])
# sns.violinplot(data=KTdf.dropna(), x="depth", y="T", ax=ax[2])
plt.gcf().autofmt_xdate()
ρbins2 = [ 1019.45,  1020.43,  1021.05,  1021.68,
           1022.49,  1022.94,  1023.49,  1026.27]
dcpy.plots.liney(ρbins, ax=ax[0])
dcpy.plots.liney(Sbins, ax=ax[1])
plt.gcf().set_size_inches((8.5, 7.5))
plt.tight_layout()
#+END_SRC
#+RESULTS: TS-sampled-distribution
:RESULTS:
[[file:images/TSρ-sampled-by-χpod.png]]
:END:

#+NAME: kmeans
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgiZJc38.png
data = KTdf.ρ
centroids, _ = sp.cluster.vq.kmeans(data, 10)
idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(10):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1])

#+END_SRC
#+RESULTS: kmeans
[[file:images/temp/imgiZJc38.png]]

#+NAME: TS-plot
#+BEGIN_SRC ipython :session :ipyfile images/rho-bins-TS-plot.png :results drawer
T, S, binned= dcpy.util.BinEqualizeHist([KTdf['T'], KTdf['S']], bins=[200, 100])
Tg, Sg = np.meshgrid(T, S, indexing='ij')
ρg = sw.pden(Sg, Tg, 50)
# plt.plot(KTdf['S'], KTdf['T'], '.')
plt.pcolormesh(S, T, binned.T, cmap=mpl.cm.Reds)
# hc = plt.contour(Sg, Tg, ρg, colors='k', levels=ρbins)
# plt.clabel(hc, fmt='%1.1f')
plt.xlabel('S')
plt.ylabel('T')

kmeans = 12

data = KTdf.ρ
centroids, _ = sp.cluster.vq.kmeans(data, kmeans)
idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(kmeans):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1], 'k--')

cent = np.sort(centroids)
newbins = np.hstack([KTdf.ρ.min(), (cent[:-1]+cent[1:])/2])
hc = plt.contour(Sg, Tg, ρg, colors='k', levels=newbins, zorder=10)
plt.clabel(hc, fmt='%1.1f')
#+END_SRC
#+RESULTS: TS-plot
:RESULTS:
: <a list of 12 text.Text objects>
[[file:images/rho-bins-TS-plot.png]]
:END:
* OSM 2018 figures
** rama vs nrl | met & K_T
#+BEGIN_SRC ipython :session :results none
def full_extent(ax, pad=0.0):
    """Get the full extent of an axes, including axes labels, tick labels, and
    titles."""

    from matplotlib.transforms import Bbox
    # For text objects, we need to draw the figure first, otherwise the extents
    # are undefined.
    ax.figure.canvas.draw()
    items = [ax, ax.title, ax.xaxis.label, ax.yaxis.label]
    items += (ax.get_xticklabels() + ax.get_yticklabels())
    bbox = Bbox.union([item.get_window_extent() for item in items])

    return bbox.expanded(1.0 + pad, 1.0 + pad)

ax, hkr = ra12.met_turb_summary(region={'time': '2014', 'depth': 15}, naxes=2)

ktrama = ((10**KTm.KT).sel(lon=90, lat=12, time='2014')
         .dropna(dim='depth', how='all')
         .resample(time='D').mean(dim='time')
         .isel(depth=0))
hdl_pointr = ax['Kt'].plot(ktrama.time[-1], ktrama[-1],
                           'o', ms=4, color=hkr[0].get_color(), clip_on=False)
hdl_textr = ax['Kt'].text('2014-12-31', ktrama[-1], '  12N 15m', ha='left',
                          clip_on=False, color=hkr[0].get_color())

arrowprops = dict(arrowstyle="<->", connectionstyle="arc3")
ha1 = ax['Kt'].annotate("",
                        xy=('2014-04-15', 5e-5), xycoords='data',
                        xytext=('2014-04-15', 1), textcoords='data',
                        arrowprops=arrowprops)
ha2 = ax['Kt'].annotate("",
                        xy=('2014-07-15', 5e-3), xycoords='data',
                        xytext=('2014-07-15', 1), textcoords='data',
                        arrowprops=arrowprops)
ha3 = ax['Kt'].annotate("",
                        xy=('2014-10-9', 5e-2), xycoords='data',
                        xytext=('2014-10-9', 10), textcoords='data',
                        arrowprops=arrowprops)

htxt = []
htxt.append(
    ax['met'].text('2014-02-01', 0.35, 'NE', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-04-15', 0.35, 'NESW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-07-16', 0.35, 'SW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-10-20', 0.35, 'SWNE', va='bottom', zorder=-1)
)

ax['met'].set_xlim(('2014-01', '2015-01'))
ax['met'].set_ylim([0, 0.35])
ax['Kt'].xaxis.set_major_formatter(mpl.dates.DateFormatter('%b-%d'))
ax['Kt'].set_xlabel('2014')
ax['Kt'].set_ylabel('Daily avg. $K_T$ (m²/s)')
ax['Kt'].xaxis.set_tick_params(rotation=0)
# plt.tight_layout()
plt.gcf().set_size_inches((6, 3.25))
plt.savefig('images/rama-vs-nrl-0.png', bbox_inches='tight')

nrlregion = dict(lon=88.5, lat=8, time='2014')
ktnrl = ((10**KTm.KT).sel(**nrlregion)
         .dropna(dim='depth', how='all')
         .resample(time='D').mean(dim='time')
         .isel(depth=1))
hdl = ax['Kt'].plot(ktnrl.time, ktnrl, lw=0.75)
hdl_pointn = ax['Kt'].plot(ktnrl.time[-1], ktnrl[-1],
                           'o', ms=4, color=hdl[0].get_color(), clip_on=False)
hdl_textn = ax['Kt'].text('2014-12-31', ktnrl[-1], '  8N 100m', ha='left',
                          clip_on=False, color=hdl[0].get_color())

for ha in [ha1, ha2, ha3]:
    ha.set_visible(False)

ha = []
arrowprops = dict(arrowstyle="->", connectionstyle="arc3")
ha.append(ax['Kt'].annotate("near-molecular!",
                       xytext=('2014-04-01', 7e-6), xycoords='data',
                       xy=('2014-04-15', 2e-7), textcoords='data',
                            arrowprops=arrowprops, ha='right'))

plt.gcf().set_size_inches((6, 3.25))
plt.savefig('images/rama-vs-nrl-1.png', bbox_inches='tight')

# extent = full_extent(ax['Kt']).transformed(f.transFigure.inverted())
# # We can now make the rectangle in figure coords using the "transform" kwarg.
# rect = mpl.patches.Rectangle([extent.xmin, extent.ymin],
#                              extent.width, extent.height,
#                              facecolor='yellow', edgecolor='none', zorder=-1,
#                              transform=fig.transFigure)
# f.patches.append(rect)

ax['Jq0'].set_visible(False)
ax['met'].set_visible(False)

plt.savefig('images/rama-vs-nrl-KT.png', bbox_inches='tight')

hkr[0].set_visible(False)
hdl_textr.set_visible(False)
hdl_pointr[0].set_visible(False)

ha.append(ax['Kt'].annotate("Arabian Sea water arrives",
                       xytext=('2014-06-01', 1e-3), xycoords='data',
                       xy=('2014-07-01', 5e-7), textcoords='data',
                            arrowprops=arrowprops, ha='right'))

ha.append(ax['Kt'].annotate("Near-inertial wave burst",
                       xytext=('2014-09-01', 1e-2), xycoords='data',
                       xy=('2014-07-27', 1e-3), textcoords='data',
                            arrowprops=arrowprops, ha='center'))

plt.savefig('images/nrl5-KT-labels.png', bbox_inches='tight')

#ax['met'].set_visible(True)

# (KTm.S.sel(**nrlregion)
#  .dropna(dim='depth', how='all')
#  .resample(time='D').mean(dim='time')
#  .isel(depth=0)).plot.line(x='time', ax=ax['met'],
#                            color=hdl[0].get_color())

# ax['met'].set_ylim([34, 36])
# ax['met'].set_title('')
# ax['Kt'].xaxis.set_tick_params(rotation=0)
# plt.savefig('images/rama-vs-nrl-KT-nrl-sal.png', bbox_inches='tight')

#+END_SRC
[[file:images/rama-vs-nrl-1.png]]
** rama vs nrl | K_T distributions
#+BEGIN_SRC ipython :session :ipyfile images/rama-vs-nrl-kt-violin.png
<<define-vert_distrib>>

moor_mask = np.logical_or(
    np.logical_and(KTdf.moor == 'RAMA12', np.round(KTdf.depth)==15),
    np.logical_and(KTdf.moor == 'NRL5', np.round(KTdf.depth) == 104))
new_deep_mask = np.logical_and(mask_deep, moor_mask)
subset = KTdf[moor_mask]

bins = [1018, 1022.5, 1026]
subset = bin_ktdf(subset, bins)

subset.loc[subset.moor == 'NRL5', 'z'] -= 85
subset.loc[subset.bin == 'ML', 'z'] -= 10
subset.loc[subset.bin == 'BL', 'z'] -= 5

with plt.rc_context({'font.size': 8}):
    f, ax = vert_distrib(subset, subset.bin, varname='KT',
                         label_moorings=False, label_bins=True, adjust_fig=False,
                         width=8, percentile=False, add_offset=False)

    for aa in ax:
         ax[aa].yaxis.set_visible(True)
         ax[aa].spines['left'].set_visible(True)

    ax['NE'].set_yticklabels(['', '', '15', '//', '', '100'])
    ax['NE'].set_ylim([28, 0])
    plt.gcf().set_size_inches((6.2, 1.8))
    plt.suptitle('$\log_{10}$ hourly averaged $K_T$ (m²/s)', y=-0.15, va='baseline')
    plt.subplots_adjust(wspace=0.07)
    sns.despine(fig=f, left=False, bottom=False, trim=True)

plt.savefig('images/rama-vs-nrl-kt.svg')
# plt.tight_layout(w_pad=-1)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1754]:
:END:

** nrl5 adcp near-inertial
#+BEGIN_SRC ipython :session :ipyfile images/nrl5-near-inertial-adcp.png
#from dcpy.ts import xfilter
#f,  axx = plt.subplots(3, 1, sharex=True)
# ax = dict(Kt=axx[0], u=axx[1], v=axx[2])
# (nrl5.KT.isel(depth=1)
# .sel(**nrl5.select_region(['Storm+IW'])).plot(ax=ax['Kt']))
# ax['KT'].set_yscale('log')
# axv
with plt.rc_context({'font.size': 14}):
    ax, hc = nrl5.PlotVel(region='Storm+IW')
    ax['u'].set_ylim([250, 0])
    ax['v'].set_ylim([250, 0])
    ax['v'].set_xlabel('')

arrowprops = dict(arrowstyle="<-", connectionstyle="arc3")

hanno.remove()
hanno = ax['v'].annotate("",
                       xy=('2014-07-18', 70), xycoords='data',
                       xytext=('2014-08-7', 150), textcoords='data',
                       arrowprops=arrowprops)
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[1681]:
[[file:images/nrl5-near-inertial-adcp.png]]
:END:

** χpod depths on ARGO climatology
#+BEGIN_SRC ipython :session :ipyfile images/argo-clim-χpod-depths.png
<<define-make_map>>
argoT = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Temperature_2016.nc',
                        autoclose=True, decode_times=False)
argoS = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Salinity_2016.nc',
                        autoclose=True, decode_times=False)

def mark_range(ax, top, middle, bottom, color=colors['NRL']):
   xlim = ax.get_xlim()
   ax.fill_between([xlim[0], xlim[1]], bottom, top,
                   facecolor=color, alpha=0.1, zorder=-5)
   dcpy.plots.liney(middle, ax=ax,
                 color=colors['NRL'], linestyle='-')

def plot_profiles(ax, lon, lat, color):

   region = {'LATITUDE': lat, 'LONGITUDE': lon, 'method': 'nearest'}

   ax.plot(argoT.ARGO_TEMPERATURE_MEAN.sel(**region).squeeze(),
           argoT.PRESSURE, color=color, lw=2)
   ax2 = ax.twiny()
   ax2.plot(argoS.ARGO_SALINITY_MEAN.sel(**region).squeeze(),
            argoS.PRESSURE, '--', color=color, lw=2)

   ax2.spines['top'].set_visible(True)
   ax.set_xlim([23, 30])
   ax.set_ylabel('Pressure')
   ax.text(29, 10, 'T', color=color)
   ax.text(23.75, 10, 'S', color=color)
   ax.text(25.5, 114, 'Argo clim.', color='black',
           ha='center', fontsize=12)

   return ax2


with plt.rc_context({'font.size': 15}):

   f, ax = plt.subplots(2, 1)
   ax20 = plot_profiles(ax[0], 90, 12, color=colors['RAMA'])
   ax21 = plot_profiles(ax[1], 85.5, 5, color=colors['NRL'])
   mark_range(ax[1], 55, 60, 100)
   mark_range(ax[1], 75, 80, 115)
   mark_range(ax[1], 28, 32, 78)
   mark_range(ax[1], 48, 52, 100)
   mark_range(ax[1], 60, 63, 85)
   mark_range(ax[1], 80, 83, 105)
   dcpy.plots.liney([85, 105], ax=ax[1],
                    color=colors['NRL'], linestyle='-')
   dcpy.plots.liney([15, 30, 45], ax=ax[0],
                    color=colors['RAMA'], linestyle='-')

   ax[0].set_ylim([120, 0])
   ax[1].set_ylim([120, 0])

   f.set_size_inches(3, 8)
   plt.tight_layout()

#+END_SRC
#+RESULTS:
:RESULTS:
# Out[1357]:
[[file:images/argo-clim-χpod-depths.png]]
:END:

* Surface fluxes
#+CALL: read-tropflux()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img7tMMDR.png
# sst = ra12.ctd['T'].sel(depth=1).groupby('time.month').mean(dim='time')

timebase = 'weekofyear'

tfsel = tropflux.sel(longitude=90, latitude=12, method='nearest')
tf = (tfsel.groupby('time.'+timebase)
      .mean(dim='time'))

jq0 = tf.netflux

if 'mldclim' not in locals():
   mldclim = dcpy.oceans.argo_mld_clim()

mld = mldclim.mld_da_mean.sel(lon=90, lat=12, method='nearest')

if timebase == 'weekofyear':
   ihi = np.interp(np.linspace(1,13, 53), mld.month,
                   0.45 * tfsel.swr.groupby('time.month').mean(dim='time')
                   ,* np.exp(-0.04 * mld))
   Ih = xr.DataArray(ihi, dims=[timebase],
                     coords=[jq0[timebase]], name='Ih')
else:
   Ih = 0.45*tfsel.swr.groupby('time.month').mean(dim='time')

f, ax = plt.subplots(2,1)
hsst = tf.sst.plot(ax=ax[0],color='k')
ax0 = ax[0]
ax1 = ax0.twinx()
hjq0 = ax1.fill_between(jq0[timebase], jq0-Ih, color='salmon')
ax1.set_zorder(-10)
ax1.axhline(0, color='k')
# hIh = Ih.plot.line('k--', ax=ax1)

ax0.set_title(''); ax1.set_title('');

_ = f.legend((hsst[0], hjq0),
           ('SST', 'Jq0-Ih'),
           loc='upper center')

jq14 = ra12.Jq.sel(time='2014').groupby('time.'+timebase).mean(dim='time')
jq15 = ra12.Jq.sel(time='2015').groupby('time.'+timebase).mean(dim='time')
jqt = (jq14.fillna(0) + jq15.fillna(0))/2
jqt.plot.line(ax=ax1)

_ = (mld*-1).plot(ax=ax[1])
args = {'color': 'k', 'ls': '--'}
ax[1].axhline(-15, **args)
ax[1].axhline(-30, **args)
ax[1].axhline(-45, **args)
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img7tMMDR.png]]
* Seasonal patterns
** depth of salinity surfaces

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgzT2m1u.png :results drawer
clim = xr.open_dataset('~/work/datasets/nio-atlas/nioa_climatology_seasonal_temp_salt_monsoon_season.nc', decode_times=False)

_, zmat = xr.broadcast(clim.SALT, clim.DEPTH)

S0 = 35
isodepth = zmat.where(np.logical_and(clim.SALT > 34.9, clim.SALT < 35.1)).mean(dim='DEPTH')

isodepth.plot(x='LONGITUDE', col='TIME', col_wrap=2, levels=np.arange(10, 500, 30))
#+END_SRC

#+RESULTS:
:RESULTS:
: <xarray.plot.facetgrid.FacetGrid at 0x7f44b39be6d8>
[[file:images/temp/imgzT2m1u.png]]
:END:
** "pycnocline uplift"
It is quite hard to see if there is a semi-regular period.

This could be the large-scale ∇S being advected back and forth across the mooring.
1. At 12N, it happens in Jul-2014, Jul-2015

#+BEGIN_SRC ipython :session :ipyfile images/rama-sal-mosaic.png :results drawer
sal = xr.open_dataset('~/TaoTritonPirataRama/RAMA/s_xyzt_dy.cdf',
                      autoclose=True)['S_41'].sel(lon=90, lat=[12,15])
sal.values[sal.values > 40] = np.nan
sal = sal.dropna(dim='depth', how='all')

def process(x):
    x = x.expand_dims('year')
    x['year'] = x.time.dt.year.pipe(np.unique)
    x['time'] = x.time.dt.dayofyear
    x = x.rename({'time': 'dayofyear'})
    return x

stacked = [process(a[1]) for a in sal.groupby('time.year')]

syearly = (xr.concat(stacked, dim='year')
           .dropna(dim='year', how='all')
           .drop([2007, 2018], dim='year'))

g = syearly.plot.contourf(x='dayofyear', row='year', col='lat',
                          robust=True, levels=40, yincrease=False, size=1, aspect=7)
# g.axes[0,0].set_xlim([0, 100])
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/rama-sal-mosaic.png]]
:END:
*** old figures :noexport:
[[file:images/15n-sal.png]]
[[file:images/12n-sal.png]]
** K_T variations
#+CAPTION: Distribution of 5 minute averages of K_T.
#+RESULTS:
[[file:../images//rama12n-kt-boxplot.png]]

* Barrier layers
When the freshwater arrives, I see large values of Jqt at 30m/45m. This is at both 12N, 15N in both 2014, 2015.

- This observation contradicts the presence of layers hmmm...

- Some of these are where T_z changes sign frequently. (╯°□°）╯︵ ┻━┻

- Sally says that in the Gulf of Mexico she thinks that ambient water is getting subducted under river plumes and mixing there because of strong shear at the base. This is as opposed to the standard barrier layer idea that there is not much mixing happening beneath the mixed layer: i.e., the freshwater cap prevents wind-forced turbulence from penetrating downward?

- Ritabrata observes similar stuff: high mixing near the base and mixing shuts down in 10-20m range below the base.

Some examples follow.
#+NAME: barrier-rama15-2015
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama15-2015-feb.png :results raw
ax = ra15.Plotχpods(region={'time': slice('2015-02-01', '2015-03-31')},
                    filt='mean',  filter_len=6*3600, Tlim=[26.5,28])
_ = ax['T'].set_ylim([50,0])
_ = ax['Jq'].set_yscale('symlog', linthreshy=10, linscaley=0.5)
#+END_SRC
#+ATTR_HTML: :class full-width
#+CAPTION: In this one, the rise in turbulence at 30m coincides with *speed increasing*. 30m χpod sees relatively few changes in T_z sign, but high heat fluxes (compare with below). The "waviness" seems to be M_2.
#+RESULTS: barrier-rama15-2015
[[file:images/barrier-layer-rama15-2015-feb.png]]

When the freshwater arrives we see stronger M_2 tides, maybe a packet came by? But the variability is confined to 20m, 40m CTDs.

#+BEGIN_SRC ipython :session :ipyfile images/rama-15n-freshwater-M2.png
f, ax = plt.subplots(3,1, sharex=False, sharey=False)

(ra15.ctd.S.sel(depth=[10, 20, 40, 60],
                time=slice('2015-02-01', '2015-04-10'))
.plot.line(x='time', ax=ax[0]))

(ra15.ctd.S.sel(depth=[10, 20, 40, 60],
                time=slice('2015-02-22', '2015-03-01'))
.plot.line(x='time', ax=ax[1], add_legend=False))
ax[0].set_title('RAMA 15N, arrival of freshwater 2015 - Note M2 signal')

specargs =dict(dt=600/86400, nsmooth=2, multitaper=True, preserve_area=False, ax=ax[2])
dcpy.ts.PlotSpectrum(ra15.ctd.S.sel(depth=40,
                                    time=slice('2015-02-16', '2015-03-10')),
                     **specargs)
dcpy.ts.PlotSpectrum(ra15.ctd.S.sel(depth=40,
                                    time=slice('2015-03-20', '2015-04-10')),
                     **specargs)
ax[2].set_ylim([10**-5, 1])
ax[2].set_xlabel('Freq (cpd)')
dcpy.plots.linex([1/(2*np.pi/dcpy.oceans.coriolis(15)/86400),
                  24/12.42], ax=ax[2])

plt.gca().set_title('Spectra of salinity at 40m | RAMA 15N, 90E')
plt.legend(['2015-Feb-16 - 2015-Mar-10', '2015-Mar-20 - 2015-Apr-10'])
# plt.gca().set_yscale('linear')
# plt.gca().set_ylim([0, 1])

plt.setp(ax[0].get_xticklabels(), visible=True, rotation=20)
plt.setp(ax[1].get_xticklabels(), visible=True, rotation=20)

f.set_size_inches((8.5, 12.5))
plt.tight_layout()
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/rama-15n-freshwater-M2.png]]
:END:

10m velocity is not useful: 10m salinity behaves much differently. There's a near inertial packet Mar 13-17, otherwise just M2 in velocity.
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgt8hw0H.png
hdl, ax = (dcpy.ts.PlotSpectrum((ra15.vel.u+1j*ra15.vel.v)
                                .squeeze().sel(time=slice('2014-02-16',
                                                          '2014-03-10')),
                                multitaper=True, dt=30*60/86400))
hdl, ax = (dcpy.ts.PlotSpectrum((ra15.vel.u+1j*ra15.vel.v)
                                .squeeze().sel(time=slice('2014-03-12',
                                                          '2014-04-10')),
                                multitaper=True, dt=30*60/86400, ax=ax))

dcpy.plots.linex([1/(2*np.pi/dcpy.oceans.coriolis(15)/86400),
                  24/12.42], ax=ax)
ax[1].set_xlim([1e-1, 1e1])
ax[0].set_xlim([1e1, 1e-1])
#+END_SRC

#+RESULTS:
:RESULTS:
: (10.0, 0.1)
[[file:images/temp/imgt8hw0H.png]]
:END:

#+NAME: barrier-rama12-2014
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama12-2014-feb.png :results raw
ax = ra12.Plotχpods(region={'time': slice('2014-02-20', '2014-03-20')},
                    Tlim=[26.5, 28.75],
                    filt='hann',  filter_len=3*3600)
_ = ax['T'].set_ylim([60,0])
#+END_SRC
#+CAPTION: Here, both χpods see frequent changes in the sign of T_z and heat fluxes are large and change sign often. |T_z| stays decently big (0.01-0.1) for chunks of time --- these are associated with large fluxes. Maybe using internal T_z might make sense here.
#+RESULTS: barrier-rama12-2014
[[file:images/barrier-layer-rama12-2014-feb.png]]

#+NAME: barrier-rama12-2015
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama12-2015-apr.png :results raw
ax = ra12.Plotχpods(filt='hann',  filter_len=6*3600, met='tropflux')
_ = ax['T'].set_ylim([60,0])
_ =  ax['met'].set_xlim(('2015-04-10', '2015-05-10'))
#+END_SRC
#+CAPTION: Not that similar to above (but see 2015/04/15-2015/04/18). Here, 45m χpod sees large heat fluxes.
#+RESULTS: barrier-rama12-2015
[[file:images/barrier-layer-rama12-2015-apr.png]]
* Hudhud sensitivity to Jq
# Read data
#+BEGIN_SRC ipython :session
def read_Turb(filename):
    from scipy.io import loadmat
    f = loadmat(filename)

    def process_estimate(estimate):
        chi = xr.Dataset()
        tmatlab = estimate[0,0]['time'][0,0].squeeze()
        tcommon = ((-86400 + (tmatlab-366) * 86400).astype('timedelta64[s]')
                   + np.datetime64('0001-01-01')).astype('datetime64[ns]')

        chi['χ'] = xr.DataArray(estimate[0,0]['chi'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['Kt'] = xr.DataArray(estimate[0,0]['Kt'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['Jq'] = xr.DataArray(estimate[0,0]['Jq'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['ε'] = xr.DataArray(estimate[0,0]['eps'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])

        return chi

    Turb = dict()
    for field in f['Turb'].dtype.names:
        if field in ['mm1', 'mm2', 'pm1', 'pm2',
                     'mi11', 'mi22', 'pi11', 'pi22']:
            estimate = f['Turb'][field]
            Turb[field] = process_estimate(estimate)
    return Turb

dirname = '/home/deepak/pods/526/proc/'
est = dict()
for tz in [1e-4, 3e-4, 7.5e-4, 1e-3, 2e-3, 5e-3]:
    filename = dirname + 'Turb-{0:.1e}.mat'.format(tz)
    print(filename)
    est[tz] = read_Turb(filename)

#+END_SRC

# plot results
#+BEGIN_SRC ipython :session
trange = slice('2014-10-07','2014-10-11')
hudhud = slice('2014-10-08','2014-10-10 12:00')

barwidth = 1e-4
f, ax = plt.subplots(2, 1)
for ee in est.keys():
    Jqvec = est[ee]['mm1'].Jq
    (Jqvec
     .resample(time='H').mean()
     .sel(time=trange)
     .plot(ax=ax[1], lw=1, label=ee))

    hb = ax[0].bar(ee, Jqvec.where(Jqvec > 0).sel(time=hudhud).mean(),
                   barwidth)
    ax[0].bar(ee, Jqvec.where(Jqvec < 0).sel(time=hudhud).mean(),
              barwidth, color=hb[0].get_facecolor())
    ax[0].plot(ee, Jqvec.sel(time=hudhud).mean(), 'k.')

ax[0].set_title('Mean heat flux (+/-) during Hudhud as fn(min_dTdz)')

hwda = (ra12.Jq.sel(depth=15, time=trange)
        .plot(ax=ax[1], add_legend=False, label='wda'))
ax[1].legend()

dcpy.plots.liney([ra12.Jq.where(ra12.Jq > 0).sel(depth=15, time=hudhud).mean(),
                  ra12.Jq.where(ra12.Jq < 0).sel(depth=15, time=hudhud).mean()],
                 ax=ax, color=hwda[0].get_color(), zorder=8)
dcpy.plots.liney(0, ax=ax, zorder=10, color='k', ls='-')

plt.savefig('/home/deepak/bay/images/526-heat-flux-dTdz.png', bbox_inches='tight')
#+END_SRC

#+CAPTION: Sensitivity to ~min_dTdz~. Looks like there are a lot of observations at T_z ~ 1e-3. For lower values of ~min_dTdz~, there is a lot of +/- cancellation. Which do I believe?
file:images/526-heat-flux-dTdz.png

#+CAPTION: Turns out removing IC fits removes a lot of data during Hudhud.
[[file:images/wda-526-hudhud-jq-masking.png]]

* Spectrogram
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgoi5WUg.png
spec = dcpy.ts.Spectrogram(ra15.vel.spd.interpolate_na(dim='time').squeeze(),
                           dim='time',
                           window=(7*86400)/(30*60),
                           shift=(3.5*86400)/(30*60), nsmooth=15)
np.log10(spec).plot.contourf(x='time', levels=40);
plt.gca().set_yscale('log')
#+END_SRC

#+RESULTS:

* MISO signals?
** Summary
cite:Sobel2010 show large TRMM 30-90 day variance between May and October in the Bay.
[[file:../images//sobel-trmm-variance.png]]

#+CAPTION: Subsurface anomalies line up with northward propagating features in SST, LWR.
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]

#+CAPTION: Southward propagating signals in 2011-Nov/Dec!
#+RESULTS:
[[file:images/bandpass-90e-2011.png]]

*** old                                                          :noexport:
I see northward propagating "anomalies" in Tropflux SWR.
[[file:images/90e-swr-anom.png]]
** in mixing
*** RAMA 12N
**** Coherence
- Note sure coherence is the way to do this given short records

The next figure shows coherence between Jq0 and  Jqt at 15m, 30m at the RAMA 12N mooring for the year 2014. Signs for all fluxes are such that +ve warms the surface.
Looks like we have significant coherence in the 20-60day band between daily averaged Jq0 and Jqt at 15m.
The 180 phase difference looks stable, is apparent in the filtered time series and seems to make physical sense (more surface heating → increases T_z → reduces J_q^t and vice versa).

Nothing at 30m
 - short(er) data record - instrument dies in september
 - not much temp fluctuations at that depth while the instrument was alive (see above).

#+CAPTION: (Top left) Band-passed time series. (bottom left) PSD for the unfiltered time series. (Right) coherence amplitude and phase between J_q^0 and J_q^t at both depths. Significance level marked by horizontal line. Pass band marked by vertical lines.
file:rama/images/ra12-jq0-jqt-coherence.png
** temp / salinity record
*** Stratification T_z
Filtered T_z?
#+BEGIN_SRC ipython :session :ipyfile images/ra12n-bandpass-strat.png
from dcpy.plots import offset_line_plot
f, ax = plt.subplots(4, 1, sharex=True)

trange = slice('2014-06', '2014-08')
T = rama.SelectVar('T', dict(lon=90))
Tz = (T.sel(lat=12)
      .dropna(dim='depth', how='all')
      .drop(-13, dim='depth')
      .diff(dim='depth'))
Tz /= Tz.sel(time=trange).std(dim='time')
Tzbp = (Tz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Tzbp /= Tzbp.sel(time=trange).std(dim='time')

S = rama.SelectVar('S', dict(lon=90))
Sz = (S.sel(lat=12)
      .dropna(dim='depth', how='all')
      .diff(dim='depth'))
Sz /= Sz.sel(time=trange).std(dim='time')
Szbp = (Sz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Szbp /= Szbp.sel(time=trange).std(dim='time')

dcpy.plots.offset_line_plot(
    Tz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[0])

dcpy.plots.offset_line_plot(
    Tzbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[1])

dcpy.plots.offset_line_plot(
    Sz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[2])

dcpy.plots.offset_line_plot(
    Szbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[3])

ax[0].set_ylabel('$ΔT$')
ax[1].set_ylabel('$ΔT$\'')
ax[2].set_ylabel('$ΔS$')
ax[3].set_ylabel('$ΔS$\'')

dcpy.plots.liney(0, ax=ax[0])
dcpy.plots.liney(0, ax=ax[1])

plt.suptitle('10-80 day bandpass filtered at χpod depths / normalized by std.', y=1.0)
plt.tight_layout()
plt.gcf().autofmt_xdate()
#+END_SRC

#+RESULTS:
[[file:images/ra12n-bandpass-strat.png]]
*** Subsurface MISO signals?
What am I looking for?
1. northward propagation of MISO signal
2. subsurface MISO signals in 30d-90d band

#+BEGIN_SRC ipython :session :ipyfile images/temp/asd02j.png :noweb yes
if 'rama' not in locals():
     print('reading rama')
     <<read-rama-array>>

flen = np.array([10.0, 80.0])
hdl, var = rama.hov('T', region=dict(lon=90, depth=[-1, -10, -20]),
                    row='depth', filt='bandpass',
                    filter_len=flen*86400)

plt.gcf().set_size_inches((8.5, 2.5))
plt.gca().set_xlim(['2011-01-01', '2013-07-01'])
plt.gcf().autofmt_xdate()
# plt.gcf().suptitle('bandpass ' + str(flen) + 'days')
#+END_SRC
#+CAPTION: Hovmöller plot of RAMA 90E data | Bandpassed 10, 80 days. Looks like _southward_ propagation in Nov/Dec 2011.
#+RESULTS:
[[file:images/temp/asd02j.png]]
#+BEGIN_SRC ipython :session :ipyfile images/rama-iso-T-std.png :noweb yes
if 'rama' not in locals():
    <<read-rama-array>>

from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

Tfilt = BandPassButter(rama.T.where(rama.T < 40), freqs=freqs, dim='time')

MayToOct = np.logical_and(Tfilt.time.dt.month >=5,
                          Tfilt.time.dt.month <= 10)

def plot_temp_std_along_lon(Tfilt, inmask, lon):
    f, ax = plt.subplots(2, 2, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx], cmap=mpl.cm.Reds))

        # normalize at each lat,lon by maximum in depth
        Tnorm = Tstd / Tstd.max(dim='depth')
        Tnorm.name = 'normalized to \n show structure'
        (Tnorm.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx+2], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_along_lon(Tfilt, MayToOct, lon=90)
#+END_SRC
#+CAPTION: Lon = 90: Max 30-90 day std dev is within 5S-5N as expected from Han (2005). Seems independent of season. Subsurface peak = thermocline? Agrees with Girishkumar et al (2013)
#+RESULTS:
[[file:images/rama-iso-T-std.png]]

#+BEGIN_SRC ipython :session :ipyfile images/iso-T-std-lat-lon-map.png
def plot_temp_std_lat_lon(Tfilt, inmask):
    ''' Takes max. std along depth and plots in (lon, lat) space'''
    f, ax = plt.subplots(2, 1, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.dropna(dim='depth', how='all')
             .dropna(dim='lat', how='all')
             .max(dim=['depth']).transpose()
             .plot(ax=ax[idx], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_lat_lon(Tfilt, MayToOct)
#+END_SRC
#+CAPTION: Taking max(std) along depth → (lon, lat) map. Some sign of near-equatorial maxima.
#+RESULTS:
[[file:images/iso-T-std-lat-lon-map.png]]


#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907n9q.png
from dcpy.ts import apply_along_dim_1d

freqs = [1/30.0, 1/60.0]

T = rama.T.copy()

T.values[T.values > 40] = np.nan

apply_along_dim_1d(T, 'time', dcpy.ts.FillGaps, x=T.time, maxlen=20)

bp = (BandPassButter(T.sel(lon=90, lat=[15, 12, 8])
                     .dropna(dim='time', how='all'),
                     freqs=freqs, dim=['time'])
      .dropna(dim='depth', how='all'))

bp.plot.contourf(row='lat', x='time', levels=40)
plt.gcf().set_size_inches((8.5, 4.5))
plt.gca().set_ylim([-140, 0])
# plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img3907n9q.png]]

#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img9554Dcu.png
from dcpy.plots import offset_line_plot

T = rama.SelectVar('T', dict(lon=90.0))

T = T.groupby('time.month') - T.groupby('time.month').mean(dim='time')
Tclim = T.groupby('time.dayofyear').mean(dim='time')
Tanom = T.groupby('time.dayofyear') - Tclim


offset_line_plot(T.sel(depth=-1)
           .dropna(dim='time', how='all'),
          x='time', y='lat')
plt.gca().set_xlim('2011', '2014')

# Tanom.sel(depth=-1).plot()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC

#+RESULTS:
[[file:images/temp/img9554Dcu.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-90e-2014.png :noweb yes
freqs = [1/10.0, 1/80.0]
time = '2015'

<<bandpass-mosaic>>
#+END_SRC
#+CAPTION: Southward propagating signals in 2011-Nov/Dec, but not so much in 2014?
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]
*** Spectra
#+call: read-mur()

#+NAME: calc-spec
#+BEGIN_SRC ipython :session :results none
import xarray as xr
from dcpy.ts import SpectralDensity

var = rama.SelectVar('T', region=dict(lon=90, lat=12)).dropna(dim='depth', how='all')

iz = var.get_axis_num('depth')

spec = []
for zz in range(var.shape[iz]):
    S, f, conf = SpectralDensity(var.isel(depth=zz), dt=1,
                                 multitaper=False, nsmooth=2,
                                 fillgaps=True, maxlen=60)
    # create a DataArray
    spec.append(xr.DataArray(S, coords=[f], dims=['freq'],
                             attrs={'depth': var.depth.values[zz]},
                             name='PSD'))
#+END_SRC

:code-notes:
1. Let's try FFT - yes, using ~apply()~ works like doing things manually. +But results look weird+ xarray isn't respecting missing_value; haven't figured out why :(

2. bah gaps are non-uniform at all depths. can't do the groupby-apply thing. lets make a list of DataArrays and iterate over them when we plot.

3. xarray line-plots are only for 1D data.

:END:
#+CALL: calc-spec()
#+BEGIN_SRC ipython :session :ipyfile images/12n-spectra.png :exports results
if 'mur' in locals():
    S, f, conf = dcpy.ts.SpectralDensity(mur['sst'].sel(lon=90, lat=12), multitaper=True)
    plt.loglog(f, S*10**1.25, label='SST', lw=0.5)

for si, ss in enumerate(spec[0:8]):
    (ss*10**-si**1.15).plot(label=str(ss.depth), lw=0.5)

plt.title('12N 90E')
ax = plt.gca()
ax.set_xscale('log')
ax.set_yscale('log')
ax.legend()
plt.gcf().set_size_inches(8.5, 5.5)
plt.xlim([10**-3.5, 1])
#+END_SRC

#+RESULTS:
[[file:../images/12n-spectra.png]]

*** spectra old :noexport:
#+BEGIN_SRC ipython :session :ipyfile images/temp/img16594-DQ.png
data = rama.SelectVar('T', region=dict(lon=90, lat=12, depth=10))

S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=True)
plt.loglog(f, S)
S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=False)
plt.loglog(f, S)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img16594-DQ.png]]

#+BEGIN_SRC ipython :session
%matplotlib inline

import moor.moor as moor
import chipy.chipy as chipy

moor = importlib.reload(moor)
chipy = importlib.reload(chipy)

import os
if 'rama' not in os.getcwd():
    os.chdir('/home/deepak/rama/scripts/')

ra12 = moor.moor(90, 12, 'RAMA 12N', '../RAMA13/')
# ra12.AddChipod(526, 15, 'mm', '2017-07-10.mat')
# ra12.AddChipod(527, 30, 'mm', '2017-07-10.mat')
ra12.ReadMet('../RAMA13/rama_mooring_data/', WindType='pmel')
# ra12.ReadCTD('../RamaPrelimProcessed/RAMA13.mat', 'ramaprelim')
ra12.ReadCTD('../data/', 'rama')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :session :ipyfile images/temp/py28335Frc.png
dcpy.ts = importlib.reload(dcpy.ts)
dcpy.oceans = importlib.reload(dcpy.oceans)
dcpy.plots = importlib.reload(dcpy.plots)

freqs = [1/(2*np.pi/dcpy.oceans.inertial(ra12.lat)/86400),
         dcpy.ts.AliasFreq(1/(12.42/24), 1),
         1/30, 1/90]

nsmooth = 4
subset = None
mtflag = True

plt.figure(figsize=(6.5, 10.5))
ax0 = plt.subplot(211)
dcpy.ts.PlotSpectrum(ra12.ctd.Tlong, SubsetLength=subset, ax=ax0,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
ax0.set_ylabel('PSD (T)')
if mtflag:
    ax0.set_title('Multitaper')

dcpy.plots.linex(freqs)
ax1 = plt.subplot(212, sharex=ax0)
dcpy.ts.PlotSpectrum(ra12.ctd.Slong, SubsetLength=subset, ax=ax1,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
dcpy.plots.linex(freqs)
ax1.set_ylabel('PSD (S)')
ax1.set_xlabel('Freq (cpd)')

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//temp/py28335Frc.png]]

** winds at EBOB and rama
#+BEGIN_SRC ipython :session :ipyfile images/bob-winds.png
from scipy.interpolate import interpn

tau = nc.MFDataset('../tropflux/tau_tropflux*')
flx = nc.MFDataset('../tropflux/netflux_tropflux*')

ttime = tau['time'][:]
ftime = flx['time'][:]

ax = [1, 1, 1, 1]
ax[0] = plt.subplot(4, 1, 1)
ax[0].set_title('RAMA')
ax[1] = plt.subplot(4, 1, 2, sharex=ax[0])
ax[1].set_title('EBOB')
ax[2] = plt.subplot(4, 1, 3, sharex=ax[0])
ax[2].set_title('RAMA')
ax[3] = plt.subplot(4, 1, 4, sharex=ax[0])
ax[3].set_title('EBOB')

for latm, lonm in zip([12, 18, 5.5, 8],
                     [90, 90, 85.5, 88.5]):

    if latm < 12:
        ind = 1
    else:
        ind = 0

    label = str(latm) + 'N, ' + str(lonm) + 'E'
    τtrop = interpn((ttime,
                     tau['latitude'][:],
                     tau['longitude'][:]),
                    tau['tau'][:, :, :],
                    (ttime, latm, lonm))
    ftrop = interpn((ttime,
                     flx['latitude'][:],
                     flx['longitude'][:]),
                    flx['netflux'][:, :, :],
                    (ttime, latm, lonm))
    ttrop = ttime \
            + dt.date2num(dt.datetime.date(1950, 1, 1))

    ax[ind].plot(ttrop, τtrop, label=label)
    ax[ind+2].plot(ttrop, ftrop, label=label)

for ind in [0,1]:
    ax[ind].xaxis_date()
    ax[ind].legend()
    ax[ind].set_ylim([0, 0.4])
    ax[ind].set_ylabel('τ (N/m²)')
    ax[ind+2].set_ylabel('flux (W/m²)')

ax[0].set_xlim([dt.datetime.datetime(2013, 11, 29, 0, 0, 0),
                dt.datetime.datetime(2015, 1, 1, 0, 0, 0)])
ax[2].axhline(0, color='gray')
ax[3].axhline(0, color='gray')
plt.gcf().autofmt_xdate()
plt.tight_layout()
#+END_SRC
#+RESULTS:
[[file:../images//bob-winds.png]]
** in SWR
Look at anomalies:
1. Subtract yearly average.
2. Subtract daily climatology (2001-2017)

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-anom.png :noweb yes
if 'swr' not in locals():
    <<read-tropflux-swr>>
swr['swr'].load()

grpstr = 'time.dayofyear'

# pick location
sw = swr['swr'].sel(longitude=90.5, latitude=slice(0.5, 22.5))
# remove yearly average
swa = (sw.groupby('time.year')
       - sw.groupby('time.year').mean(dim='time'))
# make daily climatology
clim = sw.groupby(grpstr).mean(dim='time')
# get daily anomalies
anom = sw.groupby(grpstr) - clim

f, ax = plt.subplots(3, 1, sharey=True)

(anom.sel(time=slice('2014-05', '2014-09'))
     .plot(x='time', y='latitude', ax=ax[0]))
(anom.sel(time=slice('2015-05', '2015-09'))
     .plot(x='time', y='latitude', ax=ax[1]))

(anom.sel(time=slice('2013', '2016'))
     .groupby('time.dayofyear')
     .mean(dim='time')
     .plot(x='dayofyear', y='latitude', ax=ax[2]))
ax[2].set_title('anomalies averaged over 2013-2016')

ax[0].set_xlabel('')
ax[1].set_xlabel('')
ax[1].set_title('')

plt.tight_layout()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC
#+CAPTION: Shortwave radiation anomalies w.r.t daily climatology [2001-2017]. Definitely see northward propagating anomalies along 90°E. Propagation is most evident for lat > 8°N. Winter is quite for lat > 10.
#+RESULTS:
[[file:images/90e-swr-anom.png]]

Let's try 10-80day filter like cite:Sengupta2001a
#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SWR.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

if 'swr' not in locals():
    swr = xr.open_mfdataset('../datasets/tropflux/swr*.nc', autoclose=True)

swr['swr'].load()

bp = (
    swr['swr'].sel(longitude=[85, 90], method='nearest')
    .pipe(BandPassButter, freqs, dt=1, dim='time')
)

bp.sel(time='2014').plot(x='time', row='longitude')

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC
#+CAPTION: bandpass filter yields same results as above (slightly smoother).
#+RESULTS:
[[file:images/bandpass-SWR.png]]

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-spec.png
dcpy.ts.PlotSpectrum(swr['swr'].sel(latitude=[15, 12, 8], longitude=90, method='nearest'), multitaper=True, nsmooth=5, scale=5)
dcpy.plots.linex([1/10.0, 1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0, 1/120, 1/180, 1/360])
plt.title('Tropflux SWR spectra along 90E')
plt.legend(('15N', '12N', '8N'))
#+END_SRC
#+CAPTION: Spectra of SW radiation along 90°E. Seasonal cycle harmonics are very evident 360, 180, 90, 45. 120-day peak at 8N, 12N.
#+RESULTS:
[[file:images/90e-swr-spec.png]]

** SST analysis
*** test snapshot
#+CALL: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907o-U.png
mur['sst'].isel(time=1).plot()
#+END_SRC
#+CAPTION: Test snapshot
#+RESULTS:
[[file:../images//temp/img3907o-U.png]]
*** spec
#+call: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/mur-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

# psd = xrft.power_spectrum(mur['sst'].sel(lon=90, lat=12), dim=['time'], density=True, window=True, detrend='constant')
scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = mur.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('MUR SST spectra along RAMA line')
plt.legend()
#+END_SRC
#+CAPTION: MUR SST spectra 2013-2016
#+RESULTS:
[[file:images/mur-spectra-RAMA-line.png]]


#+BEGIN_SRC ipython :session :ipyfile images/cmc-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = cmc.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('CMC SST spectra along RAMA line (2007-2017)')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:images/cmc-spectra-RAMA-line.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SST.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]


(cmc['sst'].sel(lon=[85, 90], method='nearest')
           .where(cmc.mask == 1)
           .pipe(BandPassButter, freqs, dt=1, dim='time')
           .sel(time='2014')
           .plot(x='time', row='lon'))

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC

#+RESULTS:
[[file:images/bandpass-SST.png]]
*** SST variance map
#+BEGIN_SRC ipython :session :results none
freqs = [1/30.0, 1/90.0]

bp = dcpy.ts.BandPassButter(sst, freqs=freqs, dim=['time'])
bp = bp.dropna(dim='time', how='all')

# dcpy.ts.PlotSpectrum(mur['sst'].sel(lon=90, lat=12))
# dcpy.plots.linex(freqs)
# dcpy.ts.PlotSpectrum(bp.sel(lon=90, lat=12))
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907dce.png]]
#+BEGIN_SRC ipython :session :results none
import matplotlib.animation

def animate(i):
    import matplotlib.pyplot as plt
    plt.clf()
    hdl = bp.isel(time=i).plot()
    return hdl

anim = mpl.animation.FuncAnimation(plt.gcf(), animate)

anim.save('sst-iso.mp4', fps=5)
#+END_SRC
* vel spectra

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907nzu.png
u = rama.SelectVar('u', region=dict(lon=90, lat=12))
v = rama.SelectVar('v', region=dict(lon=90, lat=12))
KE = 0.5*np.hypot(u,v)

dcpy.ts.PlotSpectrum(KE)
dcpy.ts.PlotSpectrum(KE, multitaper=True)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907nzu.png]]


#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907fRQ.png
np.sqrt(N2).plot()
plt.ylabel('N (1/s)')
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907fRQ.png]]

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907mHE.png
KE = np.hypot(ra12.vel.u, ra12.vel.v)*2

dcpy.ts.PlotSpectrum(KE, dt=30*60.0, multitaper=False, label='KE 10m')

# figure out N²
woa = dcpy.oceans.ReadWoa(lon=90, lat=12, return_xr=True)
N2, _, pn2 = sw.bfrq(woa['S'], woa['T'], woa['depth'], lat=12)

N2 = xr.DataArray(np.squeeze(N2), coords=[np.squeeze(pn2)], dims=['depth'])
N = np.sqrt(N2)
omg, K_omg, P_omg, _, _, _ = dcpy.oceans.GM(lat=12.0,
                                            N=N.sel(depth=10, method='nearest').values,
                                            N0=N.sel(depth=50, method='nearest').values)

# plot frequency spectra
ax = plt.gca()
ax.loglog(omg/(2*np.pi), 2*np.pi*K_omg, label='GM81 KE')
ax.loglog(omg/(2*np.pi), 2*np.pi*P_omg, label='GM81 PE')
ax.legend(frameon=False)
ax.set_title('energy spectra')
ax.set_xlabel('frequency (cps)')
ax.set_ylabel('power spectral density (m^2/s^2/cps)')

#+END_SRC
#+CAPTION: Attempt at GM spectra for KE
#+RESULTS:
[[file:../images//temp/img3907mHE.png]]

* TS plots

#+BEGIN_SRC ipython :session :ipyfile images/TS.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.TSPlot(ax=ax3)
nrl5.TSPlot(ax=ax1)
ra12.TSPlot(ax=ax2)

ax1.set_xlim([32, 36])
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//TS.png]]

#+BEGIN_SRC ipython :session :ipyfile images/KT-seasonal.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.ChipodSeasonalSummary(ax=ax3)
nrl5.ChipodSeasonalSummary(ax=ax1)
ra12.ChipodSeasonalSummary(ax=ax2)

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//KT-seasonal.png]]
* MLD climatology

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907e_A.png
mld = dcpy.oceans.argo_mld_clim()

ax = plt.gca()
for lat in range(0, 22, 2):
    mld.mld_da_mean.sel(lon=90, lat=lat,
                        method='nearest', tolerance=1).plot(ax=ax, label=str(lat))

plt.title('lon=90.5')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907e_A.png]]

* ARGO data : S_min and S_max
[[file:../images//argo-smin-smax.png]]
* code tests
** MLD calc
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgJlnzfg.png
f, ax = plt.subplots(1,3)

it = 35000
ra15.ctd['T'].isel(time=it).plot(ax=ax[0])
dcpy.plots.linex(ra15.ild.isel(time=it), ax=ax[0])

ra15.ctd['S'].isel(time=it).plot(ax=ax[1])
dcpy.plots.linex(ra15.sld.isel(time=it), ax=ax[1])

ra15.ctd['ρ'].isel(time=it).plot(ax=ax[2])
dcpy.plots.linex(ra15.mld.isel(time=it), ax=ax[2])
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

* sampling considerations
** ISO signals
Can I  see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907IKt.png
dt = 1  # day
N = 365  # number of days
smth = [1, 2, 3, 4, 5]  # nsmooth
periods = np.array([10.0, 20.0, 30.0, 50.0, 60.0, 90.0])  # peaks

ax = []
ax.append(plt.subplot(211))
ax.append(plt.subplot(212))

t = np.arange(N)
ts = dcpy.ts.synthetic(N, dt, 1, -3)

for tt in periods:
    ts += 1e3 * np.sin(2*3.14/tt * t)

for ss in smth:
    dcpy.ts.PlotSpectrum(ts, ax=ax[0], scale=5**-ss,
                         nsmooth=ss, label=str(ss))
    dcpy.ts.PlotSpectrum(ts, ax=ax[1], scale=5**-ss,
                         nsmooth=ss, label=str(ss),
                         multitaper=True)

ax[0].set_title('Varying smoothing | ' + str(N) + ' day daily timeseries')
ax[1].set_title('multitaper')
plt.legend()
# dcpy.ts.PlotSpectrum(ts, nsmooth=smth, multitaper=True)
dcpy.plots.linex(1/periods)
#+END_SRC
#+CAPTION: Can I see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+RESULTS:
[[file:../images//temp/img3907IKt.png]]o
** χpod depths for RAMA17

#+name: read-rama-10m
#+BEGIN_SRC ipython :session :results none
import xarray as xr
import pandas as pd

rama10 = xr.open_mfdataset('rama/data/t*90e_10m.cdf', autoclose=True)
salhr = xr.open_mfdataset('rama/data/s[0-9]*90e_hr.cdf', autoclose=True)

newtrange = pd.date_range(start=rama10.time.values.min(),
                          end=rama10.time.values.max(), freq='10min')
#+END_SRC

#+call: read-rama-10m()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427kYC.png
# ra12 = xr.open_dataset('rama/data/t12n90e_10m.cdf', autoclose=True)
T = rama10.T_20.sel(depth=[10, 20, 40, 60])
T = T.reindex({'time': newtrange})
T = T.where(T < 40).squeeze()
Tz = -T.diff(dim='depth')/T.depth.diff(dim='depth')
Tz['depth'] = (T.depth.values[:-1] + T.depth.values[1:])/2
Tz.name = '$T_z$'

S = salhr.S_41.sel(lat=12, depth=[10, 20, 40, 60])
S = S.reindex({'time': pd.date_range(start=S.time.values.min(),
                                     end=S.time.values.max(), freq='1H')})
S = S.where(S < 40).squeeze()
Sz = -S.diff(dim='depth')/S.depth.diff(dim='depth')
Sz.name = '$S_z$'

N2 = -9.81 * (-1.7e-4 * Tz + 7.6e-4 * Sz)
#+END_SRC

#+RESULTS:
[[file:images/temp/img10427kYC.png]]

#+BEGIN_SRC ipython :session :ipyfile images/min-Tz-rama.png
min_Tz = 1e-3

def count(x):
    return (x.where(np.abs(x) < 1e-3).count(dim='time'))/x.count(dim='time')*100

lat = [15, 12, 8, 4, 0]

f, ax = plt.subplots(len(lat), 1, sharex=True, sharey=True)

for (axx, ll) in zip(ax, lat):
    dcpy.plots.offset_line_plot(Tz.sel(lat=ll)
                                .groupby('time.dayofyear')
                                .apply(count),
                                x='dayofyear', y='depth',
                                offset=0, remove_mean=False, ax=axx)
    axx.set_title(str(ll)+'N')

f.suptitle('% observations in a day with $T_z$ < 1e-3', y=1.05)
ax[0].set_ylim([0, 100])

ax[-1].set_xlabel('day of year')

plt.tight_layout()
plt.gcf().set_size_inches((6.5, 6.5))
#+END_SRC
#+CAPTION: How likely is it that we can compute χ for an instrument at 30m vs instrument at 45m
#+RESULTS:
[[file:images/min-Tz-rama.png]]

[[file:images/li-et-al-may-oct-mld.png]]

#+call: read-ra12()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427SMu.png

#+END_SRC

* χ processing
** Winters & D'Asaro methodology
*** Convection
*** determining sign
1. Use mooring dT/dz (10-20m scale)
2. Use sign of hourly moving median (6 points).
3. For |dT/dz| < 1e-3; use sign of two hourly median

[[file:~/work/bay/images/wda-tz-sign.png]]

[[file:~/work/bay/images/wda-tz-sign-2.png]]

*** noise levels
The differentiator uses the /analog/ signal as input; so it never differentaties bit-noise in T. i.e. the noise floor in Tp and T are _different._

~chi_chi_proc~ checks for Tp noise floor.

When doing the WDA estimate, I need to check for the T noise floor when sorting temperature.
*** Use just the sorted gradient or re-evalute with mooring gradient?
[[file:images/wda-Jq-comparison.png]]
** really low turbulence

- instrument is being pumped through what looks like really quiet layers.
- 15 sec period roughly : signal is also seen in pressure time series.

[[file:images/518-low-turbulence.png]]
#+CAPTION: zoom-in of first image
[[file:images/518-low-turbulence-zoom-1.png]]
#+CAPTION: zoom-in of first image
[[file:images/518-low-turbulence-zoom-2.png]]
** 1 sec IC fits
Use 526 2017-07-06 to test: this has kstart, kstop, ki saved for the entire year.

1. I can get ~k_stop~ decently well in ~combine_turbulence~. Not doing that well with ~k_start.~
2. Part of the reason is that I'm not actually getting k_b right which is mystifying.
3. If I can do ~k_start~ I can also check how many points are in fitting range.
   1. Though really, I should redo all calculations :(.

#+CAPTION: Comparing estimated k_b with saved k_b. Why is this wrong?!  This might be because chi, epsilon is recalculated right at the end but the k_b I saved was not.
[[file:images/526-k_b-est-saved.png]]

#+CAPTION: This figure show histograms of ε when k_i > k_{stop}. It compares one where I estimate kstop and other where kstop was saved during iterations.
[[file:images/526-eps-ki-filter-hist.png]]

#+CAPTION: Here I compare ε distributions after when k_i < k_stop (straddling the transition) and k_i < k_start (always in vc range). These use the saved ranges.
[[file:images/526-chi-ki-filtering.png]]
** using pressure instead of accelerometer

Tested with RAMA14-810
#+CAPTION: Δp is quantized! Bit resolution ≈ 2 cm. I smooth over 0.5 seconds.
[[file:images/810-p-velz-a-velz.png]]

#+ATTR_HTML: :width 50%
#+CAPTION: Agrees with Perlin & Moum (2012), though here $dp/dt$ is smaller.
[[file:images/810-compare-spd.png]]
#+CAPTION: mean/median larger by a factor of 2 (only tested for 20-Feb-2015)
[[file:images/810-compare-chi-eps.png]]

#+CAPTION: slope ≈ 1.5 (only tested for 20-Feb-2015)
[[file:images/810-compare-hist2-chi-eps.png]]

bibliography:~/Papers/bibtexLibrary.bib
