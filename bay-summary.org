#+TITLE: Bay of Bengal notes
#+SETUPFILE: ~/org/notebook.org
* Map
#+CAPTION: χpod locations for ASIRI/EBOB/MesoBOB
[[file:../images/MixingmapASIRIPiston.png]]
* Summary
** All χpods
*** RAMA
#+ATTR_HTML: :class full-width
[[file:images/ra12-2014-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/ra12-2015-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/ra15-summary.png]]

*** EBOB

#+ATTR_HTML: :class full-width
[[file:images/nrl1-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/nrl2-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/nrl3-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/nrl4-summary.png]]

#+ATTR_HTML: :class full-width
[[file:images/nrl5-summary.png]]

** vertical distribution of $K_T$
*** Mangle together and change to dataframe
#+CALL: read-all-moorings()
#+NAME: make-KT-dataframe
#+BEGIN_SRC ipython :session :results none
def make_merged_KT(moorings):
    KT = []
    for m in moorings:
        ktsubset = m.KT.copy()

        ktsubset['season'] = ktsubset.time.monsoon.labels
        ktsubset['depth'].values = np.round(ktsubset.z.mean(dim='time'),
                                            decimals=1)

        # if m.name == 'RAMA 12N':
        #     ktsubset['depth'].values += 0.012

        # if m.name == 'RAMA 15N':
        #     ktsubset['depth'].values += 0.015

        # if m.name == 'NRL1':
        #     ktsubset['depth'].values += 0.001

        # if m.name == 'NRL2':
        #     ktsubset['depth'].values += 0.002

        # if m.name == 'NRL3':
        #     ktsubset['depth'].values += 0.003

        # if m.name == 'NRL4':
        #     ktsubset['depth'].values += 0.004

        # if m.name == 'NRL5':
        #     ktsubset['depth'].values += 0.005

        depth_season = np.round(ktsubset.z.groupby(ktsubset['season'])
                                .median(dim='time')).astype('int64')

        # depth_week = np.round(ktsubset.z.groupby(ktsubset.time.dt.weekofyear)
        #                       .mean(dim='time')).astype('int64')

        # depth_bin = depth_week

        # bin depths
        # depth_season.values[np.logical_and(
        #     depth_season.values > 55,
        #     depth_season.values < 63)] = 60

        # depth_season.values[np.logical_and(
        #     depth_season.values >= 64,
        #     depth_season.values < 68)] = 65

        # depth_season.values[np.logical_and(
        #     depth_season.values > 68,
        #     depth_season.values < 82)] = 75

        # depth_season.values[np.logical_and(
        #     depth_season.values > 84.5,
        #     depth_season.values < 87.2)] = 85

        # depth_season.values[depth_season.values > 87.2] = 100

        _, seas = xr.broadcast(ktsubset, ktsubset['season'])

        mean_depth = xr.zeros_like(ktsubset)
        for ss in ['NE', 'NESW', 'SW', 'SWNE']:
            mask = seas.values == ss
            if np.all(mask == False):
                continue
            _, zz = xr.broadcast(seas == ss, depth_season.sel(season=ss))
            mean_depth.values[mask] = zz.values[mask]

        # get a reasonable depth for the subset
        ktsubset['mean_depth'] = mean_depth

        KT.append(ktsubset.reset_coords())

    KTm = xr.merge(KT)
    KTm.to_netcdf('merged_KT.nc', format='netCDF4')
    KTm.resample(time='1H').mean().to_netcdf('merged_KT_hourly.nc')
    KTm.resample(time='6H').mean().to_netcdf('merged_KT_6hourly.nc')

def bin_and_to_dataframe(KTm, ρbins=None, Sbins=None):
    def bin(var, bins):
        binned = bins[np.digitize(var, bins)-1]
        return xr.DataArray(binned, dims=var.dims, coords=var.coords)

    if ρbins is not None:
        KTm['ρbinned'] = bin(KTm.ρ, ρbins)
    if Sbins is not None:
        KTm['Sbinned'] = bin(KTm.S, Sbins)

    if np.all(KTm['KT'].values > 0):
        KTm['KT'].values = np.log10(KTm['KT'].values)

    KTdf = (KTm[['KT', 'ρbinned', 'z', 'season']]
            .to_dataframe()
            .dropna(axis=0, subset=['KT'])
            .reset_index())
    KTdf['latlon'] = (KTdf['lat'].astype('str') + 'N, '
                      + KTdf['lon'].astype('str') + 'E')

    return KTdf

def histedges_equalN(x, nbin):
    # from https://stackoverflow.com/questions/39418380/histogram-with-equal-number-of-points-in-each-bin
    x = x[np.logical_not(np.isnan(x))]
    npt = len(x)
    return np.interp(np.linspace(0, npt, nbin + 1),
                     np.arange(npt),
                     np.sort(x))

# moorings = [ra12, ra15, nrl1, nrl3, nrl4, nrl5]
# make_merged_KT(moorings)
#if 'KTm' in locals():
 #    del KTm

# KTm = xr.open_dataset('merged_KT.nc', autoclose=True)
ρbins = histedges_equalN(np.ravel(KTm.ρ), 11)
Sbins = histedges_equalN(np.ravel(KTm.S), 11)

KTdf = bin_and_to_dataframe(KTm, ρbins)
#+END_SRC

Test out binning so that there are equal number of observations (NaN filtered) in each bin
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgSAH1E0.png :results drawer
KTm.ρ.plot.hist(bins='fd', density=True)
ρbins = histedges_equalN(np.ravel(KTm.ρ), 12)
_ = KTm.ρ.plot.hist(bins=ρbins, density=True, edgecolor='k', facecolor='none')
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/temp/imgSAH1E0.png]]
:END:

#+NAME: argo-clim-density
#+BEGIN_SRC ipython :session :ipyfile images/mean-density-at-moorings.png
import dcpy.oceans
import seawater as sw

latitude = [12, 15, 5, 6.5, 8, 8, 8]
longitude = [90, 90, 85.5, 85.5, 85.5, 87, 88.5]
name = ['RA12', 'RA15', 'NRL1', 'NRL3', 'NRL4', 'NRL5']

_, ax = plt.subplots(1, 3, sharey=True)
if 'argoS' not in locals():
    argoS = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Salinity_2016.nc',
                            decode_times=False, autoclose=True)
    argoT = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Temperature_2016.nc',
                            decode_times=False, autoclose=True)

for (lon, lat, moorname) in zip(longitude, latitude, name):
    S = argoS.ARGO_SALINITY_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    T = argoT.ARGO_TEMPERATURE_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    ρ = sw.pden(S, T, argoS.PRESSURE)

    ax[0].plot(S, argoS.PRESSURE, label=moorname)
    ax[1].plot(T, argoS.PRESSURE, label=moorname)
    ax[2].plot(ρ, argoS.PRESSURE, label=moorname)

plt.ylim([120, 0])
plt.gcf().legend()
dcpy.plots.linex(Sbins, ax=ax[0])
dcpy.plots.linex(ρbins, ax=ax[2])
ax[0].set_ylabel('Pressure')
ax[0].set_xlabel('S')
ax[1].set_xlabel('T')
ax[1].set_xlim([20, 30])
ax[2].set_xlabel('ρ')
plt.gcf().suptitle('Roemmich & Gilson ARGO Climatology')
plt.gcf().set_size_inches((5.5, 2.5))
#+END_SRC
#+CAPTION: Mark density bins on ARGO climatology density profile
#+RESULTS: argo-clim-density
[[file:images/mean-density-at-moorings.png]]

#+NAME: TS-sampled-distribution
#+BEGIN_SRC ipython :session :ipyfile images/TSρ-sampled-by-χpod.png :results drawer
f, ax = plt.subplots(2,1)
sns.violinplot(data=KTdf.dropna(), x="depth", y="ρ", ax=ax[0])
sns.violinplot(data=KTdf.dropna(), x="depth", y="S", ax=ax[1])
# sns.violinplot(data=KTdf.dropna(), x="depth", y="T", ax=ax[2])
plt.gcf().autofmt_xdate()
ρbins2 = [ 1019.45,  1020.43,  1021.05,  1021.68,
           1022.49,  1022.94,  1023.49,  1026.27]
dcpy.plots.liney(ρbins, ax=ax[0])
dcpy.plots.liney(Sbins, ax=ax[1])
plt.gcf().set_size_inches((8.5, 7.5))
plt.tight_layout()
#+END_SRC
#+RESULTS: TS-sampled-distribution
:RESULTS:
[[file:images/TSρ-sampled-by-χpod.png]]
:END:

#+NAME: kmeans
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgiZJc38.png
data = KTdf.ρ
# centroids, _ = sp.cluster.vq.kmeans(data, 10)
# idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(10):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1])

#+END_SRC
#+RESULTS: kmeans
[[file:images/temp/imgiZJc38.png]]


#+NAME: TS-plot
#+BEGIN_SRC ipython :session :ipyfile images/rho-bins-TS-plot.png :results drawer
T, S, binned= dcpy.util.BinEqualizeHist([KTdf['T'], KTdf['S']], bins=[200, 100])
Tg, Sg = np.meshgrid(T, S, indexing='ij')
ρg = sw.pden(Sg, Tg, 50)
# plt.plot(KTdf['S'], KTdf['T'], '.')
plt.pcolormesh(S, T, binned.T, cmap=mpl.cm.Reds)
# hc = plt.contour(Sg, Tg, ρg, colors='k', levels=ρbins)
# plt.clabel(hc, fmt='%1.1f')
plt.xlabel('S')
plt.ylabel('T')

kmeans = 12

data = KTdf.ρ
centroids, _ = sp.cluster.vq.kmeans(data, kmeans)
idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(kmeans):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1], 'k--')

cent = np.sort(centroids)
newbins = np.hstack([KTdf.ρ.min(), (cent[:-1]+cent[1:])/2])
hc = plt.contour(Sg, Tg, ρg, colors='k', levels=newbins, zorder=10)
plt.clabel(hc, fmt='%1.1f')

#+END_SRC
#+RESULTS: TS-plot
:RESULTS:
: <a list of 12 text.Text objects>
[[file:images/rho-bins-TS-plot.png]]
:END:

*** Make plot
**** means/medians profile
#+NAME: define-vert_distrib
#+BEGIN_SRC ipython :session :results none
def vert_distrib(KTdf, bins, varname='KT', pal=None, f=None, ax=None,
                 ,**kwargs):

    base_marker_size = 5
    pal_dist = sns.color_palette("GnBu_d", n_colors=13)
    pal_dist.reverse()

    if pal is None:
        pal = pal_dist

    if f is None:
        f, axx = plt.subplots(1, 4, sharex=True, sharey=True)
        ax = {'NE': axx[0], 'NESW': axx[1], 'SW': axx[2], 'SWNE': axx[3]}

    if varname is 'KT':
        title = 'Hourly averaged $K_T$'
        xlim = kwargs.pop('xlim', [-7,0])
        xlines = kwargs.pop('xlines', [-5, -4])
    else:
        title = varname
        xlim = kwargs.pop('xlim', None)
        xlines = kwargs.pop('xlines', [])

    months = {'NE': 'Dec-Feb', 'NESW': 'Mar-May',
              'SW': 'Jun-Sep', 'SWNE': 'Oct-Nov'}
    for seas in ax:
        aa = ax[seas]
        from cycler import cycler
        aa.set_prop_cycle(cycler('color', pal))
        aa.set_title(seas + '\n(' + months[seas] +')')
        if xlim is not None:
            aa.set_xlim(xlim)
            aa.set_xticks(range(*xlim))

    # seaborn treats things as categoricals booo...
    # do things the verbose matplotlib way
    for index, (label, df) in enumerate(KTdf.groupby([bins, 'season'])):
        interval = label[0]
        season = label[1]
        zloc = sp.stats.trim_mean(df.z, 0.01)

        if interval.mid > 1000:
            bin_name = interval.mid-1000
            if bin_name < 20:
                if season == 'SW':
                    zloc -= 5
                elif season == 'NE' or season == 'SWNE':
                    zloc -= 2.5

            if (bin_name < 21 and bin_name > 20.8):
                if season == 'SWNE':
                    zloc +=2.5

            if (bin_name > 21.1 and bin_name < 21.6):
                if season == 'NE':
                    zloc += 5

            if (bin_name > 23.7 and bin_name < 25):
                if season == 'NESW' or season == 'SW':
                    zloc += 5

            if (bin_name > 25) and season == 'SW':
                    zloc += 5

        else:
            bin_name = interval.mid

        var = df[varname]
        hdl = ax[season].violinplot(var, positions=[zloc],
                                    widths=[12],
                                    vert=False, showmedians=False)
        color = hdl['bodies'][0].get_facecolor()[0][:-1]

        if np.all(var < 1):
            # if in log-space transform out and back
            median = np.log10(np.nanmedian(10**var))
            mean = np.log10(np.nanmean(10**var))
        else:
            median = np.nanmedian(var)
            mean = np.nanmean(var)

        ax[season].plot(median, zloc, 'o',
                        color=color, zorder=12, ms=base_marker_size)
        ax[season].plot(median, zloc, 'o',
                        color='w', zorder=11, ms=base_marker_size+2)
        ax[season].plot(mean, zloc, 'x',
                        color=color, zorder=12, ms=base_marker_size-1)

        xtxt = hdl['cbars'].get_paths()[0].vertices[1, 0]
        ytxt = zloc

        ax[season].text(xtxt, ytxt, '     '+np.round(bin_name, 1).astype('str'),
                        color=color, ha='left', va='center', fontsize=7)

        # halve the voilin
        for b in hdl['bodies']:
            m = np.mean(b.get_paths()[0].vertices[:, 1])
            b.get_paths()[0].vertices[:, 1] = np.clip(b.get_paths()[0].vertices[:, 1],
                                                      -np.inf, m)

        # min K_T is useless.
        hdl['cmaxes'].set_visible(False)
        hdl['cmins'].get_paths()[0].vertices[:, 1] = (zloc +
                                                       np.array([-1,1])*df.z.std())

    ax['NE'].set_ylabel('depth (m)')
    ax[season].set_ylim([125, 0])
    ax[season].set_yticks(np.arange(120,0,-10))
    ax[season].set_yticklabels(np.arange(120,0,-10).astype('str'))

    for aa in ax.values():
        for xx in xlines:
            aa.axvline(xx, lw=0.5, ls='dotted', zorder=-50, color='gray')

    f.set_size_inches((8.5, 5.5))
    f.suptitle(title, y=0.03, va='baseline')
    plt.subplots_adjust(wspace=0.25)

    return f, ax
#+END_SRC

#+NAME: vert-profile
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-profile.png :results drawer
<<define-vert_distrib>>
if 'KTm' not in locals():
    KTm = xr.open_dataset('merged_KT_hourly.nc').load()
    if np.all(KTm['KT'].values[np.logical_not(KTm.KT.isnull().values)] > 0):
        KTm['KT'].values = np.log10(KTm['KT'].values)

    KTm['season'] = KTm.time.monsoon.labels
    KTdf = (KTm[['KT', 'T', 'S', 'z', 'ρ', 'season']]
            .to_dataframe()
            .dropna(axis=0, subset=['KT'])
            .reset_index())
    KTdf['latlon'] = (KTdf['lat'].astype('str') + 'N, '
                      + KTdf['lon'].astype('str') + 'E')

# KTdf = KTdf.set_index(['season'])
# KTdf = KTdf.assign(
#     median_z=KTdf.groupby([bins, 'season']).transform('median')['z'])
# KTdf = KTdf.assign(
#     median_KT=KTdf.groupby([bins, 'season']).transform('median')['KT'])

bins = pd.qcut(KTdf.ρ, 11)
bins = pd.cut(KTdf.ρ, ρbins)

f, ax = vert_distrib(KTdf, bins)
plt.savefig('images/vert-profile.svg', bbox_inches='tight')
#+END_SRC
#+RESULTS: vert-profile
:RESULTS:
[[file:images/bay-KT-vert-profile.png]]
:END:

#+NAME: sal-distrib
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgbp6rfN.png :results drawer
<<define-vert_distrib>>

Sbins = pd.qcut(KTdf.S, 11)

f, ax = plot_distrib(KTdf, bins, varname='S', xlines=[32, 35])
# plot_distrib(KTdf.where(KTdf.S > 34.9), bins, pal=[[0.5,0.5,0.5]]*13, f=f, ax=ax)
#+END_SRC
#+RESULTS: sal-distrib
:RESULTS:
[[file:images/temp/imgbp6rfN.png]]
:END:

**** full distrib OLD
#+NAME: define-seaborn_vert_distrib
#+BEGIN_SRC ipython :session :results none
pal_dist = sns.color_palette("GnBu_d", n_colors=13)
pal_dist.reverse()

def seaborn_vert_distrib(KTdf, category, kind='kde'):
    stylekwargs = dict(style="ticks",
                       rc={'axes.facecolor': 'None',
                           'figure.facecolor': 'None'})
    bandwidth = 'scott'
    # pal_dist=sns.cubehelix_palette(11, rot=-.25, light=.7)
    # pal_dist = [pal_dist[0]]*13

    pal_boxplot = sns.color_palette("muted",
                                    n_colors=len(KTdf['latlon'].unique()))
    pal_boxplot[1] = (0,0,0)
    pal_boxdict = dict(zip(KTdf['latlon'].unique(), pal_boxplot))

    # pal = sns.cubehelix_palette(11, rot=-.25, light=0.7)

    def label(x, color, label):
        def stat_label(name, x, fmt, suffix=''):
            q75, q25 = np.percentile(x, [75, 25])
            return ((name+': {0:'+fmt+'}'+suffix
                     +', {1:'+fmt+'}'+suffix
                     +', {2:'+fmt+'}'+suffix)
                    .format(q25, x.mean(), q75))

        extract = KTdf.take(x.index)
        ax = plt.gca()
        label = float(label)
        if category == 'ρbinned':
            lab = (stat_label('S', extract.S, '.1f') + '\n'
                   + stat_label('z', extract.z, '.0f', 'm') + '\n'
                   +'σ: {0:2.1f}kg/m³'.format(label-1000))
        elif category == 'Sbinned':
            lab = '{0:2.1f}'.format(label)
        elif category == 'mean_depth':
            lab = '{0:.0f}m'.format(label)

        ax.text(1, 0.05, lab,
                color=(sns.light_palette((210, 90, 20), input="husl"))[3],
                fontsize=8,
                ha="right", va="bottom", transform=ax.transAxes)

    def mark_distributions_by_location(x, color, label):
        ax = plt.gca().twinx()
        gby = KTdf.take(x.index).groupby('latlon');

        for index, (name, grp) in enumerate(gby):
            props = {'linewidth': 1, 'color': pal_boxdict[name]}
            ax.boxplot(grp['KT'], vert=False, sym='', widths=0.08,
                       showbox=False,
                       showmeans=False, positions=[0.2+0.1*index],
                       boxprops={**props}, whiskerprops={**props},
                       medianprops={**props}, capprops={**props})

        ax.set_ylim([0, 2])
        ax.set_yticks([])

        # with sns.axes_style(**stylekwargs):
        #     sns.boxplot(data=KTdf.take(x.index), x='KT', hue='latlon',
        #                 ax=ax, orient='h', width=0.1)

    def mark_mean_mdn(x, color, label):
        ax = plt.gca()

        mean = np.log10(np.nanmean(10**x))
        median = np.log10(np.nanmedian(10**x))
        yloc = 0.5
        plt.plot(mean, yloc, color=color, marker='x')
        # plt.plot(mean, yloc, color='w', marker='x', fillstyle='none')
        plt.plot(median, yloc, color=color, marker='o', ms=10)
        plt.plot(median, yloc, color='w', marker='o', ms=11, fillstyle='none')

    with sns.axes_style(**stylekwargs):
        g = sns.FacetGrid(KTdf, row=category, col="season",
                          col_order=['NE', 'NESW', 'SW', 'SWNE'],
                          hue=category, xlim=[-7, 0],
                          sharex=True, sharey=True, palette=pal_dist,
                          aspect=4, size=1)


        kdekwargs = {'clip': [-8, 0],
                     'clip_on': False,
                     'cut': 0,
                     'bw': bandwidth}

        distkwargs = {'bins': 50, 'hist':True, 'rug':False, 'norm_hist':True,
                      'kde':False, 'kde_kws':{'lw': 1, **kdekwargs}}
        if kind == 'kde':
            g.map(sns.kdeplot, "KT", shade=True, alpha=0.6, lw=1.5, **kdekwargs)
            g.map(sns.kdeplot, "KT", color="w", lw=2, **kdekwargs)

        elif kind == 'dist':
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'alpha': 1})
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'histtype': 'step', 'color': 'w',
                            'lw': 1, 'alpha': 1})

        g.map(plt.axhline, y=0, lw=2, clip_on=False)

        g.map(label, "KT")
        g.map(mark_mean_mdn, "KT")
#        g.map(mark_distributions_by_location, "KT")
        g.fig.subplots_adjust(hspace=-0.58)
        g.set_xlabels('$K_T$')
        g.set_titles('')
        g.set(yticks=[], ylim=[0, 2])
        _ = g.despine(left=True)

        g.axes[1,0].set_title('NE\n(Dec-Mar)')
        g.axes[1,1].set_title('NE → SW\n(Apr-May)')
        g.axes[1,2].set_title('SW\n(Jun-Sep)')
        g.axes[1,3].set_title('SW → NE\n(Oct-Nov)')

        for index, tt in enumerate(KTdf['latlon'].unique()):
            plt.gcf().text(0.98,0.97-index*0.015, tt,
                           color=pal_boxplot[index],
                           ha='right', va='top')
            plt.suptitle('Columns are seasons, rows are density bins', y=0.95)

        return g

#+END_SRC

#+CALL: make-KT-dataframe()
#+NAME: KT-vert-hist
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist.png :results drawer
<<define-seaborn_vert_distrib>>

g = seaborn_vert_distrib(KTdf, "ρbinned", 'dist')
#+END_SRC
#+RESULTS: KT-vert-hist
:RESULTS:
[[file:images/bay-KT-vert-hist.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist-depths.png
<<define-seaborn_vert_distrib>>
seaborn_vert_distrib(KTdf, 'mean_depth', 'kde')
#+END_SRC

#+RESULTS:
: <seaborn.axisgrid.FacetGrid at 0x7f1a3c885dd8>
[[file:images/bay-KT-vert-hist-depths.png]]
** Surface fluxes

#+CALL: read-tropflux()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img7tMMDR.png
# sst = ra12.ctd['T'].sel(depth=1).groupby('time.month').mean(dim='time')

timebase = 'weekofyear'

tfsel = tropflux.sel(longitude=90, latitude=12, method='nearest')
tf = (tfsel.groupby('time.'+timebase)
      .mean(dim='time'))

jq0 = tf.netflux

if 'mldclim' not in locals():
   mldclim = dcpy.oceans.argo_mld_clim()

mld = mldclim.mld_da_mean.sel(lon=90, lat=12, method='nearest')

if timebase == 'weekofyear':
   ihi = np.interp(np.linspace(1,13, 53), mld.month,
                   0.45 * tfsel.swr.groupby('time.month').mean(dim='time')
                   ,* np.exp(-0.04 * mld))
   Ih = xr.DataArray(ihi, dims=[timebase],
                     coords=[jq0[timebase]], name='Ih')
else:
   Ih = 0.45*tfsel.swr.groupby('time.month').mean(dim='time')

f, ax = plt.subplots(2,1)
hsst = tf.sst.plot(ax=ax[0],color='k')
ax0 = ax[0]
ax1 = ax0.twinx()
hjq0 = ax1.fill_between(jq0[timebase], jq0-Ih, color='salmon')
ax1.set_zorder(-10)
ax1.axhline(0, color='k')
# hIh = Ih.plot.line('k--', ax=ax1)

ax0.set_title(''); ax1.set_title('');

_ = f.legend((hsst[0], hjq0),
           ('SST', 'Jq0-Ih'),
           loc='upper center')

jq14 = ra12.Jq.sel(time='2014').groupby('time.'+timebase).mean(dim='time')
jq15 = ra12.Jq.sel(time='2015').groupby('time.'+timebase).mean(dim='time')
jqt = (jq14.fillna(0) + jq15.fillna(0))/2
jqt.plot.line(ax=ax1)

_ = (mld*-1).plot(ax=ax[1])
args = {'color': 'k', 'ls': '--'}
ax[1].axhline(-15, **args)
ax[1].axhline(-30, **args)
ax[1].axhline(-45, **args)
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img7tMMDR.png]]
** Seasonal patterns
*** "pycnocline uplift"
It is quite hard to see if there is a semi-regular period.

This could be the large-scale ∇S being advected back and forth across the mooring.
1. At 12N, it happens in Jul-2014, Jul-2015
[[file:images/12n-sal.png]]

[[file:images/15n-sal.png]]

#+RESULTS:
[[file:images/temp/img3907Zeq.png]]

*** K_T variations
#+CAPTION: Distribution of 5 minute averages of K_T.
#+RESULTS:
[[file:../images//rama12n-kt-boxplot.png]]

** MISO signals?
*** Summary
cite:Sobel2010 show large TRMM 30-90 day variance between May and October in the Bay.
[[file:../images//sobel-trmm-variance.png]]

#+CAPTION: Subsurface anomalies line up with northward propagating features in SST, LWR.
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]

#+CAPTION: Southward propagating signals in 2011-Nov/Dec!
#+RESULTS:
[[file:images/bandpass-90e-2011.png]]

**** old :noexport:
I see northward propagating "anomalies" in Tropflux SWR.
[[file:images/90e-swr-anom.png]]
*** in mixing
**** RAMA 12N
***** Coherence
- Note sure coherence is the way to do this given short records

The next figure shows coherence between Jq0 and  Jqt at 15m, 30m at the RAMA 12N mooring for the year 2014. Signs for all fluxes are such that +ve warms the surface.
Looks like we have significant coherence in the 20-60day band between daily averaged Jq0 and Jqt at 15m.
The 180 phase difference looks stable, is apparent in the filtered time series and seems to make physical sense (more surface heating → increases T_z → reduces J_q^t and vice versa).

Nothing at 30m
 - short(er) data record - instrument dies in september
 - not much temp fluctuations at that depth while the instrument was alive (see above).

#+CAPTION: (Top left) Band-passed time series. (bottom left) PSD for the unfiltered time series. (Right) coherence amplitude and phase between J_q^0 and J_q^t at both depths. Significance level marked by horizontal line. Pass band marked by vertical lines.
file:rama/images/ra12-jq0-jqt-coherence.png
*** temp / salinity record
**** Stratification T_z
Filtered T_z?
#+BEGIN_SRC ipython :session :ipyfile images/ra12n-bandpass-strat.png
from dcpy.plots import offset_line_plot
f, ax = plt.subplots(4, 1, sharex=True)

trange = slice('2014-06', '2014-08')
T = rama.SelectVar('T', dict(lon=90))
Tz = (T.sel(lat=12)
      .dropna(dim='depth', how='all')
      .drop(-13, dim='depth')
      .diff(dim='depth'))
Tz /= Tz.sel(time=trange).std(dim='time')
Tzbp = (Tz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Tzbp /= Tzbp.sel(time=trange).std(dim='time')

S = rama.SelectVar('S', dict(lon=90))
Sz = (S.sel(lat=12)
      .dropna(dim='depth', how='all')
      .diff(dim='depth'))
Sz /= Sz.sel(time=trange).std(dim='time')
Szbp = (Sz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Szbp /= Szbp.sel(time=trange).std(dim='time')

dcpy.plots.offset_line_plot(
    Tz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[0])

dcpy.plots.offset_line_plot(
    Tzbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[1])

dcpy.plots.offset_line_plot(
    Sz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[2])

dcpy.plots.offset_line_plot(
    Szbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[3])

ax[0].set_ylabel('$ΔT$')
ax[1].set_ylabel('$ΔT$\'')
ax[2].set_ylabel('$ΔS$')
ax[3].set_ylabel('$ΔS$\'')

dcpy.plots.liney(0, ax=ax[0])
dcpy.plots.liney(0, ax=ax[1])

plt.suptitle('10-80 day bandpass filtered at χpod depths / normalized by std.', y=1.0)
plt.tight_layout()
plt.gcf().autofmt_xdate()
#+END_SRC

#+RESULTS:
[[file:images/ra12n-bandpass-strat.png]]
**** Subsurface MISO signals?
What am I looking for?
1. northward propagation of MISO signal
2. subsurface MISO signals in 30d-90d band

#+BEGIN_SRC ipython :session :ipyfile images/temp/asd02j.png :noweb yes
if 'rama' not in locals():
     print('reading rama')
     <<read-rama-array>>

flen = np.array([10.0, 80.0])
hdl, var = rama.hov('T', region=dict(lon=90, depth=[-1, -10, -20]),
                    row='depth', filt='bandpass',
                    filter_len=flen*86400)

plt.gcf().set_size_inches((8.5, 2.5))
plt.gca().set_xlim(['2011-01-01', '2013-07-01'])
plt.gcf().autofmt_xdate()
# plt.gcf().suptitle('bandpass ' + str(flen) + 'days')
#+END_SRC
#+CAPTION: Hovmöller plot of RAMA 90E data | Bandpassed 10, 80 days. Looks like _southward_ propagation in Nov/Dec 2011.
#+RESULTS:
[[file:images/temp/asd02j.png]]
#+BEGIN_SRC ipython :session :ipyfile images/rama-iso-T-std.png :noweb yes
if 'rama' not in locals():
    <<read-rama-array>>

from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

Tfilt = BandPassButter(rama.T.where(rama.T < 40), freqs=freqs, dim='time')

MayToOct = np.logical_and(Tfilt.time.dt.month >=5,
                          Tfilt.time.dt.month <= 10)

def plot_temp_std_along_lon(Tfilt, inmask, lon):
    f, ax = plt.subplots(2, 2, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx], cmap=mpl.cm.Reds))

        # normalize at each lat,lon by maximum in depth
        Tnorm = Tstd / Tstd.max(dim='depth')
        Tnorm.name = 'normalized to \n show structure'
        (Tnorm.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx+2], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_along_lon(Tfilt, MayToOct, lon=90)
#+END_SRC
#+CAPTION: Lon = 90: Max 30-90 day std dev is within 5S-5N as expected from Han (2005). Seems independent of season. Subsurface peak = thermocline? Agrees with Girishkumar et al (2013)
#+RESULTS:
[[file:images/rama-iso-T-std.png]]

#+BEGIN_SRC ipython :session :ipyfile images/iso-T-std-lat-lon-map.png
def plot_temp_std_lat_lon(Tfilt, inmask):
    ''' Takes max. std along depth and plots in (lon, lat) space'''
    f, ax = plt.subplots(2, 1, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.dropna(dim='depth', how='all')
             .dropna(dim='lat', how='all')
             .max(dim=['depth']).transpose()
             .plot(ax=ax[idx], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_lat_lon(Tfilt, MayToOct)
#+END_SRC
#+CAPTION: Taking max(std) along depth → (lon, lat) map. Some sign of near-equatorial maxima.
#+RESULTS:
[[file:images/iso-T-std-lat-lon-map.png]]


#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907n9q.png
from dcpy.ts import apply_along_dim_1d

freqs = [1/30.0, 1/60.0]

T = rama.T.copy()

T.values[T.values > 40] = np.nan

apply_along_dim_1d(T, 'time', dcpy.ts.FillGaps, x=T.time, maxlen=20)

bp = (BandPassButter(T.sel(lon=90, lat=[15, 12, 8])
                     .dropna(dim='time', how='all'),
                     freqs=freqs, dim=['time'])
      .dropna(dim='depth', how='all'))

bp.plot.contourf(row='lat', x='time', levels=40)
plt.gcf().set_size_inches((8.5, 4.5))
plt.gca().set_ylim([-140, 0])
# plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img3907n9q.png]]

#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img9554Dcu.png
from dcpy.plots import offset_line_plot

T = rama.SelectVar('T', dict(lon=90.0))

T = T.groupby('time.month') - T.groupby('time.month').mean(dim='time')
Tclim = T.groupby('time.dayofyear').mean(dim='time')
Tanom = T.groupby('time.dayofyear') - Tclim


offset_line_plot(T.sel(depth=-1)
           .dropna(dim='time', how='all'),
          x='time', y='lat')
plt.gca().set_xlim('2011', '2014')

# Tanom.sel(depth=-1).plot()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC

#+RESULTS:
[[file:images/temp/img9554Dcu.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-90e-2014.png :noweb yes
freqs = [1/10.0, 1/80.0]
time = '2015'

<<bandpass-mosaic>>
#+END_SRC
#+CAPTION: Southward propagating signals in 2011-Nov/Dec, but not so much in 2014?
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]
**** Spectra
#+call: read-mur()

#+NAME: calc-spec
#+BEGIN_SRC ipython :session :results none
import xarray as xr
from dcpy.ts import SpectralDensity

var = rama.SelectVar('T', region=dict(lon=90, lat=12)).dropna(dim='depth', how='all')

iz = var.get_axis_num('depth')

spec = []
for zz in range(var.shape[iz]):
    S, f, conf = SpectralDensity(var.isel(depth=zz), dt=1,
                                 multitaper=False, nsmooth=2,
                                 fillgaps=True, maxlen=60)
    # create a DataArray
    spec.append(xr.DataArray(S, coords=[f], dims=['freq'],
                             attrs={'depth': var.depth.values[zz]},
                             name='PSD'))
#+END_SRC

:code-notes:
1. Let's try FFT - yes, using ~apply()~ works like doing things manually. +But results look weird+ xarray isn't respecting missing_value; haven't figured out why :(

2. bah gaps are non-uniform at all depths. can't do the groupby-apply thing. lets make a list of DataArrays and iterate over them when we plot.

3. xarray line-plots are only for 1D data.

:END:
#+CALL: calc-spec()
#+BEGIN_SRC ipython :session :ipyfile images/12n-spectra.png :exports results
if 'mur' in locals():
    S, f, conf = dcpy.ts.SpectralDensity(mur['sst'].sel(lon=90, lat=12), multitaper=True)
    plt.loglog(f, S*10**1.25, label='SST', lw=0.5)

for si, ss in enumerate(spec[0:8]):
    (ss*10**-si**1.15).plot(label=str(ss.depth), lw=0.5)

plt.title('12N 90E')
ax = plt.gca()
ax.set_xscale('log')
ax.set_yscale('log')
ax.legend()
plt.gcf().set_size_inches(8.5, 5.5)
plt.xlim([10**-3.5, 1])
#+END_SRC

#+RESULTS:
[[file:../images/12n-spectra.png]]

**** spectra old :noexport:
#+BEGIN_SRC ipython :session :ipyfile images/temp/img16594-DQ.png
data = rama.SelectVar('T', region=dict(lon=90, lat=12, depth=10))

S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=True)
plt.loglog(f, S)
S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=False)
plt.loglog(f, S)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img16594-DQ.png]]

#+BEGIN_SRC ipython :session
%matplotlib inline

import moor.moor as moor
import chipy.chipy as chipy

moor = importlib.reload(moor)
chipy = importlib.reload(chipy)

import os
if 'rama' not in os.getcwd():
    os.chdir('/home/deepak/rama/scripts/')

ra12 = moor.moor(90, 12, 'RAMA 12N', '../RAMA13/')
# ra12.AddChipod(526, 15, 'mm', '2017-07-10.mat')
# ra12.AddChipod(527, 30, 'mm', '2017-07-10.mat')
ra12.ReadMet('../RAMA13/rama_mooring_data/', WindType='pmel')
# ra12.ReadCTD('../RamaPrelimProcessed/RAMA13.mat', 'ramaprelim')
ra12.ReadCTD('../data/', 'rama')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :session :ipyfile images/temp/py28335Frc.png
dcpy.ts = importlib.reload(dcpy.ts)
dcpy.oceans = importlib.reload(dcpy.oceans)
dcpy.plots = importlib.reload(dcpy.plots)

freqs = [1/(2*np.pi/dcpy.oceans.inertial(ra12.lat)/86400),
         dcpy.ts.AliasFreq(1/(12.42/24), 1),
         1/30, 1/90]

nsmooth = 4
subset = None
mtflag = True

plt.figure(figsize=(6.5, 10.5))
ax0 = plt.subplot(211)
dcpy.ts.PlotSpectrum(ra12.ctd.Tlong, SubsetLength=subset, ax=ax0,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
ax0.set_ylabel('PSD (T)')
if mtflag:
    ax0.set_title('Multitaper')

dcpy.plots.linex(freqs)
ax1 = plt.subplot(212, sharex=ax0)
dcpy.ts.PlotSpectrum(ra12.ctd.Slong, SubsetLength=subset, ax=ax1,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
dcpy.plots.linex(freqs)
ax1.set_ylabel('PSD (S)')
ax1.set_xlabel('Freq (cpd)')

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//temp/py28335Frc.png]]

*** winds at EBOB and rama
#+BEGIN_SRC ipython :session :ipyfile images/bob-winds.png
from scipy.interpolate import interpn

tau = nc.MFDataset('../tropflux/tau_tropflux*')
flx = nc.MFDataset('../tropflux/netflux_tropflux*')

ttime = tau['time'][:]
ftime = flx['time'][:]

ax = [1, 1, 1, 1]
ax[0] = plt.subplot(4, 1, 1)
ax[0].set_title('RAMA')
ax[1] = plt.subplot(4, 1, 2, sharex=ax[0])
ax[1].set_title('EBOB')
ax[2] = plt.subplot(4, 1, 3, sharex=ax[0])
ax[2].set_title('RAMA')
ax[3] = plt.subplot(4, 1, 4, sharex=ax[0])
ax[3].set_title('EBOB')

for latm, lonm in zip([12, 18, 5.5, 8],
                     [90, 90, 85.5, 88.5]):

    if latm < 12:
        ind = 1
    else:
        ind = 0

    label = str(latm) + 'N, ' + str(lonm) + 'E'
    τtrop = interpn((ttime,
                     tau['latitude'][:],
                     tau['longitude'][:]),
                    tau['tau'][:, :, :],
                    (ttime, latm, lonm))
    ftrop = interpn((ttime,
                     flx['latitude'][:],
                     flx['longitude'][:]),
                    flx['netflux'][:, :, :],
                    (ttime, latm, lonm))
    ttrop = ttime \
            + dt.date2num(dt.datetime.date(1950, 1, 1))

    ax[ind].plot(ttrop, τtrop, label=label)
    ax[ind+2].plot(ttrop, ftrop, label=label)

for ind in [0,1]:
    ax[ind].xaxis_date()
    ax[ind].legend()
    ax[ind].set_ylim([0, 0.4])
    ax[ind].set_ylabel('τ (N/m²)')
    ax[ind+2].set_ylabel('flux (W/m²)')

ax[0].set_xlim([dt.datetime.datetime(2013, 11, 29, 0, 0, 0),
                dt.datetime.datetime(2015, 1, 1, 0, 0, 0)])
ax[2].axhline(0, color='gray')
ax[3].axhline(0, color='gray')
plt.gcf().autofmt_xdate()
plt.tight_layout()
#+END_SRC
#+RESULTS:
[[file:../images//bob-winds.png]]
*** in SWR
Look at anomalies:
1. Subtract yearly average.
2. Subtract daily climatology (2001-2017)

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-anom.png :noweb yes
if 'swr' not in locals():
    <<read-tropflux-swr>>
swr['swr'].load()

grpstr = 'time.dayofyear'

# pick location
sw = swr['swr'].sel(longitude=90.5, latitude=slice(0.5, 22.5))
# remove yearly average
swa = (sw.groupby('time.year')
       - sw.groupby('time.year').mean(dim='time'))
# make daily climatology
clim = sw.groupby(grpstr).mean(dim='time')
# get daily anomalies
anom = sw.groupby(grpstr) - clim

f, ax = plt.subplots(3, 1, sharey=True)

(anom.sel(time=slice('2014-05', '2014-09'))
     .plot(x='time', y='latitude', ax=ax[0]))
(anom.sel(time=slice('2015-05', '2015-09'))
     .plot(x='time', y='latitude', ax=ax[1]))

(anom.sel(time=slice('2013', '2016'))
     .groupby('time.dayofyear')
     .mean(dim='time')
     .plot(x='dayofyear', y='latitude', ax=ax[2]))
ax[2].set_title('anomalies averaged over 2013-2016')

ax[0].set_xlabel('')
ax[1].set_xlabel('')
ax[1].set_title('')

plt.tight_layout()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC
#+CAPTION: Shortwave radiation anomalies w.r.t daily climatology [2001-2017]. Definitely see northward propagating anomalies along 90°E. Propagation is most evident for lat > 8°N. Winter is quite for lat > 10.
#+RESULTS:
[[file:images/90e-swr-anom.png]]

Let's try 10-80day filter like cite:Sengupta2001a
#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SWR.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

if 'swr' not in locals():
    swr = xr.open_mfdataset('../datasets/tropflux/swr*.nc', autoclose=True)

swr['swr'].load()

bp = (
    swr['swr'].sel(longitude=[85, 90], method='nearest')
    .pipe(BandPassButter, freqs, dt=1, dim='time')
)

bp.sel(time='2014').plot(x='time', row='longitude')

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC
#+CAPTION: bandpass filter yields same results as above (slightly smoother).
#+RESULTS:
[[file:images/bandpass-SWR.png]]

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-spec.png
dcpy.ts.PlotSpectrum(swr['swr'].sel(latitude=[15, 12, 8], longitude=90, method='nearest'), multitaper=True, nsmooth=5, scale=5)
dcpy.plots.linex([1/10.0, 1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0, 1/120, 1/180, 1/360])
plt.title('Tropflux SWR spectra along 90E')
plt.legend(('15N', '12N', '8N'))
#+END_SRC
#+CAPTION: Spectra of SW radiation along 90°E. Seasonal cycle harmonics are very evident 360, 180, 90, 45. 120-day peak at 8N, 12N.
#+RESULTS:
[[file:images/90e-swr-spec.png]]

*** SST analysis
**** test snapshot
#+CALL: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907o-U.png
mur['sst'].isel(time=1).plot()
#+END_SRC
#+CAPTION: Test snapshot
#+RESULTS:
[[file:../images//temp/img3907o-U.png]]
**** spec
#+call: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/mur-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

# psd = xrft.power_spectrum(mur['sst'].sel(lon=90, lat=12), dim=['time'], density=True, window=True, detrend='constant')
scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = mur.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('MUR SST spectra along RAMA line')
plt.legend()
#+END_SRC
#+CAPTION: MUR SST spectra 2013-2016
#+RESULTS:
[[file:images/mur-spectra-RAMA-line.png]]


#+BEGIN_SRC ipython :session :ipyfile images/cmc-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = cmc.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('CMC SST spectra along RAMA line (2007-2017)')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:images/cmc-spectra-RAMA-line.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SST.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]


(cmc['sst'].sel(lon=[85, 90], method='nearest')
           .where(cmc.mask == 1)
           .pipe(BandPassButter, freqs, dt=1, dim='time')
           .sel(time='2014')
           .plot(x='time', row='lon'))

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC

#+RESULTS:
[[file:images/bandpass-SST.png]]
**** SST variance map
#+BEGIN_SRC ipython :session :results none
freqs = [1/30.0, 1/90.0]

bp = dcpy.ts.BandPassButter(sst, freqs=freqs, dim=['time'])
bp = bp.dropna(dim='time', how='all')

# dcpy.ts.PlotSpectrum(mur['sst'].sel(lon=90, lat=12))
# dcpy.plots.linex(freqs)
# dcpy.ts.PlotSpectrum(bp.sel(lon=90, lat=12))
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907dce.png]]
#+BEGIN_SRC ipython :session :results none
import matplotlib.animation

def animate(i):
    import matplotlib.pyplot as plt
    plt.clf()
    hdl = bp.isel(time=i).plot()
    return hdl

anim = mpl.animation.FuncAnimation(plt.gcf(), animate)

anim.save('sst-iso.mp4', fps=5)
#+END_SRC
** vel spectra

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907nzu.png
u = rama.SelectVar('u', region=dict(lon=90, lat=12))
v = rama.SelectVar('v', region=dict(lon=90, lat=12))
KE = 0.5*np.hypot(u,v)

dcpy.ts.PlotSpectrum(KE)
dcpy.ts.PlotSpectrum(KE, multitaper=True)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907nzu.png]]


#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907fRQ.png
np.sqrt(N2).plot()
plt.ylabel('N (1/s)')
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907fRQ.png]]

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907mHE.png
KE = np.hypot(ra12.vel.u, ra12.vel.v)*2

dcpy.ts.PlotSpectrum(KE, dt=30*60.0, multitaper=False, label='KE 10m')

# figure out N²
woa = dcpy.oceans.ReadWoa(lon=90, lat=12, return_xr=True)
N2, _, pn2 = sw.bfrq(woa['S'], woa['T'], woa['depth'], lat=12)

N2 = xr.DataArray(np.squeeze(N2), coords=[np.squeeze(pn2)], dims=['depth'])
N = np.sqrt(N2)
omg, K_omg, P_omg, _, _, _ = dcpy.oceans.GM(lat=12.0,
                                            N=N.sel(depth=10, method='nearest').values,
                                            N0=N.sel(depth=50, method='nearest').values)

# plot frequency spectra
ax = plt.gca()
ax.loglog(omg/(2*np.pi), 2*np.pi*K_omg, label='GM81 KE')
ax.loglog(omg/(2*np.pi), 2*np.pi*P_omg, label='GM81 PE')
ax.legend(frameon=False)
ax.set_title('energy spectra')
ax.set_xlabel('frequency (cps)')
ax.set_ylabel('power spectral density (m^2/s^2/cps)')

#+END_SRC
#+CAPTION: Attempt at GM spectra for KE
#+RESULTS:
[[file:../images//temp/img3907mHE.png]]

** TS plots

#+BEGIN_SRC ipython :session :ipyfile images/TS.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.TSPlot(ax=ax3)
nrl5.TSPlot(ax=ax1)
ra12.TSPlot(ax=ax2)

ax1.set_xlim([32, 36])
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//TS.png]]

#+BEGIN_SRC ipython :session :ipyfile images/KT-seasonal.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.ChipodSeasonalSummary(ax=ax3)
nrl5.ChipodSeasonalSummary(ax=ax1)
ra12.ChipodSeasonalSummary(ax=ax2)

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//KT-seasonal.png]]
** MLD climatology

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907e_A.png
mld = dcpy.oceans.argo_mld_clim()

ax = plt.gca()
for lat in range(0, 22, 2):
    mld.mld_da_mean.sel(lon=90, lat=lat,
                        method='nearest', tolerance=1).plot(ax=ax, label=str(lat))

plt.title('lon=90.5')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907e_A.png]]

** ARGO data : S_min and S_max
[[file:../images//argo-smin-smax.png]]
** sampling considerations
*** ISO signals
Can I  see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907IKt.png
dt = 1  # day
N = 365  # number of days
smth = [1, 2, 3, 4, 5]  # nsmooth
periods = np.array([10.0, 20.0, 30.0, 50.0, 60.0, 90.0])  # peaks

ax = []
ax.append(plt.subplot(211))
ax.append(plt.subplot(212))

t = np.arange(N)
ts = dcpy.ts.synthetic(N, dt, 1, -3)

for tt in periods:
    ts += 1e3 * np.sin(2*3.14/tt * t)

for ss in smth:
    dcpy.ts.PlotSpectrum(ts, ax=ax[0], scale=5**-ss,
                         nsmooth=ss, label=str(ss))
    dcpy.ts.PlotSpectrum(ts, ax=ax[1], scale=5**-ss,
                         nsmooth=ss, label=str(ss),
                         multitaper=True)

ax[0].set_title('Varying smoothing | ' + str(N) + ' day daily timeseries')
ax[1].set_title('multitaper')
plt.legend()
# dcpy.ts.PlotSpectrum(ts, nsmooth=smth, multitaper=True)
dcpy.plots.linex(1/periods)
#+END_SRC
#+CAPTION: Can I see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+RESULTS:
[[file:../images//temp/img3907IKt.png]]o
*** χpod depths for RAMA17

#+name: read-rama-10m
#+BEGIN_SRC ipython :session :results none
import xarray as xr
import pandas as pd

rama10 = xr.open_mfdataset('rama/data/t*90e_10m.cdf', autoclose=True)
salhr = xr.open_mfdataset('rama/data/s[0-9]*90e_hr.cdf', autoclose=True)

newtrange = pd.date_range(start=rama10.time.values.min(),
                          end=rama10.time.values.max(), freq='10min')
#+END_SRC

#+call: read-rama-10m()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427kYC.png
# ra12 = xr.open_dataset('rama/data/t12n90e_10m.cdf', autoclose=True)
T = rama10.T_20.sel(depth=[10, 20, 40, 60])
T = T.reindex({'time': newtrange})
T = T.where(T < 40).squeeze()
Tz = -T.diff(dim='depth')/T.depth.diff(dim='depth')
Tz['depth'] = (T.depth.values[:-1] + T.depth.values[1:])/2
Tz.name = '$T_z$'

S = salhr.S_41.sel(lat=12, depth=[10, 20, 40, 60])
S = S.reindex({'time': pd.date_range(start=S.time.values.min(),
                                     end=S.time.values.max(), freq='1H')})
S = S.where(S < 40).squeeze()
Sz = -S.diff(dim='depth')/S.depth.diff(dim='depth')
Sz.name = '$S_z$'

N2 = -9.81 * (-1.7e-4 * Tz + 7.6e-4 * Sz)
#+END_SRC

#+RESULTS:
[[file:images/temp/img10427kYC.png]]

#+BEGIN_SRC ipython :session :ipyfile images/min-Tz-rama.png
min_Tz = 1e-3

def count(x):
    return (x.where(np.abs(x) < 1e-3).count(dim='time'))/x.count(dim='time')*100

lat = [15, 12, 8, 4, 0]

f, ax = plt.subplots(len(lat), 1, sharex=True, sharey=True)

for (axx, ll) in zip(ax, lat):
    dcpy.plots.offset_line_plot(Tz.sel(lat=ll)
                                .groupby('time.dayofyear')
                                .apply(count),
                                x='dayofyear', y='depth',
                                offset=0, remove_mean=False, ax=axx)
    axx.set_title(str(ll)+'N')

f.suptitle('% observations in a day with $T_z$ < 1e-3', y=1.05)
ax[0].set_ylim([0, 100])

ax[-1].set_xlabel('day of year')

plt.tight_layout()
plt.gcf().set_size_inches((6.5, 6.5))
#+END_SRC
#+CAPTION: How likely is it that we can compute χ for an instrument at 30m vs instrument at 45m
#+RESULTS:
[[file:images/min-Tz-rama.png]]

[[file:images/li-et-al-may-oct-mld.png]]

#+call: read-ra12()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427SMu.png

#+END_SRC

** using pressure instead of accelerometer

Tested with RAMA14-810
#+CAPTION: Δp is quantized! Bit resolution ≈ 2 cm. I smooth over 0.5 seconds.
[[file:images/810-p-velz-a-velz.png]]

#+ATTR_HTML: :width 50%
#+CAPTION: Agrees with Perlin & Moum (2012), though here $dp/dt$ is smaller.
[[file:images/810-compare-spd.png]]
#+CAPTION: mean/median larger by a factor of 2 (only tested for 20-Feb-2015)
[[file:images/810-compare-chi-eps.png]]

#+CAPTION: slope ≈ 1.5 (only tested for 20-Feb-2015)
[[file:images/810-compare-hist2-chi-eps.png]]
