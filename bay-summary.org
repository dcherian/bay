#+TITLE: Bay of Bengal notes
#+SETUPFILE: ~/org/notebook.org

* Map
#+NAME: map
#+BEGIN_SRC ipython :session :results none
import bay

bay.make_labeled_map()
plt.gcf().set_size_inches((6, 8))
plt.savefig('../images/map.svg')
plt.savefig('../images/map.png', bbox_inches='tight')
#+END_SRC
#+CAPTION: χ-pod locations.
#+ATTR_HTML: :width 55%
[[file:images/map.png]]

#+BEGIN_SRC ipython :session :results none
import bay
pods = {
    'RAMA67':
        {'lon': 67, 'lat': 0, 'label': 'RAMA',
         'ha': 'center', 'va': 'bottom',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA80':
        {'lon': 80, 'lat': 0, 'label': 'RAMA',
         'ha': 'center', 'va': 'bottom',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA90':
        {'lon': 90, 'lat': 0, 'label': 'RAMA',
         'ha': 'left', 'va': 'center',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA4':
        {'lon': 90, 'lat': 4, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '45 m': ''}},
    'RAMA12':
        {'lon': 90, 'lat': 12, 'label': 'RAMA',
         'ha': 'center', 'va': 'top',
         'depths': {
             '15 m': '',
             '45 m': ''}},
    'RAMA15':
        {'lon': 90, 'lat': 15, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '15 m': '2018, 19',
             '30 m': '2018, 19',
             '45 m': '2018, 19',
             '55 m': '2018, 19',
             '65 m': '2018, 19'}},
}

ax, colors = bay.make_map(pods, DX=1, DY=1, add_year=False)

ax.set_xlim([65, 96])
ax.set_ylim([-2, 24])
ax.set_xticks([65, 67, 70, 75, 80, 85, 90, 95])
ax.set_yticks([0, 4, 8, 12, 15, 18, 20, 22, 24])

ax.set_title('MISOBOB $χ$pod deployments (2018, 19)')
plt.savefig('../images/map-misobob.svg')
plt.savefig('../images/map-misobob.png', bbox_inches='tight')
#+END_SRC
#+ATTR_HTML: :width 55%
[[file:images/map-misobob.png]]

** emily :noexport:
#+CAPTION: χpod locations for ASIRI/EBOB/MISOBOB
#+ATTR_HTML: :width 55%
[[file:../images/MixingmapASIRIPiston.png]]
* All χpods
** RAMA
#+ATTR_HTML: :class full-width
[[file:images/summary-RAMA-12N-2014.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-RAMA-12N-2015.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-RAMA-15N.png]]

** EBOB
#+ATTR_HTML: :class full-width
[[file:images/summary-NRL1.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL2.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL3.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL4.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL5.png]]

* vertical distribution of $K_T$
** Make plot
*** Merge together
#+CALL: read-all-moorings()
#+NAME: make-merged-KT
#+BEGIN_SRC ipython :session :results none
import bay

moorings = [ra12, ra15, nrl1, nrl3, nrl4, nrl5]
bay.make_merged_nc(moorings)

#KTm = xr.open_dataset('merged_KT.nc')
#ρbins = histedges_equalN(np.ravel(KTm.ρ), 11)
#Sbins = histedges_equalN(np.ravel(KTm.S), 11)

#KTdf = bin_and_to_dataframe(KTm, ρbins)
#+END_SRC
*** means/medians profile
#+NAME: vert-profile
#+BEGIN_SRC ipython :session :results none
import bay
bay = importlib.reload(bay)

moors = ['RAMA12', 'RAMA15', 'NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5']

bay.make_vert_distrib_plot('KT', label_moorings=True)
plt.savefig('images/vert-profile.svg', bbox_inches='tight')
plt.savefig('images/bay-KT-vert-profile.pdf', bbox_inches='tight')
plt.savefig('images/bay-KT-vert-profile.png', bbox_inches='tight')
#+END_SRC
#+ATTR_HTML: :class full-width
[[file:images/bay-KT-vert-profile.png]]

Some sensitivities:
1. Changing 505 to 'mmw': not much

2. High mixing at 70-100m depth in SW monsoon, compared to NE monsoon.
   1. Connected to SMC/SLD?
   2. Near-inertial waves from storms could be a thing
   3. Something happens in NRL5, around SW monsoon start to see temperature inversions semi-regularly (rare, but regular)

3. High values near surface are usually base of mixed layer/barrier layer χpods (527, 814)

4. 814 is crap: some changes moving distributions lower.

5. Changing 511 to mm2: quite a bit. Reduced the double peak stuff


#+NAME: save-distrib-for-each-mooring
#+BEGIN_SRC ipython :session :results none
import bay
bay = importlib.reload(bay)

bins = [1018, 1021, 1022, 1022.5, 1023, 1023.5, 1024.25, 1029]
moors = ['RAMA12', 'RAMA15', 'NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5']

for mm in moors:
    bay.make_vert_distrib_plot('KT', bins, mm)
    plt.gcf().suptitle(mm)
    plt.savefig('images/vert-profile-moor/'+mm+'.png', bbox_inches='tight')
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgrtIJ8z.png
season = 'SW'
bin_name = 24.0

ρmid = (KTdf.bin
        .apply(lambda x: x.mid-1000 if type(x) is not str else None))

if type(bin_name) is str:
    mask = KTdf.bin == bin_name
else:
    mask = (abs(ρmid - bin_name) < 0.2)

# mask = np.logical_and(mask, KTdf.season == season)
subset = KTdf[mask]
f, ax = vert_distrib(subset, subset.moor, varname='ρ')
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[702]:
:END:

#+NAME: sal-distrib
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgbp6rfN.png :results drawer
<<define-vert_distrib>>

Sbins = pd.qcut(KTdf.S, 11)

f, ax = plot_distrib(KTdf, bins, varname='S', xlines=[32, 35])
# plot_distrib(KTdf.where(KTdf.S > 34.9), bins, pal=[[0.5,0.5,0.5]]*13, f=f, ax=ax)
#+END_SRC
#+RESULTS: sal-distrib
:RESULTS:
[[file:images/temp/imgbp6rfN.png]]
:END:
*** bootstrap confidence intervals on mean
#+BEGIN_SRC ipython :session
import scikits.bootstrap as bs
import tqdm

if 'turb' not in locals():
    turb = bay.nc_to_binned_df()

if 'df' not in locals():
    dflist = []
    for (season, name), group in tqdm.tqdm(
            turb[['KT', 'z']].groupby([turb.season, turb.bin])):

        ci = bs.ci(group.KT)
        dflist.append(pd.DataFrame({'season': season,
                                    'bin': name,
                                    'KT': group.KT.mean(),
                                    'ci': [ci],
                                    'z': sp.stats.trim_mean(group.z, 0.1)},
                                   index=[0]))

    df = pd.concat(dflist)
    df['season'] = df.season.astype('category')
    df['bin'] = df['bin'].astype('category')

bay.plots.vert_distrib(df, df.bin, kind='mean_ci_profile',
                       label_moorings=False, add_offset=True,
                       xlim=[-7.5, -2])
plt.subplots_adjust(wspace=0)

plt.savefig('images/bay-KT-mean-profile.png', bbox_inches='tight')
plt.savefig('images/bay-KT-mean-profile.pdf', bbox_inches='tight')

#+END_SRC
#+CAPTION:
[[file:images/bay-KT-mean-profile.png]]

*** full distrib seaborn
#+NAME: define-seaborn_vert_distrib
#+BEGIN_SRC ipython :session :results none
pal_dist = sns.color_palette("GnBu_d", n_colors=13)
pal_dist.reverse()

def seaborn_vert_distrib(KTdf, category, kind='kde'):
    stylekwargs = dict(style="ticks",
                       rc={'axes.facecolor': 'None',
                           'figure.facecolor': 'None'})
    bandwidth = 'scott'
    # pal_dist=sns.cubehelix_palette(11, rot=-.25, light=.7)
    # pal_dist = [pal_dist[0]]*13

    pal_boxplot = sns.color_palette("muted",
                                    n_colors=len(KTdf['latlon'].unique()))
    pal_boxplot[1] = (0,0,0)
    pal_boxdict = dict(zip(KTdf['latlon'].unique(), pal_boxplot))

    # pal = sns.cubehelix_palette(11, rot=-.25, light=0.7)

    def label(x, color, label):
        def stat_label(name, x, fmt, suffix=''):
            q75, q25 = np.percentile(x, [75, 25])
            return ((name+': {0:'+fmt+'}'+suffix
                     +', {1:'+fmt+'}'+suffix
                     +', {2:'+fmt+'}'+suffix)
                    .format(q25, x.mean(), q75))

        extract = KTdf.take(x.index)
        ax = plt.gca()
        label = float(label)
        if category == 'ρbinned':
            lab = (stat_label('S', extract.S, '.1f') + '\n'
                   + stat_label('z', extract.z, '.0f', 'm') + '\n'
                   +'σ: {0:2.1f}kg/m³'.format(label-1000))
        elif category == 'Sbinned':
            lab = '{0:2.1f}'.format(label)
        elif category == 'mean_depth':
            lab = '{0:.0f}m'.format(label)

        ax.text(1, 0.05, lab,
                color=(sns.light_palette((210, 90, 20), input="husl"))[3],
                fontsize=8,
                ha="right", va="bottom", transform=ax.transAxes)

    def mark_distributions_by_location(x, color, label):
        ax = plt.gca().twinx()
        gby = KTdf.take(x.index).groupby('latlon');

        for index, (name, grp) in enumerate(gby):
            props = {'linewidth': 1, 'color': pal_boxdict[name]}
            ax.boxplot(grp['KT'], vert=False, sym='', widths=0.08,
                       showbox=False,
                       showmeans=False, positions=[0.2+0.1*index],
                       boxprops={**props}, whiskerprops={**props},
                       medianprops={**props}, capprops={**props})

        ax.set_ylim([0, 2])
        ax.set_yticks([])

        # with sns.axes_style(**stylekwargs):
        #     sns.boxplot(data=KTdf.take(x.index), x='KT', hue='latlon',
        #                 ax=ax, orient='h', width=0.1)

    def mark_mean_mdn(x, color, label):
        ax = plt.gca()

        mean = np.log10(np.nanmean(10**x))
        median = np.log10(np.nanmedian(10**x))
        yloc = 0.5
        plt.plot(mean, yloc, color=color, marker='x')
        # plt.plot(mean, yloc, color='w', marker='x', fillstyle='none')
        plt.plot(median, yloc, color=color, marker='o', ms=10)
        plt.plot(median, yloc, color='w', marker='o', ms=11, fillstyle='none')

    with sns.axes_style(**stylekwargs):
        g = sns.FacetGrid(KTdf, row=category, col="season",
                          col_order=['NE', 'NESW', 'SW', 'SWNE'],
                          hue=category, xlim=[-7, 0],
                          sharex=True, sharey=True, palette=pal_dist,
                          aspect=4, size=1)


        kdekwargs = {'clip': [-8, 0],
                     'clip_on': False,
                     'cut': 0,
                     'bw': bandwidth}

        distkwargs = {'bins': 50, 'hist':True, 'rug':False, 'norm_hist':True,
                      'kde':False, 'kde_kws':{'lw': 1, **kdekwargs}}
        if kind == 'kde':
            g.map(sns.kdeplot, "KT", shade=True, alpha=0.6, lw=1.5, **kdekwargs)
            g.map(sns.kdeplot, "KT", color="w", lw=2, **kdekwargs)

        elif kind == 'dist':
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'alpha': 1})
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'histtype': 'step', 'color': 'w',
                            'lw': 1, 'alpha': 1})

        g.map(plt.axhline, y=0, lw=2, clip_on=False)

        g.map(label, "KT")
        g.map(mark_mean_mdn, "KT")
        g.map(mark_distributions_by_location, "KT")
        g.fig.subplots_adjust(hspace=-0.58)
        g.set_xlabels('$K_T$')
        g.set_titles('')
        g.set(yticks=[], ylim=[0, 2])
        _ = g.despine(left=True)

        g.axes[1,0].set_title('NE\n(Dec-Mar)')
        g.axes[1,1].set_title('NE → SW\n(Apr-May)')
        g.axes[1,2].set_title('SW\n(Jun-Sep)')
        g.axes[1,3].set_title('SW → NE\n(Oct-Nov)')

        for index, tt in enumerate(KTdf['latlon'].unique()):
            plt.gcf().text(0.98,0.97-index*0.015, tt,
                           color=pal_boxplot[index],
                           ha='right', va='top')
            plt.suptitle('Columns are seasons, rows are density bins', y=0.95)

        return g

#+END_SRC

#+NAME: KT-vert-hist
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist.png :results drawer
<<define-seaborn_vert_distrib>>
KTdf['ρbinned'] = pd.qcut(KTdf.ρ, 11, precision=1)
KTdf.ρbinned = KTdf.ρbinned.apply(lambda x: x.mid)
g = seaborn_vert_distrib(KTdf, "ρbinned", 'dist')
#+END_SRC
#+RESULTS: KT-vert-hist
:RESULTS:
# Out[24]:
[[file:images/bay-KT-vert-hist.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/bay-sampling-hist.png :results drawer
<<define-seaborn_vert_distrib>>
KTdf.bin = pd.qcut(KTdf.ρ, 11, precision=1)
g = seaborn_vert_distrib(KTdf, "bin", 'dist')
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist-depths.png
<<define-seaborn_vert_distrib>>
seaborn_vert_distrib(KTdf, 'mean_depth', 'kde')
#+END_SRC
#+RESULTS:
[[file:images/bay-KT-vert-hist-depths.png]]
** nutrient fluxes
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgDBOejX.png
df = bay.convert_nc_to_binned_df()

# needed to preserve order
coords = {'season': df.season.cat.categories,
          'bin': df.bin.cat.categories}

means = xr.DataArray(np.zeros((len(df.season.unique()), len(df.bin.unique()))),
                     dims=['season', 'bin'],
                     coords=coords, name='means')

medians = xr.DataArray(np.zeros((len(df.season.unique()),
                                 len(df.bin.unique()))),
                       dims=['season', 'bin'],
                       coords=coords, name='medians')

z = xr.DataArray(np.zeros((len(df.season.unique()), len(df.bin.unique()))),
                 dims=['season', 'bin'],
                 coords=coords, name='z')

stats = xr.merge([means, medians, z])

for label, group in df.groupby(['season', 'bin']):
    season = label[0]
    interval = label[1]

    stats['means'].loc[season, interval] = (10**group.KT).mean()
    stats['medians'].loc[season, interval] = (10**group.KT).median()
    stats['z'].loc[season, interval] = group.z.mean()

stats.means.attrs['description'] = 'Seasonal and density-binned means of hourly-mean temperature diffusivity K_T'

stats.medians.attrs['description'] = 'Seasonal and density-binned medians of hourly-mean temperature diffusivity K_T'

stats.to_netcdf('means_medians.nc')
#+END_SRC

TODO:
1. Subset K_T to appropriate locations
2. why are the bins unsorted?

#+BEGIN_SRC ipython :session :ipyfile images/temp/imge5GfnK.png

o2 = (xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_o*_01.nc',
                        decode_times=False)
      .sel(**bay.region)
      .load())

t = (xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_decav_t*_01v2.nc',
                       decode_times=False)
     .sel(**bay.region)
     .load())

s = (xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_decav_s*_01v2.nc',
                       decode_times=False)
     .sel(**bay.region)
     .load())

time_new = np.datetime64(pd.datetime(2001, 1, 15)) + t.time.astype('timedelta64[M]')
time_new['time'] = time_new.data

smon = (s.s_an.sel(**bay.ebob_region)
        .groupby(time_new.monsoon.labels)
        .mean(dim='time').mean(dim='lat').mean(dim='lon'))

(nioa.SALT.sel(**bay.ebob_region)
 .mean(dim=['lon', 'lat'])
 .groupby(time_new.monsoon.labels.rename({'time': 'TIME'}))
 .mean(dim='TIME')
 .plot.line(y='DEPTH', hue='monsoon', yincrease=False))

# TODO: subset to use EBoB region K_T also
rho = (xr.DataArray(sw.pden(s.s_an, t.t_an, xr.broadcast(s.s_an, s.depth)[1]),
                    dims=t.t_an.dims, coords=t.t_an.coords)
       .sel(**bay.ebob_region)
       .mean(dim='lat').mean(dim='lon')
       .groupby(time_new.monsoon.labels)
       .mean(dim='time')
       .rename({'monsoon': 'season'}))

oxy = (o2.o_an
       .sel(lon=slice(85.5, 88.5), lat=slice(5, 8))
       .mean(dim='lat').mean(dim='lon')
       .groupby(time_new.monsoon.labels)
       .mean(dim='time')
       .rename({'monsoon': 'season'}))

flux = xr.zeros_like(stats.means) * np.nan
do2_dz = xr.zeros_like(stats.means) * np.nan
flux.name = 'o2 flux'
flux.attrs['long_name'] = '$O_2$ flux'

# interpolate WOA profile to this grid
depth_new = np.linspace(0, 400, 400)

for bb in stats.bin:
    interval = bb.item()

    if not isinstance(interval, pd.Interval):
        continue

    for seas in stats.season:
        rho_prof = rho.sel(season=seas).interp(depth=depth_new)
        oxy_prof = oxy.interp(depth=depth_new)
        mask = np.logical_and((rho_prof >= interval.left).values,
                              (rho_prof < interval.right).values)
        if mask.sum() < 3:
            continue

        do2_dz.loc[seas, interval] = (
            np.polyfit(-oxy_prof.sel(season=seas)[mask].depth.values,
                       oxy_prof.sel(season=seas)[mask].values, 1)[0])

flux = -stats.means * do2_dz
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[303]:
:END:


*** old attempts
**** without MLD binning : only ρ binning
#+CAPTION: After extending unit 814 with pitot
[[file:images/bay-KT-vert-profile-pre-mld-bin.png]]

**** by latitude
#+NAME: kt-by-lat
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-by-lat.png
KTdf.loc[KTdf['depth'] == 43.0, 'depth'] = 45.0
KTdf.loc[KTdf['depth'] == 68.5, 'depth'] = 69.0
KTdf.loc[KTdf['depth'] == 89.4, 'depth'] = 88.2
g = sns.FacetGrid(KTdf, row='depth', col='lat', hue='season',
                  sharex=True, sharey=True,
                  hue_order=['NE', 'NESW', 'SW', 'SWNE'],
                  col_order=[5., 8., 12.0, 15.0],
                  margin_titles=True, legend_out=False,
                  size=1.2, aspect=2)

kdekwargs = {'clip': [-8, 0],
             'clip_on': False,
             'bw': 0.2}

g.map(sns.kdeplot, "KT", shade=False, lw=1.5, **kdekwargs)
g.add_legend()
g.set(xlim=[-8,0], ylim=[0, 1], yticks=[])
sns.despine(left=True)
plt.subplots_adjust(hspace=-0.15)
#+END_SRC
#+RESULTS: kt-by-lat
[[file:images/bay-KT-by-lat.png]]
** Bin testing
Test out binning so that there are equal number of observations (NaN filtered) in each bin
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgSAH1E0.png :results drawer
def histedges_equalN(x, nbin):
    # from https://stackoverflow.com/questions/39418380/histogram-with-equal-number-of-points-in-each-bin
    x = x[np.logical_not(np.isnan(x))]
    npt = len(x)
    return np.interp(np.linspace(0, npt, nbin + 1),
                     np.arange(npt),
                     np.sort(x))

turb.ρ.plot.hist(bins='fd', density=True)
ρbins = histedges_equalN(np.ravel(turb.ρ), 12)
_ = turb.ρ.plot.hist(bins=ρbins, density=True, edgecolor='k', facecolor='none')
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/temp/imgSAH1E0.png]]
:END:


#+NAME: argo-clim-density
#+BEGIN_SRC ipython :session :ipyfile images/mean-density-at-moorings.png
import dcpy.oceans
import seawater as sw

latitude = [12, 15, 5, 6.5, 8, 8, 8]
longitude = [90, 90, 85.5, 85.5, 85.5, 87, 88.5]
name = ['RA12', 'RA15', 'NRL1', 'NRL3', 'NRL4', 'NRL5']

_, ax = plt.subplots(1, 3, sharey=True)
if 'argoS' not in locals():
    argoS = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Salinity_2016.nc',
                            decode_times=False)
    argoT = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Temperature_2016.nc',
                            decode_times=False)

for (lon, lat, moorname) in zip(longitude, latitude, name):
    S = argoS.ARGO_SALINITY_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    T = argoT.ARGO_TEMPERATURE_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    ρ = sw.pden(S, T, argoS.PRESSURE)

    ax[0].plot(S, argoS.PRESSURE, label=moorname)
    ax[1].plot(T, argoS.PRESSURE, label=moorname)
    ax[2].plot(ρ, argoS.PRESSURE, label=moorname)

plt.ylim([120, 0])
plt.gcf().legend()
dcpy.plots.linex(Sbins, ax=ax[0])
dcpy.plots.linex(ρbins, ax=ax[2])
ax[0].set_ylabel('Pressure')
ax[0].set_xlabel('S')
ax[1].set_xlabel('T')
ax[1].set_xlim([20, 30])
ax[2].set_xlabel('ρ')
plt.gcf().suptitle('Roemmich & Gilson ARGO Climatology')
plt.gcf().set_size_inches((5.5, 2.5))
#+END_SRC
#+CAPTION: Mark density bins on ARGO climatology density profile
#+RESULTS: argo-clim-density
[[file:images/mean-density-at-moorings.png]]

#+NAME: TS-sampled-distribution
#+BEGIN_SRC ipython :session :ipyfile images/TSρ-sampled-by-χpod.png :results drawer
f, ax = plt.subplots(2,1)
sns.violinplot(data=KTdf.dropna(), x="depth", y="ρ", ax=ax[0])
sns.violinplot(data=KTdf.dropna(), x="depth", y="S", ax=ax[1])
# sns.violinplot(data=KTdf.dropna(), x="depth", y="T", ax=ax[2])
plt.gcf().autofmt_xdate()
ρbins2 = [ 1019.45,  1020.43,  1021.05,  1021.68,
           1022.49,  1022.94,  1023.49,  1026.27]
dcpy.plots.liney(ρbins, ax=ax[0])
dcpy.plots.liney(Sbins, ax=ax[1])
plt.gcf().set_size_inches((8.5, 7.5))
plt.tight_layout()
#+END_SRC
#+RESULTS: TS-sampled-distribution
:RESULTS:
[[file:images/TSρ-sampled-by-χpod.png]]
:END:

#+NAME: kmeans
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgiZJc38.png
data = KTdf.ρ
centroids, _ = sp.cluster.vq.kmeans(data, 10)
idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(10):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1])

#+END_SRC
#+RESULTS: kmeans
[[file:images/temp/imgiZJc38.png]]

#+NAME: TS-plot
#+BEGIN_SRC ipython :session :ipyfile images/rho-bins-TS-plot.png :results drawer
T, S, binned= dcpy.util.BinEqualizeHist([KTdf['T'], KTdf['S']], bins=[200, 100])
Tg, Sg = np.meshgrid(T, S, indexing='ij')
ρg = sw.pden(Sg, Tg, 50)
# plt.plot(KTdf['S'], KTdf['T'], '.')
plt.pcolormesh(S, T, binned.T, cmap=mpl.cm.Reds)
# hc = plt.contour(Sg, Tg, ρg, colors='k', levels=ρbins)
# plt.clabel(hc, fmt='%1.1f')
plt.xlabel('S')
plt.ylabel('T')

kmeans = 12

data = KTdf.ρ
centroids, _ = sp.cluster.vq.kmeans(data, kmeans)
idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(kmeans):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1], 'k--')

cent = np.sort(centroids)
newbins = np.hstack([KTdf.ρ.min(), (cent[:-1]+cent[1:])/2])
hc = plt.contour(Sg, Tg, ρg, colors='k', levels=newbins, zorder=10)
plt.clabel(hc, fmt='%1.1f')
#+END_SRC
#+RESULTS: TS-plot
:RESULTS:
: <a list of 12 text.Text objects>
[[file:images/rho-bins-TS-plot.png]]
:END:
** analysis
*** Why is there a peak in SWNE in the EBOB array?
Biggest contribution is NRL1. Some more from NRL4. The low values are from NRL5. NRL3 seems to miss out... because the instruments are shallower?

#+CAPTION: 2014 monthly mean SSH EKE normalized by climatological monthly mean SSH EKE. NRL3 sees more EKE than usual.
[[file:images/eke-norm-clim-2014.png]]
*** At what ρ levels in the Bay is there large spiciness / large watermass contrasts?
  - σ=22-24; 23 is where the Arabian Sea S_{max} is.
* Surface fluxes
#+CALL: read-tropflux()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img7tMMDR.png
# sst = ra12.ctd['T'].sel(depth=1).groupby('time.month').mean(dim='time')

timebase = 'weekofyear'

tfsel = tropflux.sel(longitude=90, latitude=12, method='nearest')
tf = (tfsel.groupby('time.'+timebase)
      .mean(dim='time'))

jq0 = tf.netflux

if 'mldclim' not in locals():
   mldclim = dcpy.oceans.argo_mld_clim()

mld = mldclim.mld_da_mean.sel(lon=90, lat=12, method='nearest')

if timebase == 'weekofyear':
   ihi = np.interp(np.linspace(1,13, 53), mld.month,
                   0.45 * tfsel.swr.groupby('time.month').mean(dim='time')
                   ,* np.exp(-0.04 * mld))
   Ih = xr.DataArray(ihi, dims=[timebase],
                     coords=[jq0[timebase]], name='Ih')
else:
   Ih = 0.45*tfsel.swr.groupby('time.month').mean(dim='time')

f, ax = plt.subplots(2,1)
hsst = tf.sst.plot(ax=ax[0],color='k')
ax0 = ax[0]
ax1 = ax0.twinx()
hjq0 = ax1.fill_between(jq0[timebase], jq0-Ih, color='salmon')
ax1.set_zorder(-10)
ax1.axhline(0, color='k')
# hIh = Ih.plot.line('k--', ax=ax1)

ax0.set_title(''); ax1.set_title('');

_ = f.legend((hsst[0], hjq0),
           ('SST', 'Jq0-Ih'),
           loc='upper center')

jq14 = ra12.Jq.sel(time='2014').groupby('time.'+timebase).mean(dim='time')
jq15 = ra12.Jq.sel(time='2015').groupby('time.'+timebase).mean(dim='time')
jqt = (jq14.fillna(0) + jq15.fillna(0))/2
jqt.plot.line(ax=ax1)

_ = (mld*-1).plot(ax=ax[1])
args = {'color': 'k', 'ls': '--'}
ax[1].axhline(-15, **args)
ax[1].axhline(-30, **args)
ax[1].axhline(-45, **args)
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img7tMMDR.png]]
* Seasonal patterns
** depth of salinity surfaces

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgzHFIIB.png
(clim.SALT.isel(TIME=3).sel(DEPTH=50, method='nearest')
 .plot.contourf(cmap=mpl.cm.Reds, levels=20, robust=True))
hdl = (clim.SALT.isel(TIME=3).sel(DEPTH=50, method='nearest')
 .plot.contour(colors='k', levels=[32, 33, 34, 35], robust=True))
plt.gca().set_aspect('equal')
plt.gca().clabel(hdl, hdl.levels)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[14]:
: <a list of 2 text.Text objects>
:END:

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgzT2m1u.png :results drawer
clim = xr.open_dataset('~/work/datasets/nio-atlas/nioa_climatology_seasonal_temp_salt_monsoon_season.nc', decode_times=False)

_, zmat = xr.broadcast(clim.SALT, clim.DEPTH)

S0 = 33
isodepth = zmat.where(np.logical_and(clim.SALT > S0-0.1, clim.SALT < S0+0.1)).mean(dim='DEPTH')

isodepth.plot(x='LONGITUDE', col='TIME', col_wrap=2, levels=np.arange(10, 500, 30))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[138]:
: <xarray.plot.facetgrid.FacetGrid at 0x7f23fd4b7630>
[[file:images/temp/imgzT2m1u.png]]
:END:
** "pycnocline uplift"
It is quite hard to see if there is a semi-regular period.

This could be the large-scale ∇S being advected back and forth across the mooring.
1. At 12N, it happens in Jul-2014, Jul-2015

#+BEGIN_SRC ipython :session :ipyfile images/rama-sal-mosaic.png :results drawer
sal = (xr.open_dataset('~/TaoTritonPirataRama/RAMA/s_xyzt_dy.cdf')
       ['S_41'].sel(lon=90, lat=[12,15]))
sal.values[sal.values > 40] = np.nan
sal = sal.dropna(dim='depth', how='all')

def process(x):
    x = x.expand_dims('year')
    x['year'] = x.time.dt.year.pipe(np.unique)
    x['time'] = x.time.dt.dayofyear
    x = x.rename({'time': 'dayofyear'})
    return x

stacked = [process(a[1]) for a in sal.groupby('time.year')]

syearly = (xr.concat(stacked, dim='year')
           .dropna(dim='year', how='all')
           .drop([2007, 2018], dim='year'))

g = syearly.plot.contourf(x='dayofyear', row='year', col='lat',
                          robust=True, levels=40, yincrease=False, size=1, aspect=7)
# g.axes[0,0].set_xlim([0, 100])
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/rama-sal-mosaic.png]]
:END:
*** old figures :noexport:
[[file:images/15n-sal.png]]
[[file:images/12n-sal.png]]
** K_T variations
#+CAPTION: Distribution of 5 minute averages of K_T.
#+RESULTS:
[[file:../images//rama12n-kt-boxplot.png]]
** Spectrograms
*** Things to look at
1. NRL1 cyclonic shear bit; might be a signal in J_q. Also near-(shifted) inertial energy at this point
2.
*** Summary
- M_2 *shear* has some patterns. M_2 signal in temperature occurs throughout.
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| Moor | Overall                     | NE              | NESW         | SW                           | SWNE         |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL1 | Not much f_0                 | max CW f_0 shear |              | some diurnal                 |              |
|      | M_2, M_4 T throughout         |                 |              | lots of high frequency shear |              |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL2 |                             |                 |              |                              |              |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL3 |                             |                 |              | max f_0 shear                 |              |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL4 | max f_0 shear                |                 |              |                              | max f_0 shear |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|
| NRL5 | IW energy only along f_0, M_2 | Max f_0 shear    | max f_0 shear |                              |              |
|      | Lots of f_0 shear            |                 |              | Bursts of M_2 shear           |              |
|------+-----------------------------+-----------------+--------------+------------------------------+--------------|

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgcwn1WZ.png
self = nrl1
depth = 140

f, ax = plt.subplots(3, 1, sharex=True)

self.vel.u.sel(depth=depth, method='nearest').plot(ax=ax[0])
self.vel.v.sel(depth=depth, method='nearest').plot(ax=ax[0])
ax[0].legend('u', 'v')
ax[0].axhline(0)

self.vel.uz.sel(depth_shear=depth, method='nearest').plot(ax=ax[1])
self.vel.vz.sel(depth_shear=depth, method='nearest').plot(ax=ax[1])
ax[1].axhline(0)
ax[1].legend('$u_z$', '$v_z$')

self.ctd['T'].sel(depth2=depth, method='nearest').plot(ax=ax[2])
ax2 = ax[2].twinx()
self.ctd['S'].isel(z=3).plot(ax=ax2, color='teal')

[self.MarkSeasonsAndEvents(aa) for aa in ax]

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[53]:
: [None, None, None]
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgKGsAoh.png
# test interpolation

da = xr.DataArray(np.sin(0.3 * np.arange(20).reshape(5, 4)),
                  [('x', np.arange(5)),
                   ('y', [0.1, 0.2, 0.3, 0.4])])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[185]:
:END:


nrl5 ε seems have some nice period variability during SW monsoon. can I see that in a spectrum?

#+BEGIN_SRC ipython :session :ipyfile images/temp/img0A5iM0.png
eps1 = (nrl5.ε
       .resample(time='12H').mean(dim='time'))
eps2 = (eps1
        .where(eps1 > 1e-12)
        .interpolate_na(dim='time')
        .dropna(dim='time'))


f, ax = plt.subplots()

for zz in eps1.depth:
    dcpy.ts.PlotSpectrum((eps2.sel(depth=zz)),
                         multitaper=True, preserve_area=True,
                         ax=ax)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[341]:
[[file:images/temp/img0A5iM0.png]]
:END:

#+BEGIN_SRC ipython :session :results none
for m in [nrl1, nrl3, nrl4, nrl5]:
    m.plot_turb_spectrogram()
    plt.gca().set_xlim(['2014-01-01', '2014-12-31'])

    plt.savefig('images/specgram-' + m.name + '.png',
                bbox_inches='tight')
#+END_SRC

[[file:images/specgram-NRL1.png]]
[[file:images/specgram-NRL2.png]]
[[file:images/specgram-NRL3.png]]
[[file:images/specgram-NRL4.png]]
[[file:images/specgram-NRL5.png]]
*** Coarser summary

#+CAPTION: RAMA13 526 15m: NE & NESW have CW energy ≈ CCW energy (not polarised!) Very heavily polarized during the SW and SWNE. Big diurnal peak during SWNE too. Why is there not more CW-polarized NIW energy during NE monsoon?
[[file:images/mixing_seasons_ra12_526.png]]

#+CAPTION: NRL5 519 105m:
[[file:images/mixing_seasons_nrl5_519.png]]
*** NRL5
Let's look at IW spectrum during period  of low mixing and period of high mixing.

#+BEGIN_SRC ipython :session :ipyfile images/temp/img50EzMF.png

lowmix = slice('2014-03-17', '2014-05-05')
himix = slice('2014-05-06', '2014-11-01')

dTdz = -nrl5.ctd['T'].diff(dim='depth2')/nrl5.ctd.depth2.diff(dim='depth2')

z = 90
f, ax = plt.subplots(constrained_layout=True)
kwargs = dict(ax=ax, multitaper=True, dt=600/86400)
dcpy.ts.PlotSpectrum((nrl5.ctd['T'].sel(time=lowmix, depth2=z)
                      / dTdz.sel(time=lowmix, depth2=z).mean(dim='time')),
                     ,**kwargs)
dcpy.ts.PlotSpectrum((nrl5.ctd['T'].sel(time=himix, depth2=z)
                      / dTdz.sel(time=himix, depth2=z).mean(dim='time')),
                     ,**kwargs)
ax.legend(('lowmix', 'himix'))

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[175]:
: <matplotlib.legend.Legend at 0x7fbaccba9f98>
:END:

** Seasonal cycle in internal wave energy?
#+BEGIN_SRC ipython :session
depth = 500

var = nrl5.ctd.T.rename({'depth2': 'depth'})

def spectrum_variance(var):
    S, f = dcpy.ts.CenteredFFT(var.interpolate_na('time'))

    ft = xr.DataArray(S, dims='freq', coords={'freq': f * 86400/3600})
    ft = ft.where(ft.freq > 0, drop=True) * 2

    ftiw = ft.where((ft.freq > 0.5*f0) & (ft.freq < 4), drop=True)

    return (xrsp.integrate.trapz(np.abs(ftiw)**2, 'freq')/len(ftiw))

f, ax = plt.subplots(1, 1, constrained_layout=True)

for var, label in zip([nrl5.ctd.T.rename({'depth2': 'depth'}),
                       nrl5.vel.u],
                      ['T', 'u']):
    var = (var.sel(time='2014')
           .sel(depth=slice(50, 250)).mean('depth')
           .interpolate_na('time'))

    f0 = nrl5.inertial
    N = argo.N2.mean('time').pipe(np.sqrt)*86400

    variance = (var.groupby('time.month').apply(spectrum_variance))
    hdl = (variance/variance.max()).plot()
    dcpy.plots.annotate_end(hdl[0], label=label)

ax.set_ylabel('Normalized internal wave-band variance\n(50m - 250m)')
ax.set_title('NRL5')

f.savefig('images/nrl5-monthly-iw-variance.png')
#+END_SRC
#+CAPTION: OK there is a seasonal cycle in near-inertial band variance; seen in both T and u. I need to calculate a baseline GM spectral value and plot it on here.
[[file:images/nrl5-monthly-iw-variance.png]]

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgnRA15P.png
T = nrl5.ctd.T_S.isel(z=3)

kwargs = {'dt': 600/86400,
          'multitaper': True,
          'nsmooth': 5}
dcpy.ts.PlotSpectrum(T.monsoon.ne, **kwargs)
dcpy.ts.PlotSpectrum(T.monsoon.nesw, **kwargs)
dcpy.ts.PlotSpectrum(T.monsoon.sw, **kwargs)
dcpy.ts.PlotSpectrum(T.monsoon.swne, **kwargs)
tides = dcpy.ts.TidalAliases(600/86400)

plt.gca().axvline(1/(2*np.pi/dcpy.oceans.coriolis(8)/86400))
plt.gca().axvline(1/(2*np.pi/dcpy.oceans.coriolis(8)/86400))

dcpy.plots.linex([tt for tt in tides.values()])

plt.gca().legend(['NE', 'NESW', 'SW', 'SWNE'])

#+END_SRC

Let's integrate temperature spectrum in 3 bands:
1. Internal waves: 1/1.2f < freq < 1/20 minutes
2. Near-inertial: 1/1.2f < freq < 1/0.9f (*clockwise only*)
3. M2 : 0.9*f_M2 < freq < 1.1*f_M2
4. K1 : 0.9*f_K1 < freq < 1.1*f_K1

Compute the rotary spectra and integrate the sum if not near-inertial (in that case, I do clockwise only).
#+NAME: integrate_velocity_spectrum
#+BEGIN_SRC ipython :session :results none
kwargs = {'dt': 3600/86400,
          'multitaper': True,
          'nsmooth': 5}

Eiw = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                   columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                   dtype=np.float64)
Eniw = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                    columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                    dtype=np.float64)
Em2 = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                   columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                   dtype=np.float64)

Ek1 = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                   columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                   dtype=np.float64)

tides = dcpy.ts.TidalAliases(dt=600/86400)

debug = True

def integrate_spectrum(spec, flo, fhi, debug=False):
    spec_iw = spec.where(np.logical_and(spec.freq > flo,
                                        spec.freq < fhi))

    if debug:
        spec.plot()
        spec_iw.dropna(dim='freq', how='all').plot()
        dcpy.plots.linex([flo, fhi])
        plt.gca().set_xscale('log')
        plt.gca().set_yscale('log')

    return (xrsp.integrate.trapz(spec_iw.dropna(dim='freq'),
                                 coord='freq')
            .values.ravel()[0])

if debug:
    with plt.style.context('ggplot'):
        fall, axall = plt.subplots(1, 2);
        fall.set_size_inches((10, 10/2.5))

for moor in [nrl1, nrl3, nrl4, nrl5]:
    print(moor.name)
    inertial = 1/(2*np.pi/(dcpy.oceans.coriolis(moor.lat)*86400))

    T = ((moor.vel.u + 1j * moor.vel.v)
         .sel(depth=100, method='nearest'))

    if np.all(np.isnan(T)):
        continue

    with plt.style.context('ggplot'):
        if debug:
            dcpy.ts.PlotSpectrum(T.dropna(dim='time'),
                                 preserve_area=True,
                                 ax=axall, twoside=True, **kwargs)

            f, ax = plt.subplots(2, 2, sharex=True, sharey=True)
            f.set_size_inches(8, 5)
            plt.suptitle(moor.name)
            axes = dict(NE=ax[0,0], SW=ax[0,1],
                        NESW=ax[1,0], SWNE=ax[1,1])

        for season in Eiw.index:
            # T = (np.hypot(moor.vel.u, moor.vel.v)
            #      .sel(depth=100, method='nearest'))

            Tsub = (T.where(T.monsoon.labels == season)
                    .sel(time='2014')
                    .dropna(dim='time'))

            # S, freq, conf = dcpy.ts.SpectralDensity(T, **kwargs)
            cw, ccw, freq, conf_cw, conf_ccw = dcpy.ts.RotaryPSD(Tsub, **kwargs)

            dakwargs = dict(dims=['freq'], coords={'freq': freq})
            spec = xr.Dataset()
            spec['cw'] = xr.DataArray(cw, **dakwargs)
            spec['ccw'] = xr.DataArray(ccw, **dakwargs)

            if debug:
                dcpy.ts.PlotSpectrum(Tsub, axes[season], twoside=False,
                                     preserve_area=True,
                                     ,**kwargs)
                axes[season].set_title(season)

            # spec = xr.DataArray(S, dims=['freq'], coords={'freq': freq})
            # integrate_spectrum(spec.cw, 0.9*inertial, 1.2*inertial)

            Eiw[moor.name][season] = (integrate_spectrum(spec.cw + spec.ccw,
                                                         0.9*inertial,
                                                         1/1200*86400))
            Eniw[moor.name][season] = (
                integrate_spectrum(spec.cw, 0.9*inertial, 1.2*inertial))
            Em2[moor.name][season] = (integrate_spectrum(spec.cw+spec.ccw,
                                                         0.9*tides['M2'],
                                                         1.1*tides['M2']))
            Ek1[moor.name][season] = (integrate_spectrum(spec.cw+spec.ccw,
                                                         0.9*tides['K1'],
                                                         1.1*tides['K1']))

        if debug:
            dcpy.plots.linex([0.9*inertial, 1.2*inertial,
                              0.9*tides['M2'], 1.1*tides['M2'],
                              0.9*tides['K1'], 1.1*tides['K1']],
                             ax=ax.ravel())
            [aa.set_xlabel('') for aa in ax[0, :]]
            [aa.set_ylabel('') for aa in ax[:, 1]]
            [aa.set_xlabel('Freq (cpd)') for aa in ax[1, :]]
            [aa.set_ylim([0, 0.013]) for aa in ax.flat]

            f.savefig('images/rotary-vel-spectra-'+moor.name+'.png',
                      bbox_inches='tight', transparent=False)

axall[0].set_ylim(axall[1].get_ylim())
axall[1].legend(['NRL1', 'NRL3', 'NRL4', 'NRL5'])
fall.savefig('images/rotary-vel-spectra-NRL.png', bbox_inches='tight',
             transparent=False)
#+END_SRC
#+CAPTION: Seasonal area/variance-preserving two-sided spectra of velocity at 100m for NRL1,3,4,5.
[[file:images/rotary-vel-spectra-NRL.png]]

[[file:images/rotary-vel-spectra-NRL1.png]]
[[file:images/rotary-vel-spectra-NRL3.png]]
[[file:images/rotary-vel-spectra-NRL4.png]]
[[file:images/rotary-vel-spectra-NRL5.png]]

#+BEGIN_SRC ipython :session :ipyfile images/temperature-seasonal-variance.png
f, ax = plt.subplots(1, 3)
sns.heatmap(Eiw*1e3, ax=ax[0], robust=True, annot=True, linecolor='w', linewidths=3,
            cmap=mpl.cm.Reds, fmt='.2f')
ax[0].set_title('internal wave band')

sns.heatmap(Eniw*1e3, ax=ax[1], robust=True, annot=True, linecolor='w', linewidths=3,
            cmap=mpl.cm.Reds, fmt='.2f')
ax[1].set_title('NIW band')

sns.heatmap(Em2*1e3, ax=ax[2], robust=True, annot=True, linecolor='w', linewidths=3,
            cmap=mpl.cm.Reds, fmt='.2f')
ax[2].set_title('M2 band')

f.suptitle('Temperature variance at 200m')
f.set_size_inches(16, 5)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[475]:
:END:

** Seasonal cycle in M_2 tide!
There is a seasonal cycle in M2. There are also prominent tidal harmonics = nonlinear tide?

There is a more prominent seasonal cycle in the K1 tide too?

Most of these KT are contaminated by instrument moving down in the water column :(

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl1.png
nrl1.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[171]:
[[file:images/seasonal-nrl1.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl2.png
nrl2.plot_spectrogram()
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl3.png
nrl3.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[176]:
[[file:images/seasonal-nrl3.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl4.png
nrl4.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[175]:
[[file:images/seasonal-nrl4.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl5.png
nrl5.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[174]:
[[file:images/seasonal-nrl5.png]]
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgdYM4bm.png
dt = 10/24/60
kwargs = dict(dim='time', dt=dt, window=25/dt, shift=5/dt)

spec = dcpy.ts.Spectrogram(self.ctd['T'].sel(depth2=150), **kwargs)
np.log10(spec).plot(robust=True, x='time')
plt.gca().set_yscale('log')

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[157]:
:END:


#+begin_SRC ipython :session :ipyfile images/temp/imgoi5WUg.png
spec = dcpy.ts.Spectrogram(ra15.vel.spd.interpolate_na(dim='time').squeeze(),
                           dim='time',
                           window=(7*86400)/(30*60),
                           shift=(3.5*86400)/(30*60), nsmooth=15)
np.log10(spec).plot.contourf(x='time', levels=40);
plt.gca().set_yscale('log')
#+END_SRC

#+RESULTS:
** Seasonal cycle in near-inertial waves?
*** NIW input u⋅τ using Alford (2003) spectral solution
**** double check with in-situ data : looks OK
Doing for RAMA12 and topmost bin from NRL5.

From a quick check; merra2 does better for nrl5, but ncep does better for RAMA?

#+BEGIN_SRC ipython :session :results none
def compare_fluxes(mooring, input_file='merra2'):

    # 1/1.25, 1.25 taken from Alford (2003)
    freqs = np.array([1/1.25, 1.25]) * mooring.inertial.values

    def filt(comp, freqs=freqs):
        dt = (comp.time.diff('time').mean()
             .values.astype('timedelta64[m]').astype('float32'))
        ufilt = dcpy.ts.BandPassButter(np.real(comp),
                                       dim='time',
                                       freqs=freqs,
                                       dt=dt/24/60)
        vfilt = dcpy.ts.BandPassButter(np.imag(comp),
                                       dim='time',
                                       freqs=freqs,
                                       dt=dt/24/60)

        return (ufilt + 1j*vfilt)

    # choose ML velocity: pick topmost bin
    ZI = (filt((mooring.vel.u.isel(depth=0).squeeze().interpolate_na('time')
               + 1j * mooring.vel.v.isel(depth=0).squeeze().interpolate_na('time')))
          .sel(time='2014'))

    # choose wind-stress
    if 'taux' in mooring.met:
        T = (mooring.met.taux + 1j * mooring.met.tauy)
    else:
        T = (mooring.tropflux.taux + 1j * mooring.tropflux.tauy)

    T = 1/1025 * (T.interp_like(ZI).interpolate_na('time')
                  .sel(time='2014')
                  .rolling(time=12).mean().dropna('time'))

    # calculate flux
    flux = np.real(1025 * ZI * np.conj(T))

    # if np.isnan(mooring.mld).all():
    #     mld = (mimoc.DEPTH_MIXED_LAYER
    #            .interp(lon=mooring.lon, lat=mooring.lat).load()
    #            .interp(time=T.time))
    # else:
    #     mld = mooring.mld.interp(time=T.time).rolling(time=300).mean()

    # model_input, ZImodel = dcpy.oceans.calc_wind_power_input(
    #     (T * 1025),
    #     mld=mld,
    #     f0=dcpy.oceans.coriolis(mooring.lat))

    wind_input = (
        xr.open_dataset(
            '/home/deepak/bay/estimates/' + input_file
            + '-wind-power-input-2014.nc')
        .sel(lat=mooring.lat, lon=mooring.lon, method='nearest')
        .sel(time='2014')
        .load())
    model_input = wind_input.wind_input
    ZImodel = wind_input.ui + 1j * wind_input.vi
    # ZIfilt = filt(ZImodel.dropna('time'))
    # filt_input = np.real(1025 * ZIfilt * np.conj(T))

    f, ax = plt.subplots(2, 2, sharex='col', constrained_layout=True,
                         gridspec_kw={'width_ratios': [2, 1]})
    np.real(ZImodel).plot(ax=ax[0, 0], lw=0.5)
    np.real(ZI).plot(ax=ax[0, 0])
    # ZIfilt.plot(ax=ax[0, 0], color='k')
    ax[0, 0].legend(['slab model', 'true'])

    model_input.plot(ax=ax[1, 0])
    flux.plot(ax=ax[1, 0])
    # filt_input.plot(ax=ax[1, 0], color='k')
    ax[1, 0].legend(['slab flux', 'true flux'])

    dcpy.ts.PlotSpectrum(ZI.dropna('time'), twoside=False, ax=ax[0, 1])
    dcpy.ts.PlotSpectrum(ZImodel.dropna('time'), twoside=False, ax=ax[0, 1])
    ax[0, 1].legend(['true cw', 'true ccw', 'filt model cw', 'filt model ccw'])

    dcpy.ts.PlotSpectrum(model_input.dropna('time'), ax=ax[1, 1])
    dcpy.ts.PlotSpectrum(flux.dropna('time'), ax=ax[1, 1])
    # dcpy.ts.PlotSpectrum(filt_input.dropna('time'), ax=ax[1, 1], color='k')
    ax[1, 1].legend(['slab model flux', 'true flux'])
    dcpy.plots.linex(freqs, ax=ax[:, 1])
    dcpy.plots.linex(mooring.inertial, ax=ax[:, 1])

    ax2 = ax[1, 0].twinx()
    ax[1, 0].spines['right'].set_visible(True)
    ax2.set_ylabel('cumulative input')
    dt_true = (np.diff(flux.time)
               .astype('timedelta64[s]').astype('float32')
               .mean())
    dt_mod = (np.diff(model_input.time)
              .astype('timedelta64[s]').astype('float32')
              .mean())
    ax2.plot(model_input.time, np.cumsum(model_input) * dt_mod)
    ax2.plot(flux.time, np.cumsum(flux) * dt_true)
    ylim = ax2.get_ylim()
    ax2.set_ylim([0, ylim[1]*2])

    ax[1, 1].set_ylim([1e-7, 5e-3])
    ax[1, 0].set_ylim([-0.05, 0.05])
    ax[0, 0].set_ylim([-0.3, 0.3])
    ax[1, 0].set_xlim(('2014-01-01', '2015-01-01'))
    ax[0, 1].set_title('Spectra of currents')
    ax[1, 1].set_title('Spectra of flux')
    f.suptitle(mooring.name + ' | ' + input_file
               + 'wind power input comparison | data vs model.')

for input_file in ['merra2', 'ncep']:
    compare_fluxes(ra12, input_file)
    plt.savefig('images/niw-input-' + input_file + '-ra12-check.png')

    nrl5.vel['time'] = nrl5.vel.time.dt.round('H')
    nrl5.tropflux['time'] = nrl5.tropflux.time.dt.round('D')
    compare_fluxes(nrl5, input_file)
    plt.savefig('images/niw-input-'+ input_file + '-nrl5-check.png')
#+END_SRC

#+CAPTION: RAMA12 *with local winds*: Agreement between flux calculated using filtered currents (0.5f - 1.5f) and predicted *using local winds* is good. No tuning required! The black should agree with orange. Black is (0.5f - 1.5f) filtered version of blue. There's a lot of high frequency information in the solution (local winds) that makes the blue look worse but it really isn't.
[[file:images/niw-input-ra12-local-winds-check.png]]

#+CAPTION: Same as above *with NCEP winds*
[[file:images/niw-input-ra12-check.png]]

#+CAPTION: Same as above for NRL5. Agreement isn't as good. One funny thing is that there's a lot more clockwise energy in the near-inertial band here. Not sure if that's the discrepancy though cite:Plueddemann2006 seem to think it could make a file.
[[file:images/niw-input-nrl5-check.png]]

**** Basin-wide estimate
#+BEGIN_SRC ipython :session
import cartopy.crs as ccrs

def plot_input(wind_input, windstr):

    niw = wind_input.groupby(wind_input.time.monsoon.labels).mean('time')
    f = plt.figure(constrained_layout=False)

    gs = f.add_gridspec(2, 5, height_ratios=[2.5, 1])

    ax = dict()
    for ss, seas in enumerate(['NE', '2014-03', '2014-04', 'SW', 'SWNE']):
        ax[seas] = f.add_subplot(gs[0, ss], projection=ccrs.PlateCarree())
        bay.plot_coastline(ax[seas])
        ax[seas].set_xticks(np.arange(80, 96, 5))
        ax[seas].set_yticks(np.arange(4, 24, 3))
        ax[seas].set_ylim([4, 24])
        ax[seas].set_xlim([80, 95])

        if '2014' in seas:
            hniw = ((wind_input.wind_input*1000).sel(time=seas).mean('time')
                    .plot(cmap=mpl.cm.GnBu,
                          levels=np.arange(0, 1.2, 0.05), add_colorbar=False,
                          ax=ax[seas]))

        else:
            hniw = ((niw.wind_input*1000).sel(monsoon=seas)
                    .plot(cmap=mpl.cm.GnBu,
                          levels=np.arange(0, 1.2, 0.05), add_colorbar=False,
                          ax=ax[seas]))
        ax[seas].text(0.05, 0.9, seas, transform=ax[seas].transAxes)
        ax[seas].set_title('')
        ax[seas].set_ylabel('')
        ax[seas].set_xlabel('')

        if ss > 0:
            [tt.set_visible(False) for tt in ax[seas].get_yticklabels()]

    f.colorbar(hniw, ax=list(ax.values()), orientation='horizontal',
               label=windstr+' near-inertial energy flux $Π$ [mW/m²]', shrink=0.6)

    for ii, ll in zip([1, 1, 1], [8, 18]):
        ax['ts'+str(ii)] = f.add_subplot(gs[ii, :])
        axii = ax['ts'+str(ii)]
        if isinstance(ll, slice):
            processed_input = (
                xrsp.integrate.trapz(np.cumsum(wind_input.wind_input
                                               .sel(lon=87, method='nearest')
                                               .sel(lat=ll),
                                               axis=0)*86400*100e3, 'lat'))
        else:
            processed_input = (
                np.cumsum(wind_input.wind_input
                          .sel(lon=87, lat=ll, method='nearest'),
                          axis=0)*86400)

        hh = processed_input.plot.line(x='time', ax=axii, add_legend=False)
        hh[0].set_clip_on(False)
        dcpy.plots.annotate_end(hh[0], str(ll)+'N')

        axii.set_xlim(['2013-12', '2014-12-01'])
        axii.set_xlabel('')
        axii.set_title('')
        axii.set_ylabel('')

    axii.set_ylim([0, 3e4])
    [tt.set_rotation(0) for tt in ax['ts1'].get_xticklabels()]
    ax['ts1'].text(0.5, 0.1, 'Cumulative near-inertial energy input along 87E',
                   transform=ax['ts1'].transAxes)
    f.savefig('images/wind-input-' + windstr + '-map-ts.png',
              bbox_inches='tight')

merra2 = xr.open_dataset('~/bay/estimates/merra2-wind-power-input-2014.nc')
ncep = xr.open_dataset('~/bay/estimates/ncep-wind-power-input-2014.nc')
plot_input(merra2, 'MERRA-2')
plot_input(ncep, 'NCEP')
#+END_SRC
#+CAPTION: MERRA-2: Split NESW to Mar, Apr so we can see that the Northern Bay is a little different. The southern Bay really sees winds die down but there are steady up-coast winds north of 13N (I've checked this with tropflux)
[[file:images/wind-input-MERRA-2-map-ts.png]]

#+CAPTION: Above but with NCEP (scales are same)
[[file:images/wind-input-NCEP-map-ts.png]]

#+BEGIN_SRC ipython :session :results none

wind_input = xr.open_dataset('~/bay/estimates/wind-power-input-2014.nc')

monthly = wind_input.wind_input.groupby('time.month').mean('time')
g = (monthly*1000).plot(col='month', col_wrap=4, robust=True,
                        add_colorbar=False)
g.add_colorbar(label='Monthly average near-inertial power input [mW/m²]')
g.fig.savefig('images/niw-input-monthly.png', bbox_inches='tight')

f, ax = plt.subplots(2, 1, constrained_layout=True)
((wind_input.wind_input*1000).mean('lon').dropna('lat', how='all')
 .plot(x='time', robust=True, ax=ax[0]))
ax[0].set_title('Longitudinally-averaged wind-input [mW/m²]')
ax[0].set_xlabel('')
ax[0].set_xlim(['2014-01-01', '2014-12-31'])
[tt.set_rotation(0) for tt in ax[0].xaxis.get_ticklabels()]
[tt.set_ha('center') for tt in ax[0].xaxis.get_ticklabels()]

((monthly*1000).mean('lon').dropna('lat')
 .plot(x='month', robust=True, vmin=0, ax=ax[1], cmap=mpl.cm.Reds))
ax[1].set_title('Longitudinally-averaged monthly-mean wind-input [mW/m²]')

f.savefig('images/niw-input-lon-mean.png')
#+END_SRC
#+CAPTION: Monthly mean near-inertial wave input. These values seem low currently. :( I've used MIMOC MLD (Argo MLD has some gaps) and Tropflux winds. For about half the year, there's very little wind input north of 10N!
[[file:images/niw-input-monthly.png]]


#+CAPTION: Average the above in lon. This is cool, because near-inertial waves only propagate equatorward. That means if the wind input is limited to < 10N, as it is, most of the Bay should see little inertial energy. i.e. our 8N χpods should be seeing high mixing relative to the rest of the Bay.
[[file:images/niw-input-lon-mean.png]]

**** Save all direct mooring estimates
#+BEGIN_SRC ipython :session
# [ra12, ra15, nrl1, nrl2, nrl3, nrl4, nrl5] = bay.read_all_moorings()

flux = []
for mooring in [ra12, ra15, nrl1, nrl2, nrl3, nrl4, nrl5]:
    flux.append(
        mooring.niw.true_flux.interp(
            time=pd.date_range(mooring.niw.time[0].dt.round('H').values,
                               mooring.niw.time[-1].dt.round('H').values,
                               freq='H')))

for ii, ff in enumerate(flux):
    if 'longitude' in ff.coords:
        flux[ii] = flux[ii].rename({'longitude': 'lon', 'latitude': 'lat'})

    if 'depth' in ff.coords:
        flux[ii] = flux[ii].drop('depth')

    try:
        flux[ii] = flux[ii].expand_dims(['lon', 'lat'])
    except ValueError:
        pass

flux_merged = xr.merge(flux)
flux_merged.to_netcdf('../estimates/mooring-near-inertial-input.nc')
#+END_SRC
**** old crap: need near-inertial current!                      :noexport:
****
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgCv7Gly.png
taux = xr.open_mfdataset('../datasets/tropflux/taux_tropflux_1d_*.nc')
tauy = xr.open_mfdataset('../datasets/tropflux/tauy_tropflux_1d*.nc')
tau = (xr.merge([taux, tauy])
       .rename({'latitude': 'lat', 'longitude': 'lon'})
       .sel(**bay.region).sel(time='2014')).load()

oscar = (xr.open_mfdataset('/home/deepak/work/datasets/oscar/oscar_vel*.nc',
                          drop_variables=['year'])
         .squeeze()
         .rename({'latitude': 'lat', 'longitude': 'lon'})
         .sel(lon=slice(80, 94), lat=slice(24, 4)).sel(time='2014')).load()

oscar_1deg = (oscar
              .rolling(lat=3, center=True).mean(dim='lat')
              .sel(lat=slice(None, None, 3))
              .rolling(lon=3, center=True).mean(dim='lon')
              .sel(lon=slice(None, None, 3)))

oscari = oscar_1deg.interp_like(tau)
windinput = oscari.u * tau.taux + oscari.v * tau.tauy

windinput.attrs['long_name'] = 'near-inertial wind input'

monthly_windinput = windinput.resample(time='M').mean(dim='time').compute()
monthly_windinput.attrs = windinput.attrs

g = monthly_windinput.plot(col='time', col_wrap=4, robust=True,
                           add_colorbar=False)
g.map(bay.mark_moors)
g.add_colorbar()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[660]:
: <xarray.plot.facetgrid.FacetGrid at 0x7f9d1b4cc860>
:END:
*** NIW as fraction of total shear variance
#+BEGIN_SRC ipython :session
if 'nrl3' not in locals():
    nrl3 = bay.read_nrl3()

if 'nrl4' not in locals():
    nrl4 = bay.read_nrl4()

if 'nrl5' not in locals():
    nrl5 = bay.read_nrl5()

nrl5.plot_niw_fraction()
f.savefig('images/niw-fraction-nrl5.png')

nrl3.plot_niw_fraction()
f.savefig('images/niw-fraction-nrl5.png')

nrl4.plot_niw_fraction()
f.savefig('images/niw-fraction-nrl5.png')
#+END_SRC
#+CAPTION: Rolling 4 day variances of shear, KE. Near-inertial component estimated by bandpass filtering.
[[file:images/niw-fraction-nrl3.png]]
[[file:images/niw-fraction-nrl4.png]]
[[file:images/niw-fraction-nrl5.png]]

*** Seasonal cycle of Ri at EBOB?
#+BEGIN_SRC ipython :session :ipyfile images/nrl5-Ri.png
N2 = nrl5.N2.isel(depth=1)

z = (nrl5.zχpod.isel(num=1)
     .interp(time=nrl5.vel.time)
     .dropna(dim='time')
     .drop('num'))

S2 = (nrl5.vel.shear.interp(time=z.time, depth_shear=z)**2)

f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True)
(S2/4).plot(ax=ax[0], label='$S^2/4$')
N2.plot(ax=ax[0], yscale='log', label='$N^2$')
plt.gca().set_ylabel('')
ax[0].legend()

((N2/S2).resample(time='D').mean()
 .plot(yscale='log', ax=ax[1], ylim=[1, 100]))
ax[1].set_ylabel('Ri')
ax[1].grid(True)

(nrl5.KT.resample(time='D').mean(dim='time')
 .plot.line(x='time', yscale='log', ax=ax[2]))
ax[2].grid(True)

#+END_SRC
[[file:images/nrl5-Ri.png]]


Argo N2 agrees with NRL5, so I'm not doing something insane
#+BEGIN_SRC ipython :session :ipyfile images/temp/img9hBMIK.png
argo = dcpy.oceans.read_argo_clim()
argo_nrl5 = argo.sel(lat=nrl5.lat, lon=nrl5.lon, method='nearest').load()
argo_nrl5['rho'] = argo_nrl5.S.copy(data=sw.pden(argo_nrl5.S,
                                                 argo_nrl5['T'],
                                                 argo_nrl5.pres))
argo_nrl5['N2'] = 10/1025 * argo_nrl5.rho.differentiate('pres')
argo_nrl5_clim = argo_nrl5.groupby('time.month').mean(dim='time')
#+END_SRC
*** NIW energy at moorings :noexport:

OLD stuff
#+BEGIN_SRC ipython :session :ipyfile images/seasonal-niw-nrl.png
import bay

if 'nrl1' not in locals():
    nrl1 = bay.read_nrl1()

def depth_average(da, depth_range):
    import xrscipy as xrsp
    return (xrsp.integrate.trapz(da.sel(depth=depth_range),
                                 coord='depth'))

f, ax = plt.subplots(2, 2, constrained_layout=True)

for idx, moor in enumerate([nrl1, nrl3, nrl4, nrl5]):
    aa = ax.flat[idx]
    top = depth_average(moor.niw.KE, slice(0, 40))
    bottom = depth_average(moor.niw.KE, slice(40, None))

    def plot_monthly_average(da):
        mean = da.groupby('time.month').mean(dim='time')
        std = da.groupby('time.month').std(dim='time')

        norm = mean.max()
        (mean/norm).plot(yerr=std/norm/np.sqrt(2), ax=aa)

    plot_monthly_average(top)
    plot_monthly_average(bottom)
    aa.set_title(moor.name)
    f.legend(['0-40m', 'below 40m'], loc='outside')
    f.suptitle('Normalized seasonal mean depth integrated NIW KE + std')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[290]:
[[file:images/seasonal-niw-nrl.png]]
:END:
:END:
*** Ewa NIW @ NRL processing :noexport:
#+NAME: read-ewa
#+BEGIN_SRC ipython :session :results none
for fname in ['NRL1', 'NRL3', 'NRL4', 'NRL5']:

    nn = sp.io.loadmat('../datasets/ewa/' + fname + 'cxdm_out.mat', squeeze_me=True)

    time = dcpy.util.datenum2datetime(nn['date_time'])
    nrl = xr.Dataset()
    nrl['amp'] = xr.DataArray(nn['CA'].T/100,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['amp'].attrs['long_name'] = 'Clockwise amplitude'
    nrl['amp'].attrs['units'] = 'm/s'

    nrl['pha'] = xr.DataArray(nn['Cp'].T,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['pha'].attrs['long_name'] = 'Clockwise phase'
    nrl['pha'].attrs['units'] = 'rad'

    nrl['KE'] = xr.DataArray(nn['CKE'].T,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['KE'].attrs['long_name'] = 'Clockwise KE'
    nrl['KE'].attrs['units'] = 'J/m³'

    nrl.attrs['name'] = fname

    nrl.to_netcdf('../datasets/ewa/'+fname+'.nc')
#+END_SRC

#+NAME: plot-niw
#+BEGIN_SRC ipython :session :results none
def plot_ewa_niw(nrl):
    import cmocean

    kwargs = dict(robust=True, yincrease=False, cmap=mpl.cm.Reds)

    f, ax = plt.subplots(3, 1, sharex=True, sharey=True)

    nrl.amp.plot(ax=ax[0], **kwargs)
    nrl.pha.plot(ax=ax[1], robust=True, cmap=cmocean.cm.phase, yincrease=False, center=0)
    nrl.KE.plot(ax=ax[2], **kwargs)

    f.suptitle(nrl.name, y=0.91)
    ax[0].set_xlabel('')
    ax[1].set_xlabel('')


for nn in ['NRL1', 'NRL3', 'NRL4', 'NRL5']:
    nrl = xr.open_dataset('../datasets/ewa/' + nn + '.nc').load()
    plot_ewa_niw(nrl)
    plt.savefig('../images/niw-' + nn + '.png', bbox_inches='tight')


#+END_SRC
** Wavelets vs spectrograms
Wavelets need a good understanding of wavelet choice.

variance-preserving spectrogram seems a good way to go.

*** spectrogram to recover wijesekara et al (2016) wavelet

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgx9o72o.png
# da = nrl3.vel.u.sel(depth=120, method='nearest')

# spec = dcpy.ts.Spectrogram(da, nfft=24*60, shift=1*24,
#                            dt=1/24, multitaper=True)

plt.figure(constrained_layout=True)
hdl = (spec*spec.freq).plot.contourf(yscale='log', x='time', robust=True,
                                     levels=30, cmap=svc.cm.red_1)

ax = plt.gca()
ax2 = ax
ax2.yaxis.set_tick_params(which='both', left=True, right=True,
                          labelleft=True, labelright=True)
ax2.spines['right'].set_visible(True)

# ax2.xaxis.set_tick_params(top=False, bottom=False,
#                           labeltop=False, labelbottom=False)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[409]:
:END:

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgw7sScw.png

wz = (
(nrl3.vel.uz + 1j * nrl3.vel.vz)
      .sel(depth_shear=120, method='nearest'))

spec = dcpy.ts.PlotSpectrogram(wz, nfft=60*24, shift=3*24, dt=1/24)
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgz8e7q3.png
import tfr

frames = tfr.SignalFrames(da.values, sample_rate=1/24,
                          frame_size=24*60, hop_size=1*24)
spec = tfr.Spectrogram(frames)

spec = tfr.reassigned_spectrogram(frames, magnitudes='power')


#+END_SRC
*** test jwavelet
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgJWY9H3.png
time = np.arange(1000)
a = np.sin(2*np.pi/20*time)

da = xr.DataArray(a, dims=['time'], coords={'time': time})

da = ra12.vel.u.squeeze().interpolate_na(dim='time').dropna(dim='time')
wt = dcpy.ts.matlab_wavelet(da, dt=60/1440, kind='jlab', eng=eng, beta=10.0)

plt.figure()
np.log10(wt.power).plot.contourf(levels=20, x=dim, yincrease=False, yscale='log',
                                 robust=True, cmap=svc.cm.blue_orange_div)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[887]:
: <matplotlib.contour.QuadContourSet at 0x7f178d87c470>
:END:

*** Seasonal cycle summary : wavelets

#+BEGIN_SRC ipython :session :results none
for m in [nrl1, nrl3, nrl4, nrl5]:
    m.plot_turb_wavelet()
    plt.savefig('images/wavelet-'+m.name+'.png')

#+END_SRC

** test complex demod
I'm not sure this works for near-inertial frequencies. f_0 can change throughout the year and so there'll be phase differences and the near-inertial input won't look right. Probably makes more sense for M_2 and tidal lines.

#+BEGIN_SRC ipython :session :ipyfile images/complex-demod-ewa-mine.png
z = 100

u = nrl5.vel.u.sel(depth=z, method='nearest').interpolate_na(dim='time')
v = nrl5.vel.v.sel(depth=z, method='nearest').interpolate_na(dim='time')

dm = dcpy.ts.complex_demodulate(u + 1j * v,
                                dim='time',
                                central_period=1/nrl5.inertial,
                                cycles_per='D', bw=0.3, filt='butter',
                                debug=True)

ewa = (nrl5.niw.amp.sel(depth=z, method='nearest')
       ,* np.exp(1j * nrl5.niw.pha.sel(depth=z, method='nearest')))

f, ax = plt.subplots(2, 2)
np.abs(dm.cw).plot(ax=ax[0, 0])
nrl5.niw.amp.sel(depth=z, method='nearest').plot(ax=ax[0, 0])
ax[0, 0].legend(['mine', 'ewa'])

xr.DataArray((np.angle(dm.cw, deg=False)),
             dims=dm.cw.dims, coords=dm.cw.coords,
).plot(ax=ax[1, 0])
nrl5.niw.pha.sel(depth=z, method='nearest').plot(ax=ax[1, 0])

dm.cw.real.plot(ax=ax[0, 1])
ewa.real.plot(ax=ax[0, 1])
dm.cw.imag.plot(ax=ax[1, 1])
ewa.imag.plot(ax=ax[1, 1])

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[214]:
: [<matplotlib.lines.Line2D at 0x7f7c58aeb780>]
:END:
** Internal tides radiating out from the Andaman Sea :ebob:todo:
Let's use the RAMA 8N mooring to see if there's some seasonality to the internal tide energy being radiated out. It would be good to do this with some NIOT buoy data.

Emily says the best thing to look for is the $w$ field; this is what she did for her thesis stuff. I'm punting this to future work for the EBOB paper.

#+BEGIN_SRC ipython :session :ipyfile images/rama-8n-2m2-3m2.png
def read_pmel(file):
    ds = xr.open_dataset(file, decode_cf=False)
    for var in ds:
        ds[var].attrs['missing_value'] = ds.attrs['missing_value']
        ds[var].attrs['_FillValue'] = ds.attrs['_FillValue']

    return xr.decode_cf(ds)

r8 = (read_pmel('~/TaoTritonPirataRama/high_resolution/10m/t8n90e_10m.cdf')
      .rename({'T_20': 'temp'})
      .squeeze().load())

T = r8.temp.sel(depth=slice(80, 200)).mean('depth')

for ii in [2, 3]:
    bp = dcpy.ts.BandPassButter(T, np.array([1/1.05, 1.05])*24/12.42*ii,
                                dt=1/144, debug=False)
    (bp**2).groupby('time.month').mean('time').plot(label=str(ii)+'$M_2$')
plt.legend()

# port blair sea level
# sl = xr.open_dataset('~/datasets/sealevel/port-blair.nc')
# sl.sea_level.squeeze().plot()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[81]:
: <matplotlib.legend.Legend at 0x7f1c620e2550>
[[file:images/rama-8n-2m2-3m2.png]]
:END:
* Diffusivity scatter plots
Looks like there's some work on scattering $ε$ against $N$ : cite:Gargett1984.

#+BEGIN_SRC ipython :session
f, ax = plt.subplots(1, 2, constrained_layout=True)

freq='3H'
KT = (ra12.KT.sel(depth=15)
      .resample(time=freq).mean('time')
      .sel(time=slice('2013-12', '2014-11'))
      .dropna('time'))
τ = np.sqrt(ra12.met.τ).resample(time=freq).mean('time').interp_like(KT)
# ax[0].hexbin(τ, np.log10(KT), mincnt=1, alpha=0.5)
ax[0].plot(τ, KT, 'o', alpha=0.2, ms=4)
ax[0].set_xlim([0, 0.6])
ax[0].set_title('RAMA 12N 15m | Corr. coef = {0:.2f}'
                .format(np.corrcoef(τ, np.log10(KT))[0, 1]))
ax[0].set_xlabel('τ (3 hr avg.)')
ax[0].set_ylabel('$log_{10} K_T$ (3 hr avg.)')

# ax = plt.axes()

zpod = nrl5.zχpod.interp(time=nrl5.vel.time).dropna('time')
shear = (nrl5.vel.shear
         .interp(time=zpod.time, depth=zpod.isel(num=1))
         .interpolate_na('time'))

ke = 0.5 * np.abs(nrl5.vel.w.sel(depth=slice(100, 150)).mean('depth'))**2

# niw_shear = dcpy.ts.complex_demodulate(nrl5.vel.shear_fit, 1/nrl5.inertial.values)
niw_ke = dcpy.ts.BandPassButter(ke,
                                freqs=np.array([1/2, 2])*nrl5.inertial.values,
                                dt=1/24, debug=False)

niw_shear = dcpy.ts.BandPassButter(shear,
                                   freqs=np.array([1/2, 2])*nrl5.inertial.values,
                                   dt=1/24, debug=False)

KT = (nrl5.KT.isel(depth=1)
      .resample(time='W').mean('time')
      .dropna('time'))
sh = niw_shear.resample(time='D').var().interp(time=KT.time)

nrlτ = nrl5.tropflux.tau.interp(time=nrl5.KT.time).resample(time='W').mean('time')
ax[1].plot(nrlτ, KT, 'o', alpha=0.2, ms=4, color='C1')
ax[1].set_ylabel('Daily mean $K_T$ (log)')
ax[1].set_xlabel('Daily NIW shear variance (log)')

ax[0].set_title('RAMA 12N 15m')
ax[1].set_title('NRL5 105m')

# f, ax = plt.subplots(4, 1, sharex=True)
# ke.resample(time='D').mean('time').plot(ax=ax[0])
# # niw_shear.plot(ax=ax[1])
# (niw_shear).resample(time='D').std('time').plot(ax=ax[1])
# (nrl5.N2.isel(depth=1).resample(time='H').mean('time')
#  .plot.line(ax=ax[2], x='time'))
# (nrl5.KT.resample(time='H').mean('time')
#  .plot.line(ax=ax[-1], yscale='log', x='time'))

# τ = np.sqrt(nrl5.tropflux.tau).resample(time='4D').mean('time').interp_like(KT)
# plt.xcorr(τ, np.log10(KT), detrend=mpl.mlab.detrend_linear)

f.savefig('images/wind-KT-correlations.png')
#+END_SRC
#+CAPTION: Trying scatter plot / correlations. Good results for the 15m instrument @ RAMA 12N. 30m, 45m not so much.
[[file:images/wind-KT-correlations.png]]

** all NRL
#+BEGIN_SRC ipython :session
# slab_file = xr.open_dataset('../estimates/merra2-wind-power-input-2014.nc')

# nrl = turb.where(np.logical_and(turb.lat < 10, turb.lon < 89), drop=True)
# slabflx = slab_file.wind_input.where(
#     np.logical_and(slab_file.lat > 6,
#                    slab_file.lat < 10), drop=True)
# KT = nrl.KT.where(nrl.depth > 30, drop=True)
# KT = KT.where(KT < 0.1)  # nrl4


def avg_shear(ds, time):
    return (np.abs(ds.shear)
            .sel(time=slice(time[0], time[-1])))


def plot_shear_KT_avg(m, mooring, time_interval='2W', loffset='7D'):
    turb = xr.open_dataset('../scripts/bay_merged_hourly.nc')

    adcp = bay.read_adcp(m)

    f0 = adcp['vel'].inertial.values
    lowpass = (adcp['vel'][['uz', 'vz', 'u', 'v']]
               .apply(xfilter.lowpass, coord='time',
                      freq=0.1, cycles_per='D', order=3))

    input_file = xr.open_dataset('../estimates/mooring-near-inertial-input.nc')
    trueflx = (input_file.where(input_file.lat < 10, drop=True)
               .true_flux)

    # avg = (adcp['vel'][['uz', 'vz', 'u', 'v', 'KE']]
    #        .sel(depth=zrange).mean('depth'))
    # avglo = lowpass.sel(depth=zrange).mean('depth')
    # avgni = adcp['niw'].sel(depth=zrange).mean('depth')

    # niw_shear = adcp['niw'][['uz', 'vz']]
    # shear = adcp['vel'][['uz', 'vz']]

    KT = (turb.ε.where(turb.KT < 0.1)
          .sel(**bay.loc[m]).dropna('depth', how='all')
          .isel(depth=1).dropna('time'))
    KT.dc.set_name_units('$K_T$', 'm²/s²')

    KT = (turb.ε.where(turb.KT < 0.1)
          .sel(**bay.loc[m]).dropna('depth', how='all')
          .isel(depth=1).dropna('time'))
    KT.dc.set_name_units('$ε$', 'W/kg')

    # eps = (turb.eps.where(turb.KT < 0.1)
    #        .where(turb.eps > 0)
    #        .sel(**bay.loc[m]).dropna('depth', how='all')
    #        .isel(depth=1).dropna('time'))
    # eps.dc.set_name_units('$ε$', 'W/kg')

    # avgloshear = avg_shear(lowpass, zrange, KT)
    # avgnishear = avg_shear(adcp['niw'], zrange, KT)
    # avgshear = avg_shear(adcp['vel'], zrange, KT)

    uzi = mooring.interp_shear()
    filter_kwargs = dict(cycles_per='D', coord='time', order=3)

    full = xr.Dataset()
    full['shear'] = (uzi.uz.interpolate_na('time')
                     + 1j*uzi.vz.interpolate_na('time'))
    # full['u'] = mooring.vel.u.interp(depth=zpod, time=zpod.time, method='nearest')
    # full['v'] = mooring.vel.v.interp(depth=zpod, time=zpod.time, method='nearest')
    full['u'] = uzi.u
    full['v'] = uzi.v
    full['N2'] = ((mooring.turb.N2).isel(depth=1)
                  .interp(time=uzi.time))
    full = full.interpolate_na('time')

    low = full.apply(xfilter.lowpass, freq=2, **filter_kwargs)
    # high = full.apply(xfilter.bandpass, freq=[0.15, 4], **filter_kwargs)
    niw = full.apply(xfilter.bandpass, freq=[0.15, 0.5], **filter_kwargs)

    avgloshear = avg_shear(low, KT.time)
    # avghishear = avg_shear(high, KT.time)
    avgnishear = avg_shear(niw, KT.time)
    avgshear = avg_shear(full, KT.time)

    # plt.figure();
    # avgloshear.plot()
    # avgnishear.plot()
    # # avgshear.plot()
    # plt.title(m)

    # return

    # rs_monthly = dict(time='M', loffset='-15D')
    rs_interval = dict(time=time_interval, loffset=loffset)

    tlim = KT.time[[0, -1]].values
    KTr = KT.resample(**rs_interval)
    # epsr = eps.resample(**rs_interval)

    f = plt.figure(constrained_layout=True)
    gs = f.add_gridspec(4, 2)
    axx = []
    axx.append(f.add_subplot(gs[0, 0]))
    axx.append(f.add_subplot(gs[1, 0], sharex=axx[0]))
    axx.append(f.add_subplot(gs[2, 0], sharex=axx[0]))
    axx.append(f.add_subplot(gs[3, 0], sharex=axx[0]))
    axx.append(f.add_subplot(gs[:, 1]))
    ax = axx[0]
    ax2 = axx[1]
    ax3 = axx[2]
    ax4 = axx[3]

    hmedian = (KTr.median('time')
               .plot.step(yscale='log', ax=ax))

    hmean = (KTr.mean('time')
             .plot.step(yscale='log', ax=ax))
    dcpy.plots.annotate_end(hmean[0], 'mean')
    dcpy.plots.annotate_end(hmedian[0], 'median')

    hlo = (avgloshear
           .resample(**rs_interval).mean('time')
           .plot(ax=ax2, color='C4', yscale='linear'))

    hni = (avgnishear
           .resample(**rs_interval).mean('time')
           .plot(ax=ax2, color='C3', yscale='linear'))

    htotal = (avgshear
              .resample(**rs_interval).mean('time')
              .plot(ax=ax2, color='C2', yscale='log'))

    hloni = ((avgloshear + avgnishear)
             .resample(**rs_interval).mean('time')
             .plot(ax=ax2, color='C2', yscale='linear', ls='--'))

    dcpy.plots.annotate_end(hlo[0], 'lowpass')
    dcpy.plots.annotate_end(hni[0], 'NIW', va='top')
    dcpy.plots.annotate_end(htotal[0], 'total')
    dcpy.plots.annotate_end(hloni[0], 'lo+niw')

    ax2.set_ylabel('Shear [1/s]')

    (trueflx.sel(**bay.loc[m])
     .resample(**rs_interval).mean('time')
     .plot(ax=ax3))

    ax32 = ax3.twinx()
    (mooring.tropflux.tau
     .resample(**rs_interval).mean('time')
     .plot(ax=ax32, color='k'))
    dcpy.plots.set_axes_color(ax32, 'k', spine='right')

    monthly_flux = (trueflx.sel(**bay.loc[m])
                    .resample(**rs_interval).mean('time'))
    monthly_flux.attrs['long_name'] = 'NI flux'
    (monthly_flux.plot(ax=ax3))

    ax42 = ax4.twinx()
    N2 = (mooring.turb.N2.mean('depth')
          .resample(**rs_interval).mean('time'))
    reduced_shear = (4*N2 - avgshear**2)
    reduced_shear.attrs['long_name'] = '$4N² - S²$ (total)'

    (N2.plot(ax=ax4))
    reduced_shear.plot(ax=ax42, color='C1')
    dcpy.plots.set_axes_color(ax42, color='C1', spine='right')

    # axx[2].semilogy(avgshear.resample(**rs_interval)
    #                 .mean('time').squeeze()
    #                 .interp(time=KTr.median('time').time),
    #                 KTr.median('time'), 'o', color='C2')

    # scattery = epsr.median('time')
    # labely = '$ε$ (median)'

    scattery = KTr.mean('time')
    labely = KT.attrs['long_name'] + ' (mean)'

    scatterx = ((avgloshear)
                .resample(**rs_interval)
                .var('time').squeeze()
                .interp(time=scattery.time))
    labelx = 'lowpass shear (var)'

    # scatterx = reduced_shear.interp(time=scattery.time)
    # labelx = reduced_shear.attrs['long_name']

    mask = ~np.isnan(scatterx) & ~np.isnan(scattery)
    corrcoef = np.corrcoef(np.log10(scatterx).where(mask, drop=True).values,
                           np.log10(scattery).where(mask, drop=True).values)[0, 1]

    axx[-1].loglog(scatterx, scattery, 'o', color='C4')
    axx[-1].grid()
    axx[-1].text(0.05, 0.8, 'C² = '+str('{0:.2f}'.format(corrcoef**2)),
                 transform=axx[-1].transAxes)
    axx[-1].set_xlabel(labelx)
    axx[-1].set_ylabel(labely)

    for aa in (axx[:-1] + [ax32, ax42]):
        aa.set_title('')
        aa.set_xlabel('')

    [[tt.set_visible(False) for tt in aa.get_xticklabels()]
     for aa in (axx[:-2] + [ax32, ax42])]

    axx[0].set_title(m.upper() + ' | time interval = ' + time_interval)
    axx[-2].set_xlim(tlim)

    f.set_size_inches((12, 8))
    f.savefig('images/kt-shear-scatter-' + m + '.png')

plot_shear_KT_avg('nrl4', time_interval='2W', mooring=nrl4, loffset='-15D')
plot_shear_KT_avg('nrl5', time_interval='2W', mooring=nrl5, loffset='-15D')

# (KT.sel(lat=8).mean(['lon', 'depth'])
#  .resample(**rs_interval).mean('time')
#  .plot(yscale='log', color='k', ax=ax))

# (slabflx.mean(['lat', 'lon'])
#  .resample(**rs_monthly).mean('time')
#  .plot.step(ax=ax2, color='C1', yscale='log'))

# (np.log10(adcp['vel'].ke.sel(depth=slice(50, 150)).mean('depth')
#          .resample(**rs_monthly).mean('time'))
#  .plot(ax=ax2.twinx(), color='C3'))

# (trueflx.mean(['lat', 'lon'])
#  .resample(**rs_monthly).mean('time')
#  .plot(yscale='log', ax=plt.gca().twinx(), color='C2'))
#+END_SRC

#+CAPTION: NRL4
[[file:images/kt-shear-scatter-nrl4.png]]

#+CAPTION: NRL5
[[file:images/kt-shear-scatter-nrl5.png]]

1. NRL1 doesn't have much of a seasonal cycle
2. NRL4:
   1. Jun15 - Jul15 is outlier: there's shear but not much mixing
   2.
3. NRL5:
   1. Sep-08 - Oct8, high mixing but no shear
   2. Oct 13 - Nov 13 is again outlier: shear but not much mixing


** NRL5
*** Wind stress

wind stress → ML inertial oscillations → near-inertial wave propagates downward → mixes at χpod level

1. 2-3 inertial periods required for energy to go below mixed layer
2. estimate time needed for near inertial waves to propagate down

#+BEGIN_SRC ipython :session
KT = nrl5.turb.KT
tau = nrl5.tropflux.tau
tau.time.values = tau.time.dt.round('D')
tau = tau.interp(time=KT.time)

if 'adcp5' not in locals():
    adcp5 = bay.read_adcp('nrl5')
    uz = adcp5['niw'].uz
    vz = adcp5['niw'].vz
    Uz = np.hypot(uz, vz)

uzsub = uz.sel(depth=slice(80, 120)).mean('depth')
vzsub = vz.sel(depth=slice(80, 120)).mean('depth')
Uzsub = np.hypot(uzsub, vzsub)

mlKE = (0.5*(adcp5['vel'].u**2 + adcp5['vel'].v**2)
        .sel(depth=40, method='nearest'))
KT = (nrl5.KT.isel(depth=1).resample(time='H').mean('time')
      .interpolate_na('time').dropna('time'))
ax = dcpy.ts.PlotCoherence(np.log10(KT), mlKE.interp(time=KT.time),
                           dt=1/24, multitaper=False, nsmooth=30)
dcpy.plots.linex([24/12.42, nrl5.inertial.values], ax=ax)

fulluz = (adcp5['vel'].uz.sel(depth=slice(100, 120)).mean('depth'))
KT = (nrl5.KT.isel(depth=0).resample(time='H').mean('time')
      .interpolate_na('time').dropna('time'))
ax = dcpy.ts.PlotCoherence((KT), fulluz.interp(time=KT.time),
                           dt=1/24, multitaper=False, nsmooth=30)
dcpy.plots.linex([24/12.42, nrl5.inertial.values], ax=ax)


for depth in nrl5.KT.depth:
    dcpy.ts.PlotSpectrum(nrl5.KT.sel(depth=depth).interpolate_na('time')
                         .resample(time='H').mean('time')
                         , ax=plt.gca())

adcp5['niw']['KE'] = 0.5*(adcp5['niw'].u ** 2 + adcp5['niw'].v**2)
f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True,
                     gridspec_kw={'height_ratios': (1, 1, 3)})
nrl5.niw.true_flux.plot(ax=ax[1])
adcp5['niw'].KE.plot(ax=ax[-1], yincrease=False, robust=True)


# fulluz = (adcp5['vel'].uz.sel(depth=slice(60, 120)).mean('depth'))
# KT = (nrl5.KT.isel(depth=0).resample(time='H').mean('time')
#       .interpolate_na('time').dropna('time'))
# ax = dcpy.ts.PlotCoherence((KT), fulluz.interp(time=KT.time),
#                            dt=1/24, multitaper=False, decimate=False)
# dcpy.plots.linex([24/12.42, nrl5.inertial.values], ax=ax)

scatterx = (Uzsub).resample(time='M').var('time')
scattery = (KT.resample(time='M').mean('time'))

f = plt.figure(constrained_layout=True)
gs = mpl.gridspec.GridSpec(2, 2)
ax = list()
ax.append(f.add_subplot(gs[0, 0]))
ax.append(f.add_subplot(gs[1, 0], sharex=ax[0]))
axscatter = f.add_subplot(gs[:, 1])
(Uzsub).resample(time='D').var().plot(ax=ax[0])
(Uzsub).resample(time='W').var().plot(ax=ax[0])
scatterx.plot(ax=ax[0])
KT.resample(time='D').mean().plot.line(x='time', ax=ax[1], yscale='log')
scattery.plot.line(x='time', ax=ax[1], yscale='log')

axscatter.plot(scatterx, (scattery.T), 'o', alpha=0.5)


dcpy.ts.PlotCoherence

# f, ax = plt.subplots(1, 1, constrained_layout=True)

# plt.plot(tau.resample(time='W').mean('time'),
#          np.log10(KT).resample(time='W').mean('time').T,
#          'o')

# f.savefig('images/nrl5-KT-wind.png')
#+END_SRC
#+CAPTION:
[[file:images/nrl5-KT-wind.png]]


*** Ri
#+BEGIN_SRC ipython :session
Rifreq = (Ri.where(Ri < 100).resample(time='D').mean('time'))
KT = (nrl5.KT.where(nrl5.KT > 1e-6).mean('depth')
      .resample(time='D').mean('time')
      .sel(time='2014'))

f, ax = plt.subplots(1, 1, constrained_layout=True)
ax.plot(Rifreq, (KT), 'o', alpha=0.1)
ax.set_ylabel('Daily mean $log_{10} K_T$ [m²/s]')
ax.set_xlabel('Daily mean Ri')
f.savefig('images/nrl5-kt-ri-correlation.png')
#+END_SRC
#+CAPTION:
[[file:images/nrl5-kt-ri-correlation.png
]]


*** low- & high-pass shear variance
#+BEGIN_SRC ipython :session
turb = xr.open_dataset('../estimates/bay_merged_hourly.nc')

mooring = nrl3

filter_kwargs = dict(cycles_per='D', coord='time', order=3)

zpod = (mooring.zχpod.sel(num=2, drop=True)
        .interp(time=mooring.vel.time).dropna('time'))

iz0 = np.digitize(zpod.values, mooring.vel.depth-4) - 1
zbin = xr.DataArray(np.stack([iz0-1, iz0, iz0+1]),
                    dims=['iz', 'time'],
                    coords={'time': zpod.time, 'iz': [-8, 0, 8]})
subset = (mooring.vel[['u', 'v']]
          .sel(depth=mooring.vel.depth[zbin], time=zbin.time)
          .interpolate_na('time'))
subsetz = (subset.differentiate('iz').isel(iz=1, drop=True)
           .rename({'u': 'uz', 'v': 'vz'}))
subsetz['u'] = subset.u.isel(iz=1)
subsetz['v'] = subset.v.isel(iz=1)
subsetz['shear'] = subsetz.uz + 1j * subsetz.vz

uzi = subsetz

# uzi = (mooring.vel[['u', 'v', 'uz', 'vz']]
#        .sel(depth=120, method='nearest'))

full = xr.Dataset()
full['shear'] = uzi.uz.interpolate_na('time') + 1j*uzi.vz.interpolate_na('time')
full['u'] = uzi.u
full['v'] = uzi.v
full['N2'] = ((mooring.turb.N2).isel(depth=1)
              .interp(time=zpod.time))
full['Tz'] = (mooring.turb.Tz.isel(depth=1)
              .interp(time=zpod.time))
full = full.interpolate_na('time')

low = full.apply(xfilter.lowpass, freq=0.15, **filter_kwargs)
loni = full.apply(xfilter.lowpass, freq=4, **filter_kwargs)
high = full.apply(xfilter.bandpass, freq=[0.15, 4], **filter_kwargs)
niw = full.apply(xfilter.bandpass, freq=[0.15, 2.1], **filter_kwargs)

timescale= 'M'
mix = (turb.sel(**bay.loc[mooring.name])
       .dropna('depth', how='all')
       .isel(depth=1))
KTr = mix.KT.dropna('time').resample(time=timescale).mean('time')

epsr = xr.Dataset()
epsr['mean'] = mix.ε.dropna('time').resample(time=timescale).mean('time')
epsr['std'] = mix.ε.dropna('time').resample(time=timescale).std('time')

highr = high.shear.resample(time=timescale).apply(dcpy.util.rms).interp(time=KTr.time)
lowr = low.shear.resample(time=timescale).apply(dcpy.util.rms).interp(time=KTr.time)
lonir = loni.shear.resample(time=timescale).apply(dcpy.util.rms).interp(time=KTr.time)

f, axx = plt.subplots(1, 3, constrained_layout=True, sharey=True)
ax = dict(zip(['loni', 'low', 'high'], axx))


def _plot(ax, e, s):
    months = pd.Series(e.time.values).dt.strftime('%b-%y').values
    ax.errorbar(e['mean'], s**2, xerr=e['std'].values/np.sqrt(30*24),
                fmt='ko')
    for ee, ss, tt in zip(e['mean'], s, months):
        ax.text(ee, ss**2, '   '+tt, va='center', ha='left', fontsize=8)


_plot(ax['low'], epsr, lowr)
_plot(ax['high'], epsr, highr)
_plot(ax['loni'], epsr, lonir)

axx[0].set_ylabel('mean squared shear')
ax['loni'].set_title('(< 0.25d)')
ax['high'].set_title('High pass (> 7d)')
ax['low'].set_title('Low pass (< 7d)')
[aa.set_xscale('log') for aa in axx]
[aa.set_yscale('log') for aa in axx]
[aa.set_xlabel('ε') for aa in axx]

f.suptitle(mooring.name)

f.set_size_inches((12, 6))

f.savefig('images/shear-scatter-' + mooring.name.lower() + '.png')

# f, ax = plt.subplots(1, 2, sharex=False, sharey=True, constrained_layout=True)
# [aa.set_prop_cycle(bay.monsoon_cycler) for aa in ax]

# for season in bay.seasons:
#     dcpy.ts.PlotSpectrum(full.shear.sel(time='2014')
#                          .where(full.time.monsoon.labels == season)
#                          .dropna('time'),
#                          preserve_area=True, twoside=True, ax=ax)

# ax[0].legend(bay.seasons)
#+END_SRC

file:images/shear-scatter-nrl4.png
[[file:images/shear-scatter-nrl5.png]]

* checking inter-mooring variability
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgBRHfA4.png
turb = xr.open_dataset('bay_merged_hourly.nc')

ra = (turb.KT.sel(lon=90)
      .dropna(dim='lat', how='all')
      .dropna(dim='depth', how='all')
      .resample(time='D').mean(dim='time'))

ra.plot.line(x='time', hue='depth', row='lat', yscale='log')
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/ra12-ra15-compare-15m.png
d15 = ra.sel(depth=15)

plt.figure()
for da in [d15.sel(lat=12, time='2014'),
           d15.sel(lat=12, time='2015'),
           d15.sel(lat=15)]:
    plt.plot(da.time.dt.dayofyear, da.values)

plt.gca().set_yscale('log')
plt.legend(['12N, 2014', '12N, 2015', '15N, 2015'])
plt.title('15m χpod')
plt.gcf().set_size_inches((8, 5))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[124]:
[[file:images/ra12-ra15-compare-15m.png]]
:END:

15N, 2015 and 12N, 2014 are quite similar. 12N, 2015 is different mostly because of stratification.
- in 2014, there are a lot of temperature inversions during SW monsoon at 15m; χpod is frequently in barrier layer.
- in 2015, χpod sees basically single-signed gradient nearly all the time.

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgFx1nQF.png

#+END_SRC

* EBoB near-inertial, lowpass climate
** Processing Notes
*** Correcting for ADCP response

cite:Alford2012 corrects for sinc⁴(m) response apparently.
#+BEGIN_QUOTE
The large bin size of the instrument introduces a sinc⁴(m) rolloff of its vertical wavenumber response beginning near scales of 100 m (Alford and Gregg 2001; Polzin et al. 2002). The plotted spectra are corrected for this response.
#+END_QUOTE

cite:Alford2010
#+BEGIN_QUOTE
The ADCP spectrum rolls off at about 80-m scales, consistent with the expected response, sinc4(z_b k), for a Bartlett transmit pulse of length 2z_b (dashed line; Alford and Gregg 2001), where z_b = 16 m. When the ADCP spectrum is corrected for this modeled response (gray line), the falloff is less severe, with noise now apparent as a rise beginning at about k = 0.025 cpm. All quantities are henceforth smoothed to the resolution of the ADCP (80 m) to prevent complications resulting from depth-variable resolution.
#+END_QUOTE

*** WKB scaling
cite:Alford2007
#+BEGIN_QUOTE
Waves propagating vertically through the ocean’s depth-varying stratification undergo refraction, which affects their vertical wavenumber and amplitude. To account for this effect, velocity measurements are typically “WKB scaled” to enable comparison between different stratification environments (e.g., Leaman and Sanford 1976).
#+END_QUOTE

cite:Alford2012:
#+BEGIN_QUOTE
[WKB-scaled depth] Integration is begun at the deepest observed mixed layer depth of 120 m to avoid complications with time-variable mixed layer depth. Above that, stretched and unstretched depths are equal ... quantitative calculations such as the spectrum and vertical group velocity are computed in stretched coordinates.
#+END_QUOTE

#+BEGIN_QUOTE
quantitative calculations such as the spectrum and vertical group velocity are computed in stretched coordinates.
#+END_QUOTE

\begin{equation}
u(z_i) = \frac{u(z_i)}{\sqrt{\bar{N}(z_i)/N_0}}
\end{equation}

cite:Leaman1975 use N_0 = 3 cph like GM. cite:Alford2007 uses climatological $N$ and $N_0$ = depth-mean of that climatological $N$
*** Isopcynal frame

cite:Alford2017
#+BEGIN_QUOTE
This kinematic distortion is removed by transformation to an isopycnal-following or semi-Lagrangian reference frame (Anderson 1993). This is accomplished by selecting a set of isopycnals with constant mean spacing and computing shear along each by linear interpolation.
#+END_QUOTE

*** Inertial backrotation

cite:Alford2017:
#+BEGIN_QUOTE
A complex demodulation technique known as inertial back rotation (D’Asaro et al. 1995) is used next to remove the sense of inertial rotation in time. Backrotated shear has two advantages: first, it allows examination of the persistence or equivalently the time scales of modulation of the envelopes of near-inertial packets; the second is in interpretation of shipboard transects that take large fractions of an inertial period to conduct. Backrotated shear references measured shear to a common time, giving a closer approximation of a spatial snapshot.
#+END_QUOTE

#+BEGIN_QUOTE
Moored backrotated shear (Fig. 13c) removes the sense of phase propagation with depth but gives a sense of the time scale over which particular near-inertial shear features persist as shown above [O(10) days at this location and time] and also provides a key anchor station for comparison with the shipboard sections of backrotated shear (right).
#+END_QUOTE

The cool thing is that you can compute "persistence" by computing the integral timescale of the backrotated shear.
#+BEGIN_QUOTE
A persistence time of O(5) days can be seen at most moorings. MP3 again stands out as qualitatively different than the other locations, with highly persistent features lasting .20 days. This tendency is quantified by calculating the autocovariance of isopycnal shear.
#+END_QUOTE

In cite:Alford2017, the backrotates the full shear and then interpolates to isothermal reference frame.

*** 2D spectra

I think citep:Alford2017 has the ideal procedure:
1. First WKB scale using time-mean stratification profile
2. Then interpolate to isopycnal frame
3. Then calculate spectra
4. Shear spectra calculated by multiply WKB velocity spectra by (2πm)².
5. Separate into up, down components by calculating FFT along depth at each time; use +ve wavenumber = up, -ve wavenumber=down; set appropriate region to zero and then ifft.

citep:Alford2012 calculates 2D spectrum of WKB-scaled velocity and depth!

cite:Alford2017
#+BEGIN_QUOTE
Complex isopycnal-frame velocity w = u_{wkb} + i v_{wkb} is then demeaned and detrended in time and depth. ... The shear spectrum F_{shear}(v, m) can then be computed by multiplying at each frequency by (2πm)².
#+END_QUOTE

Since c_p c_g = (ω/m) (∂ω/∂m) < 0

| +m, -ω, -c_p, +c_g | +m, +ω, +c_p, -c_g |
|------------------+------------------|
| -m, -ω, c_p, -c_g  | -m, +ω, -c_p, +c_g |

This agrees with one of the Pinkel papers.
** Caveats:

1. Here, because temperature sensors are all basically below longranger; I lose a lot of data by mapping to temperature space. So I am restricted to doing things in depth space _to get values at χpod depths_. I can do isothermal space stuff to make general statements about the "thermocline" ≈ 130m and below.

2. There is a O(10m) gap in velocity coverage between the 2 ADCPs. I interpolate over the gap so I can get some bandpass filtered values at χpod depths.

3. NRL5 isothermal space transformation is worse because there is a missing temperature depth for some reason. Need to look that up.

** Results

*** Test plot
#+BEGIN_SRC ipython :session
if 'vel4' not in locals():
    vel4 = bay.adcp.read_adcp('nrl4')

seasonal = (vel4['niw']
            .groupby(vel4['niw'].time.monsoon.labels)
            .mean('time'))

# full near-inertial field
ranges = dict(vmin=-0.05, vmax=0.05)
common_kwargs = dict(x='time', yincrease=False, **ranges,
                     add_colorbar=False, cmap=mpl.cm.RdBu_r)
iso_kwargs = dict(y='mean_depth', levels=20)

f, ax = plt.subplots(2, 2, constrained_layout=True, sharex=True, sharey=True)
filtered.wkbu.plot(ax=ax[0, 0], **common_kwargs)
filtered.wkbv.plot(ax=ax[1, 0], **common_kwargs)
np.real(vel.uz_back).plot.contour(ax=ax[0, 0], levels=20, colors='k')

iso_filtered.wkbu.plot.contourf(ax=ax[0, 1], **iso_kwargs, **common_kwargs)
hdl = iso_filtered.wkbv.plot.contourf(ax=ax[1, 1], **iso_kwargs, **common_kwargs)

plt.colorbar(hdl, ax=ax[1, :], orientation='horizontal', shrink=0.5,
             extend='both', label='WKB scaled velocities [m/s]')

f.savefig('images/nrl4-near-inertial.png')

# compare backrotated full / filtered shear
f, ax = plt.subplots(2, 1, sharex=True, sharey=True, constrained_layout=True)
np.real(vel.uz_back).plot(ax=ax[0], robust=True)
np.real(isoT.uz_back).plot(x='time', y='mean_depth', ax=ax[1], robust=True,
                           yincrease=False)
f.savefig('images/compare-backrotation.png')

# integral time scale


# plot_2dspectrum(np.log10(shear_spec), vmax=2)
plot_2dspectrum((shear_spec), vmax=20, norm=mpl.colors.LogNorm())

niw = spec.sel(freq_time=slice(-1.2 * mooring.inertial, -0.8 * mooring.inertial))
up = (niw.where(niw.freq_wkbz > 0)
      .pipe(xrsp.integrate.trapz('freq_wkbz'))
      .pipe(xrsp.integrate.trapz('freq_time')))
down = (niw.where(niw.freq_wkbz < 0)
        .pipe(xrsp.integrate.trapz('freq_wkbz'))
        .pipe(xrsp.integrate.trapz('freq_time')))

spec = xrft.power_spectrum(wkb.isel(wkbz=50), detrend='linear', window=True)
dcpy.ts.PlotSpectrum(wkb.isel(wkbz=50), twoside=True, cycles_per='s')
ax = plt.gcf().axes
spec.where(spec.freq_time > 0, drop=True).plot(ax=ax[1], zorder=-2)
cw = spec.where(spec.freq_time < 0, drop=True)
cw['freq_time'] = np.abs(cw.freq_time)
cw.plot(ax=ax[0], zorder=-2)

spec
np.log10(spec).plot(robust=True)
#+END_SRC
#+CAPTION:
[[file:images/nrl4-near-inertial.png]]


*** Seasonal KE profiles

#+BEGIN_SRC ipython :session
for mm in range(1, 6):
    m = 'nrl' + str(mm)
    vel = bay.adcp.read_adcp(m)

    subset = vel['niw'][['KE', 'wkbKE']].where(vel['niw'].good_data.values)
    grouped = (subset.groupby(vel['niw'].time.monsoon.labels))
    count = grouped.count('time').KE
    mask = count/count.groupby('monsoon').max('depth') > 0.7
    niw = grouped.mean('time').where(mask.values)

    subset = vel['low'][['KE', 'wkbKE']].where(vel['low'].good_data.values)
    grouped = (subset.groupby(vel['low'].time.monsoon.labels))
    count = grouped.count('time').KE
    mask = count/count.groupby('monsoon').max('depth') > 0.7
    low = grouped.mean('time').where(mask.values)

    f, ax = plt.subplots(1, 4, constrained_layout=True, sharey=True)
    line_kwargs = dict(hue='monsoon', yincrease=False, add_legend=False)
    [aa.set_prop_cycle(bay.monsoon_cycler) for aa in ax]

    low.KE.plot.line(ax=ax[0], y='depth', **line_kwargs)
    hdl = niw.KE.plot.line(ax=ax[1], y='depth', **line_kwargs)

    low.wkbKE.plot.line(ax=ax[2], y='wkbz', **line_kwargs)
    niw.wkbKE.plot.line(ax=ax[3], y='wkbz', **line_kwargs)

    [aa.set_title('') for aa in ax]
    ax[1].legend(handles=hdl, labels=bay.seasons, loc='lower right', ncol=2,
                 title='Seasonal means')
    f.suptitle(niw.name)

    [aa.set_xlim([0, 0.08]) for aa in ax[[1, 3]]]
    [aa.set_xlim([0, 0.3]) for aa in ax[[0, 2]]]

    f.savefig('images/seasonal-mean-KE-profiles-' + m + '.png')
  #+END_SRC
#+CAPTION:
[[file:images/seasonal-mean-KE-profiles-nrl4.png]]


*** NIW input

#+BEGIN_SRC ipython :session
ninput = xr.open_dataset('../estimates/mooring-near-inertial-input.nc')
slab = xr.open_dataset('../estimates/merra2-wind-power-input-2014.nc')
tropflux = xr.open_dataset('../datasets/tropflux/tau_tropflux_1d_2014.nc')

f, ax = plt.subplots(3, 1, constrained_layout=True, sharex=True,
                     gridspec_kw={'height_ratios': (1, 4, 2)})

tau = tropflux.tau.sel(longitude=slice(85.5, 88.5)).mean('longitude')
tau.sel(latitude=slice(5, 8)).mean('latitude').plot(ax=ax[0], color='k')

slab_adjust = dict(zip(['nrl1', 'nrl2', 'nrl3', 'nrl4', 'nrl5'],
                       np.array([0, 0, -4, 0, 0])))

for m, offset in zip(reversed(['nrl1', 'nrl2', 'nrl3', 'nrl4', 'nrl5']),
                     np.array([0, 1, 2, 3, 0]) * 3):
    if m == 'nrl1':
        axis = ax[2]
    else:
        axis = ax[1]

    flux = ninput.true_flux.sel(**bay.loc[m]).dropna('time').sel(time='2014')
    slab_flux = (slab.wind_input.sel(**bay.loc[m], method='nearest')
                 .dropna('time').sel(time='2014'))

    hh = ((xrsp.integrate.cumtrapz(flux, 'time')/1000 + offset)
          .plot(ax=axis, lw=1.2))
    dcpy.plots.annotate_end(hh[0], m.upper())

    (((xrsp.integrate.cumtrapz(slab_flux, 'time')/1000
       + offset + slab_adjust[m]))
     .plot(ax=axis, color=hh[0].get_color(), ls='--'))


def _clean_axes(aa):
    aa.set_xlabel('')
    aa.set_ylabel('')
    aa.set_title('')


[bay.plots.mark_seasons(ax=aa) for aa in ax]
[_clean_axes(aa) for aa in ax]
ax[0].set_xlim(('2014-01', '2015-01-01'))

ax[0].text(0.03, 0.65, 'a) Tropflux daily mean $τ$ [N/m²]',
           transform=ax[0].transAxes)
ax[1].text(0.03, 0.9, 'b) Near-inertial input $\int Π \, dt$ [kJ/m²]',
           transform=ax[1].transAxes)
ax[2].text(0.03, 0.8, 'c) Near-inertial input $\int Π \, dt$ [kJ/m²]',
           transform=ax[2].transAxes)
[tt.set_rotation(0) for tt in ax[-1].xaxis.get_ticklabels()]
[tt.set_ha('center') for tt in ax[-1].xaxis.get_ticklabels()]

f.savefig('images/nrl-niw-input.png')
#+END_SRC
#+CAPTION: Slab vs local estimate
[[file:images/nrl-niw-input.png]]

#+BEGIN_SRC ipython :session
tropflux = xr.merge(
    [xr.open_dataset('../datasets/tropflux/taux_tropflux_1d_2014.nc'),
     xr.open_dataset('../datasets/tropflux/tauy_tropflux_1d_2014.nc')])

tau = ((tropflux.taux + 1j*tropflux.tauy)
       .rename({'latitude': 'lat',
                'longitude': 'lon'})
       .sel(**bay.region)
       .mean(['lon', 'lat']))

f, ax = plt.subplots(1, 2, constrained_layout=True, sharex=True)

dcpy.ts.PlotSpectrum(np.abs(tau), ax=ax[0])
dcpy.ts.PlotSpectrum(tau / np.abs(tau), ax=ax[1], twoside=False)
dcpy.plots.linex(0.264, ax=ax)
f.set_size_inches((7, 3))

f.savefig('images/nrl-wind-spectra.png')
#+END_SRC
#+CAPTION: Spectra of wind stress magnitude and wind stress angle (rotation?). This doesn't seem to work so well.
[[file:images/nrl-wind-spectra.png]]

#+BEGIN_SRC ipython :session
f, ax = plt.subplots(1, 1, constrained_layout=True)

f.savefig('images/slab-model-magnitude-vs-rotation.png')
#+END_SRC
#+CAPTION:
[[file:images/slab-model-magnitude-vs-rotation.png]]


*** 2D seasonal shear spectra

#+BEGIN_SRC ipython :session
adcp = bay.read_adcp('nrl5')

vel = (adcp['vel'].dropna('time', how='all').dropna('depth', how='all')
       .interpolate_na('depth'))

def plot_2dspectrum(da, ax=None, linthreshx=0.1, linscalex=0.05,
                    linthreshy=1e-3, linscaley=0.01, diff=None, **kwargs):

    if ax is None:
        ax = plt.gca()

    spec = xrft.power_spectrum(da, detrend='constant', window=True, )

    if diff:
        spec = spec * (2*np.pi * spec[diff])**2

    spec.plot(norm=mpl.colors.LogNorm(), ax=ax, robust=True, **kwargs)

    ax.set_yscale('symlog', linthreshy=linthreshy, linscaley=linscaley)
    ax.set_xscale('symlog', linthreshx=linthreshx, linscalex=linscalex)


f, ax = plt.subplots(1, 2, constrained_layout=True, sharex=True, sharey=True)
plot_2dspectrum(vel.shear.dropna('depth', how='all'), ax=ax[0])
plot_2dspectrum((vel.u+1j*vel.v).dropna('depth', how='all'),
                ax=ax[1], diff='freq_depth')

f.savefig('images/shear-vs-vel-times-m-spectrum.png')
#+END_SRC
#+CAPTION:
[[file:images/shear-vs-vel-times-m-spectrum.png]]

#+BEGIN_SRC ipython :session
# up- to down-going energy
def plot_2dspectrum(spec, **kwargs):
    hdl = ((spec).plot(cmap=mpl.cm.GnBu_r, robust=True, **kwargs))

    # (spec.plot(norm=mpl.colors.LogNorm(),
    #            cmap=mpl.cm.GnBu_r,
    #            vmin=10**np.percentile(np.log10(spec), 5),
    #            vmax=10**np.percentile(np.log10(spec), 95)))
    dcpy.plots.linex(np.array([-24/12.42, 24/12.42,
                               spec.inertial.values,
                               -spec.inertial.values]),
                     color='k', zorder=10, ax=kwargs['ax'])
    kwargs['ax'].set_yscale('symlog', linthreshy=1e-3, linscaley=0.01)
    kwargs['ax'].set_xscale('symlog', linthreshx=0.1, linscalex=0.05)
    return hdl


def _plot_spec(spec, ax, cmax, vmin, vmax):
    hdl = plot_2dspectrum(spec, norm=mpl.colors.LogNorm(),
                          ax=ax[0], add_colorbar=False,
                          vmin=vmin, vmax=vmax)

    levels = np.logspace(np.log10(vmax), cmax, 5)
    (spec.plot.contour(levels=levels, colors='k', ax=ax[0]))

    f0 = spec.inertial.values
    lo = spec.attrs['niw_lo']
    hi = spec.attrs['niw_hi']

    niw_band = np.logical_and(spec.freq_time < -lo * f0,
                              spec.freq_time > -hi * f0)
    intspec = xrsp.integrate.trapz(spec.where(niw_band, drop=True)
                                   .reset_coords(drop=True),
                                   'freq_time')
    intspec.plot(y='freq_wkbz', xscale='linear', ax=ax[1])

    return hdl


def plot_seasonal_spectrum(w, nsmooth=5):

    f, axx = plt.subplots(4, 4, sharex='col', sharey=True,
                          constrained_layout=True,
                          gridspec_kw={'width_ratios': (4, 1, 4, 1)})
    f.set_size_inches(14, 8)

    ax = dict()
    ax_int = dict()
    ax['shear'] = dict(zip(bay.seasons, axx[:, 0]))
    ax_int['shear'] = dict(zip(bay.seasons, axx[:, 1]))

    ax['vel'] = dict(zip(bay.seasons, axx[:, 2]))
    ax_int['vel'] = dict(zip(bay.seasons, axx[:, 3]))

    grouped = w.groupby(w.time.monsoon.labels)

    psdmax = -1
    shear_spec = dict()
    vel_spec = dict()
    for season, grp in grouped:
        # 50m and deeper to avoid mixed layer
        spec = xrft.power_spectrum(grp.sel(wkbz=slice(70, None)),
                                   dim=None, detrend='linear',
                                   window=True)
        spec.coords['inertial'] = w.inertial
        spec.freq_wkbz.attrs['long_name'] = 'm'
        spec.freq_wkbz.attrs['units'] = 'cpm'
        spec.freq_time.values = spec.freq_time * 86400
        spec.freq_time.attrs['long_name'] = 'ω'
        spec.freq_time.attrs['units'] = 'cpd'

        kernel = np.ones([nsmooth, nsmooth])
        spec.values = sp.signal.convolve2d(spec, kernel/kernel.sum(), mode='same')
        vel_spec[season] = spec

        shear_spec[season] = ((2*np.pi * spec.freq_wkbz)**2) * spec
        vel_spec[season].attrs = w.attrs
        shear_spec[season].attrs = w.attrs
        psdmax = max(shear_spec[season].max().values, psdmax)

    vmin = 0.05
    vmax = 10

    f0 = w.inertial.values
    lo = w.attrs['niw_lo']
    hi = w.attrs['niw_hi']

    for season, grp in grouped:
        hdl_shear = _plot_spec(shear_spec[season],
                               [ax['shear'][season], ax_int['shear'][season]],
                               cmax=2, vmin=vmin, vmax=vmax)

        hdl_vel = _plot_spec(vel_spec[season],
                             [ax['vel'][season], ax_int['vel'][season]],
                             cmax=4, vmin=100, vmax=2000)

        ax_int['shear'][season].set_xlim([0, 5])
        # ax_int['vel'][season].set_xlim([0, 5])

        ax['shear'][season].text(0.05, 0.8, season, color='w',
                                 transform=ax['shear'][season].transAxes)

        ax['vel'][season].text(0.05, 0.8, season, color='w',
                               transform=ax['vel'][season].transAxes)

    f.colorbar(hdl_shear, ax=axx[:, 0], orientation='horizontal', extend='both',
               label=w.attrs['name'].upper() + ' WKB shear spectral density'
               + ' $S_s(m, ω)$')

    f.colorbar(hdl_vel, ax=axx[:, 2], orientation='horizontal', extend='both',
               label=w.attrs['name'].upper() + ' WKB vel spectral density'
               + ' $S_v(m, ω)$')

    dcpy.plots.linex(np.array([-lo, -hi]) * f0, ls='--',
                     ax=list(ax['shear'].values())
                     + list(ax['vel'].values()),
                     color='k', zorder=2, lw=2)

    [aa.set_xlabel('') for aa in axx.flat[:-1]]
    [aa.set_title('') for aa in axx.flat]
    [aa.set_ylabel('') for aa in list(ax_int['shear'].values())]
    [aa.set_ylabel('') for aa in list(ax_int['vel'].values())]
    [aa.set_ylabel('') for aa in list(ax['vel'].values())]
    (ax_int['shear']['SWNE']
     .set_xlabel('near-inertial\nshear PSD\n $\int S_s(m,ω) \, dω$'))
    (ax_int['vel']['SWNE']
     .set_xlabel('near-inertial\nvel PSD\n $\int S_v(m,ω) \, dω$'))

    f.savefig('images/seasonal-vel-shear-2d-spectra-' + w.attrs['name'].lower()
              + '.png')

import xrft

for m in range(5):
    adcp = bay.read_adcp('nrl' + str(m+1))
    vel = adcp['vel'].load()
    zi = np.arange(vel.wkbz.min(), vel.wkbz.max(), 8)
    wkb = ((vel.wkbu.interp(wkbz=zi) + 1j * vel.wkbv.interp(wkbz=zi))
           .dropna('wkbz', how='any'))
    wkb.attrs = vel.attrs
    wkb.attrs['niw_lo'] = adcp['niw'].attrs['niw_lo']
    wkb.attrs['niw_hi'] = adcp['niw'].attrs['niw_hi']
    wkb['inertial'] = vel.inertial

    plot_seasonal_spectrum(wkb.sel(time=slice('2013-12-01', '2014-11-30')))
#+END_SRC
#+CAPTION: Depth-time spectra
[[file:images/seasonal-shear-2d-spectra-nrl4.png]]


*** Up- & down NI-filtered data with mixing

#+BEGIN_SRC ipython :session
def plot_up_down_fields(updown):

    ninput = (xr.open_dataset('../estimates/mooring-near-inertial-input.nc')
              .sel(**bay.loc[updown.attrs['mooring']]))

    merra = (xr.open_dataset('../estimates/merra2-wind-power-input-2014.nc')
             .sel(**bay.loc[updown.attrs['mooring']], method='nearest'))

    turb = (xr.open_dataset('../estimates/bay_merged_hourly.nc')
            .sel(**bay.loc[updown.attrs['mooring']])
            .dropna('depth', how='all')
            .dropna('time', how='all'))

    trange = slice(updown.time[0], updown.time[-1])

    tropflux = (xr.open_mfdataset('../datasets/tropflux/tau_tropflux_1d_*.nc')
                .rename({'latitude': 'lat', 'longitude': 'lon'})
                .sel(time=trange))

    f, ax = plt.subplots(4, 1, sharex='col', sharey='row',
                         constrained_layout=True,
                         squeeze=False,
                         gridspec_kw={'height_ratios': (0.5, 1, 1, 0.75)})
    f.set_constrained_layout_pads(h_pad=0/72)
    f.set_size_inches((16, 8))
    hdl = (np.real(updown.down.sel(time=trange))
           .plot(robust=False, vmin=-0.005, vmax=0.005,
                 cmap=mpl.cm.RdBu_r, ax=ax[1, 0], yincrease=False))
    clim = hdl.get_clim()
    np.real(updown.up.sel(time=trange)).plot(
        robust=True, ax=ax[2, 0], vmin=clim[0], vmax=clim[1],
        cmap=mpl.cm.RdBu_r, yincrease=False)

    for aa in ax[1:3, 0]:
        z = turb.z.resample(time='D', loffset='12H').mean('time').load()
        aa.plot(z.time, z.values, color='k')

    (tropflux.sel(**bay.loc[updown.attrs['mooring']], method='nearest')
     .tau.plot(ax=ax[0, 0], color='k'))
    (tropflux.sel(lat=slice(bay.loc[updown.attrs['mooring']]['lat'], 24, 2),
                  lon=slice(85.5, 88.5)).mean('lon')
     .tau.plot.line(x='time', ax=ax[0, 0], color='lightgray', zorder=-1,
                    lw=0.5, add_legend=False))
    ax[0, 0].set_ylabel('τ [N/m²]')
    (turb.KT.resample(time='D').mean('time')
     .plot.line(ax=ax[3, 0], x='time', yscale='log'))

    axin = ax[0, 0].twinx()
    ninput.true_flux.plot(x='time', ax=axin, _labels=False)
    # merra.wind_input.plot(x='time', ax=axin, _labels=False)
    axin.spines['right'].set_visible(True)

    # (((np.abs(updown.down.sel(time=trange))).mean('time'))
    #  .plot(ax=ax[1, 1], y='depth', yincrease=False))
    # (((np.abs(updown.up.sel(time=trange))).mean('time'))
    #  .plot(ax=ax[2, 1], y='depth', yincrease=False))

    ax[1, 0].set_ylim([220, 10])
    ax[2, 0].set_ylim([220, 10])

    [aa.set_xlabel('') for aa in ax[:, 0]]
    # [aa.set_ylabel('') for aa in ax[:, 1]]
    [aa.set_title('') for aa in ax.flat]
    [tt.set_rotation(0) for tt in ax[-1, 0].get_xticklabels()]

    turb.close()
    tropflux.close()
    merra.close()
    ninput.close()


for m in ['nrl1', 'nrl2', 'nrl3', 'nrl4', 'nrl5']:
# for m in ['nrl5']:
    adcp = bay.read_adcp(m)

    updown_shear = bay.adcp.partition_niw_up_down(
        adcp['niw'].shear.dropna('depth', how='all')
        .dropna('time', how='any'))

    plot_up_down_fields(updown_shear.where(adcp['vel'].good_data))
    plt.savefig('images/up-down-niw-shear-' + m + '.png',
                bbox_inches='tight')
#+END_SRC
#+CAPTION:
[[file:images/up-down-niw-shear-nrl5.png]]


*** Seasonal vertical profiles of RMS shear; mean KE

#+BEGIN_SRC ipython :session
split = True
wkb_scale = False

# for mooring in ['nrl1', 'nrl2', 'nrl3', 'nrl4', 'nrl5']:
for mooring in ['nrl4', 'nrl5']:
    adcp = bay.read_adcp(mooring)

    updown_shear = bay.adcp.partition_niw_up_down(
        adcp['niw'].shear.sel(time='2014')
        .dropna('depth', how='all').dropna('time', how='any'))
    updown_vel = bay.adcp.partition_niw_up_down(
        adcp['niw'].w.sel(time='2014')
        .dropna('depth', how='all').dropna('time', how='any'))
    updown_ke = 1/2 * updown_vel.apply(np.abs)**2

    mask = adcp['vel'].good_data
    rms_shear = bay.seasonal_rms(updown_shear.where(mask), split=split)
    mean_ke = bay.seasonal_mean(updown_ke.where(mask), split=split)
    for dd in adcp:
        if dd == 'iso':
            continue
        rms_shear[dd] = bay.seasonal_rms(
            adcp[dd]['shear'].where(mask).dropna('time', how='all'),
            split=split)
        mean_ke[dd] = 0.5 * bay.seasonal_mean(
            (adcp[dd].u**2 + adcp[dd].v**2).where(mask).dropna('time', how='all'),
            split=split)

    rms_shear = rms_shear.rename({'vel': 'total'})
    mean_ke = mean_ke.rename({'vel': 'total'})

    if split:
        wkb = adcp['vel'].wkb_factor_monthly
        wkb = wkb.groupby(wkb.time.monsoon.splitlabels).mean('time')
    else:
        wkb = adcp['vel'].wkb_factor_monthly
        wkb = wkb.groupby(wkb.time.monsoon.labels).mean('time')

    # wkb scale magnitudes
    if wkb_scale:
        rms_shear = rms_shear * np.sqrt(wkb)
        mean_ke = mean_ke * (wkb)

    color_niw = 'C3'
    color_low = 'C4'

    f, axx = plt.subplots(5, 4, sharex='col', sharey=True,
                          constrained_layout=True)
    f.set_constrained_layout_pads(hpad=0, wpad=0)
    axsh = dict()
    axsh['value'] = dict(zip(bay.splitseasons, axx[:, 0]))
    axsh['ratios'] = dict(zip(bay.splitseasons, axx[:, 1]))

    axke = dict()
    axke['value'] = dict(zip(bay.splitseasons, axx[:, 2]))
    axke['ratios'] = dict(zip(bay.splitseasons, axx[:, 3]))

    z = dict(depth=slice(75, None))
    for season in bay.splitseasons:
        for ds0, ax in zip([rms_shear, mean_ke],
                           [axsh, axke]):
            ds = ds0.sel(monsoon=season)

            kwargs = dict(ax=ax['value'][season], _labels=False, lw=1.5)
            h = dict()
            # ds.up.plot(y='depth', label='NIW up', **kwargs)
            # ds.down.plot(y='depth', label='NIW down', color='g', **kwargs)
            h[0] = ds.niw.sel(**z).plot(y='depth', label='NIW',
                                        ,**kwargs, color=color_niw)[0]
            h[1] = ds.low.sel(**z).plot(y='depth', label='lowpass',
                                        ,**kwargs, color=color_low)[0]
            h[2] = ds.total.sel(**z).plot(y='depth', label='Total',
                                          ,**kwargs, color='k')[0]

            kwargs.update(ax=ax['ratios'][season])
            (ds.low/ds.total).sel(**z).plot(y='depth', label='lowpass',
                                            ,**kwargs, color=color_low)
            (ds.niw/ds.total).sel(**z).plot(y='depth', label='NIW',
                                            ,**kwargs, color=color_niw)

            ax['ratios'][season].axvline(0.5, color='gray', ls='--', zorder=-1)

            for aa in ['ratios', 'value']:
                ax[aa][season].text(0.8, 0.1, season,
                                    transform=ax[aa][season].transAxes)

    # [axsh['value'][aa].set_ylabel(aa + '\ndepth [m]') for aa in axsh['value']]
    [aa.set_ylabel('depth [m]') for aa in axx[:, 0]]

    for aa in axx.flat:
        aa.spines['top'].set_visible(True)
        aa.spines['right'].set_visible(False)
        aa.spines['bottom'].set_visible(False)
        aa.xaxis.set_label_position('top')
        aa.xaxis.set_tick_params(top=True, bottom=False, labelbottom=False)

    for aa in axx[0, :]:
        aa.xaxis.set_tick_params(labeltop=True)

    for aa in axx[-1, :]:
        aa.xaxis.set_tick_params(labelbottom=False)

    axx[0, 0].invert_yaxis()
    axx[0, 1].set_xlim([0, 1])
    axx[0, 3].set_xlim([0, 1])

    axke['value']['NE'].set_xscale('log')

    if wkb_scale:
        axx[0, 0].set_xlabel('WKB Shear [1/s]')
        axx[0, 2].set_xlabel('WKB KE [m²/s²]')
    else:
        axx[0, 0].set_xlabel('Shear [1/s]')
        axx[0, 2].set_xlabel('KE [m²/s²]')
    axx[0, 1].set_xlabel('Fraction of total shear')
    axx[0, 3].set_xlabel('Fraction of total KE')

    axx[0, 0].set_ylim([550, 50])
    axx[0, 0].set_yticks(np.arange(100, 600, 100))

    hleg = f.legend(h.values(), ['NIW', 'lowpass', 'Total'],
                    loc='lower right', ncol=3, title=mooring.upper())

    f.set_size_inches((7.5, 8))
    f.savefig('images/shear-ke-profiles-' + mooring + '.png')
  #+END_SRC
#+CAPTION: Vertical profiles of shear, KE : NRL5
[[file:images/shear-ke-profiles-nrl5.png]]


*** Low-pass + NIW shear + mixing

#+BEGIN_SRC ipython :session
turb = xr.open_dataset('../estimates/bay_merged_hourly.nc')
# cm = mpl.cm.RdPu
for m in ['nrl1', 'nrl2', 'nrl3', 'nrl4', 'nrl5']:
# for m in ['nrl4', 'nrl5']:
    adcp = bay.read_adcp(m)
    good_data = adcp['vel'].good_data

    lowpass = adcp['vel'][['uz', 'vz', 'u', 'v']].apply(
        xfilter.lowpass, coord='time', freq=0.5*adcp['vel'].inertial,
        cycles_per='D', order=3)
    lowpass['Uz'] = np.hypot(lowpass.uz, lowpass.vz)
    lowpass.Uz.dc.set_name_units('Lowpass shear', '1/s')
    lowpass['KE'] = np.hypot(lowpass.u, lowpass.v)**2
    lowpass.KE.dc.set_name_units('Lowpass KE', 'm²/s²')

    niw_shear = np.hypot(adcp['niw'].uz, adcp['niw'].vz)
    niw_shear.dc.set_name_units('NIW shear', '1/s')
    niw_ke = np.hypot(adcp['niw'].u, adcp['niw'].v)**2
    niw_ke.dc.set_name_units('NIW KE', 'm²/s²')

    f = plt.figure(constrained_layout=True)
    gs = f.add_gridspec(4, 1, height_ratios=(2, 2, 2, 1))
    axx = []
    axx.append(f.add_subplot(gs[0]))
    axx.append(f.add_subplot(gs[1], sharex=axx[0], sharey=axx[0]))
    axx.append(f.add_subplot(gs[2], sharex=axx[0], sharey=axx[0]))
    axx.append(f.add_subplot(gs[3], sharex=axx[0]))

    ax = dict(zip(['full', 'lo', 'niw', 'turb'], axx))

    kwargs = dict(yincrease=False, robust=True,
                  ylim=[200, 0], cmap=mpl.cm.PuRd)

    low_daily = (adcp['vel'][['u', 'v']]
                 .apply(xfilter.lowpass, coord='time', freq=1,
                        cycles_per='D', order=3))
    speed = np.hypot(low_daily.u, low_daily.v)
    speed.dc.set_name_units('sub-1day speed', 'm/s')
    # lowpass.KE.plot(ax=ax['full'], **kwargs)
    hdl = (speed
           .where(good_data)
           .plot.contourf(ax=ax['full'], levels=25, robust=True, yincrease=False,
                          cmap=mpl.cm.Spectral_r))

    (niw_ke.resample(time='12H').mean('time')
     .plot.contour(ax=ax['niw'], levels=[0.01, 0.03],
                   colors='b', yincrease=False))
    hdl = lowpass.Uz.where(good_data).plot(ax=ax['lo'], **kwargs)
    niw_shear.where(good_data).plot(ax=ax['niw'], **kwargs)

    for aa in axx[:-1]:
        z = (turb.z
             .sel(**bay.loc[m.upper()]).dropna(dim='depth', how='all')
             .resample(time='D', loffset='12H').mean('time').load())
        aa.plot(z.time, z.values, color='k')

    (turb.KT.sel(**bay.loc[m.upper()]).dropna(dim='depth', how='all')
     .resample(time='6H').mean('time')
     .plot.line(x='time', ax=ax['turb'], yscale='log', add_legend=False))

    [aa.set_title('') for aa in axx]
    [aa.set_xlabel('') for aa in axx]
    [aa.set_title('') for aa in axx]
    [[tt.set_visible(False) for tt in aa.get_xticklabels()] for aa in axx[:-1]]

    tlim = (turb.KT.sel(**bay.loc[m.upper()])
            .dropna('depth', how='all')
            .dropna('time', how='all')
            .time[[0, -1]])

    axx[-1].set_xlim(tlim.values)
    f.set_size_inches((8, 8))
    axx[0].set_title(m)
    f.savefig('images/ke-shear-' + m + '.png', bbox_inches='tight')
#+END_SRC

[[file:~/bay/images/ke-shear-nrl1.png]]
[[file:~/bay/images/ke-shear-nrl3.png]]
[[file:~/bay/images/ke-shear-nrl4.png]]
[[file:~/bay/images/ke-shear-nrl5.png]]


*** NI summary
#+BEGIN_SRC ipython :session
ninput = xr.open_dataset('../estimates/mooring-near-inertial-input.nc').true_flux

tropflux = dcpy.oceans.read_tropflux()

m = 'NRL3'
adcp = bay.read_adcp(m)

f, axx = plt.subplots(6, 1, constrained_layout=True, sharex=True,
                      gridspec_kw={'height_ratios': (0.5, 0.5, 2, 2, 2, 0.5)})
ax = dict(zip(['tau', 'input', 'KEin', 'shear_total', 'shear_in', 'KT'],
              axx))

(tropflux.tau.sel(**bay.loc[m], method='nearest')
 .plot(ax=ax['tau'], color='k', _labels=False))

ninput.sel(**bay.loc[m]).plot(ax=ax['input'], color='k', _labels=False)

(adcp['niw'].KE.where(adcp['niw'].good_data)
 .plot(robust=True, vmin=0, cmap=mpl.cm.YlOrRd, yincrease=False, ax=ax['KEin']))

for aa in axx:
    aa.set_title('')
    aa.set_xlabel('')


# f.savefig('images/ni-summary-nrl3.png')
#+END_SRC
#+CAPTION:
[[file:images/ni-summary-nrl3.png]]
* Shear tests
1. For both NRL4, NRL5, near-inertial shear is dominant except for occasional events when the SMC meanders by.
2. Since magnitude of KT and magnitude of shear aren't expected to be proportional, maybe I should look at frequency of turbulent events.

#+BEGIN_SRC ipython :session
mooring = nrl5

# uzi = mooring.interp_shear()

filter_kwargs = dict(cycles_per='D', coord='time', order=3)

zpod = (mooring.zχpod.sel(num=2, drop=True)
        .interp(time=mooring.vel.time).dropna('time'))

iz0 = np.digitize(zpod.values, mooring.vel.depth-4) - 1
zbin = xr.DataArray(np.stack([iz0-1, iz0, iz0+1]),
                    dims=['iz', 'time'],
                    coords={'time': zpod.time, 'iz': [-8, 0, 8]})
subset = (mooring.vel[['u', 'v']]
          .sel(depth=mooring.vel.depth[zbin], time=zbin.time)
          .interpolate_na('time'))
subsetz = (subset.differentiate('iz').isel(iz=1, drop=True)
           .rename({'u': 'uz', 'v': 'vz'}))
subsetz['u'] = subset.u.isel(iz=1)
subsetz['v'] = subset.v.isel(iz=1)
subsetz['shear'] = subsetz.uz + 1j * subsetz.vz

uzi = subsetz

# uzi = (mooring.vel[['u', 'v', 'uz', 'vz']]
#        .sel(depth=120, method='nearest'))

full = xr.Dataset()
full['shear'] = uzi.uz.interpolate_na('time') + 1j*uzi.vz.interpolate_na('time')
full['u'] = uzi.u
full['v'] = uzi.v
full['N2'] = ((mooring.turb.N2).isel(depth=1)
              .interp(time=zpod.time))
full['Tz'] = (mooring.turb.Tz.isel(depth=1)
              .interp(time=zpod.time))
full = full.interpolate_na('time')

low = full.apply(xfilter.lowpass, freq=0.15, **filter_kwargs)
loni = full.apply(xfilter.lowpass, freq=2.1, **filter_kwargs)
high = full.apply(xfilter.bandpass, freq=[0.15, 4], **filter_kwargs)
niw = full.apply(xfilter.bandpass, freq=[0.15, 2.1], **filter_kwargs)

# KT = np.log10(nrl5.KT.isel(depth=1)
#       .interp(time=full.time)
#       .dropna('time'))
# dcpy.ts.PlotCoherence(KT, np.real(full.shear.interp(time=KT.time)),
#                       dt=1/24, nsmooth=15, decimate=True)

for ds in [full, low, high, niw]:
    ds['ke'] = 0.5 * (ds.u**2 + ds.v**2)
    ds['ke'].attrs['long_name'] = 'KE'
    ds['ke'].attrs['units'] = 'm²/s²'
    ds['dkedz'] = ds.u * np.real(ds.shear) + ds.v * np.imag(ds.shear)
    ds['dkedz'].dc.set_name_units('dKE/dz', 'm/s²')

f, axx = plt.subplots(3, 1, sharex=True, constrained_layout=True)
ax = dict(zip(['shear', 'N2', 'KT'], axx))

# np.sqrt(low.ke).plot(ax=ax[0], color='k')
# np.sqrt(high.ke).plot(ax=ax[0], color='g')

def rms(da, axis='time'):
    return ((da**2).mean(axis))

# np.abs(uzi.uz + 1j*uzi.vz).plot(color='gray')
# np.abs(high).plot(ax=ax[0])
rs = dict(time='W', loffset='3D')
rs = dict(time=7*24, center=True)
var = 'shear'
((np.abs(full[var])**2)
 .plot(color='k', alpha=0.2, lw=1, ax=ax['shear'], label='Full'))
(np.abs(low[var]).rolling(**rs).reduce(rms)
 .plot(color='k', ax=ax['shear'], lw=2, zorder=10, label='RMS LF (< 7 days)'))
(np.abs(loni[var]).rolling(**rs).reduce(rms)
 .plot(color='k', ax=ax['shear'], lw=2, zorder=4, ls='--',
       label='RMS LF (< $M_2$)'))
# (((1.414 * niw.shear)).resample(time='D', loffset='12H').std('time')
#  .plot(color='g', ax=ax[1]))
# (np.abs(high[var]).plot(color='g', ax=ax['shear'], lw=1, label='HF'))
((np.abs(niw.shear)).rolling(**rs).reduce(rms)
 .plot(color='g', lw=2, ax=ax['shear'], zorder=-1, label='RMS BP (7d - $M_2$)'))
ax['shear'].legend(loc='upper right')
ax['shear'].set_ylim([0, 0.0001])
ax['shear'].set_ylabel('$S²$')

((4*low.N2 - np.abs(low.shear)**2)
 .plot(ax=ax['N2'], color='k', lw=2, label='low passed'))
# (low.Tz**2 * 0.01).plot(ax=ax['N2'], color='g', lw=2, label='$T_z^2$/100')
((4*full.N2 - np.abs(full.shear)**2)
 .plot(ax=ax['N2'], color='k', alpha=0.2, zorder=-2))
# (full.Tz**2 * 0.01).plot(ax=ax['N2'], color='g', alpha=0.2, zorder=-1)
ax['N2'].legend()
ax['N2'].set_ylabel('Reduced shear')

ax['z'] = ax['N2'].twinx()
(zpod.resample(time='D', loffset='12H').mean('time')
 .plot(ax=ax['z'], color='C0', lw=2))
dcpy.plots.set_axes_color(ax['z'], color='C0', spine='right')
ax['z'].set_ylim(np.flip(np.array(ax['z'].get_ylim()) + [-10, +10]))

# ((high.N2).resample(time='D', loffset='12H').mean('time')
#  .plot(ax=ax['N2']))
# ax22 = ax[2].twinx()
# (mooring.turb.Tz.isel(depth=1)
#  .resample(time='D', loffset='-12H').mean('time')
#  .plot(ax=ax22, color='k'))
# dcpy.plots.set_axes_color(ax22, 'k', 'right')

# var = 'KT'; limy=[1e-7, 1e-3]
var = 'ε'; limy=[1e-12, 1e-6]
KT = mooring.turb[var].isel(depth=1).resample(time='D', loffset='12H')
(mooring.turb[var].isel(depth=1).plot.line(
    x='time', ax=ax['KT'], alpha=0.2, color='k', label='10 min'))
(KT.mean('time')
 .plot.line(x='time', ax=ax['KT'], yscale='log', lw=2,
            color='k', label='Daily mean'))
(KT.median('time')
 .plot.line(x='time', ax=ax['KT'], yscale='log', lw=2,
            color='C4', label='Daily median'))
ax['KT'].legend()
ax['KT'].set_ylim(limy)
t = mooring.ε.isel(depth=1).dropna('time').time.values

[aa.grid() for aa in axx]
[aa.set_title('') for aa in axx]
[aa.set_xlabel('') for aa in axx]
[bay.mark_seasons(ax=aa) for aa in axx]
[aa.set_xlim([t[0], t[-1]]) for aa in axx]

axx[0].set_title(mooring.name)
f.set_size_inches((12, 8))
axx[-1].tick_params(axis='x', labelrotation=0)
# axx[-1].set_xlim(['2013-12-15', '2015-03-01'])

def _setup_xgrid(ax):
    ax.xaxis.set_minor_locator(mpl.dates.WeekdayLocator(interval=1))
    ax.grid(True, which='minor', axis='x')

[_setup_xgrid(aa) for aa in axx]

f.savefig('images/shear-test-' + mooring.name.lower() + '.png')
#+END_SRC
#+CAPTION:
[[file:images/shear-test-nrl5.png]]
[[file:images/shear-test-nrl4.png]]

#+BEGIN_SRC ipython :session
dcpy.ts.PlotCoherence()

f.savefig('images/shear-coherence-nrl5.png')
#+END_SRC
#+CAPTION:
[[file:images/shear-coherence-nrl5.png]]

#+BEGIN_SRC ipython :session
f, ax = plt.subplots(2, 1, constrained_layout=True, sharex=True)

for aa, pa in zip(ax, [False, True]):
    kwargs = dict(ax=aa, preserve_area=pa)

    dcpy.ts.PlotSpectrum(np.hypot(nrl5.vel.uz, nrl5.vel.vz)
                         .sel(depth=55, method='nearest')
                         .interpolate_na('time'),
                         ,**kwargs)

    dcpy.ts.PlotSpectrum(np.hypot(nrl5.vel.uz, nrl5.vel.vz)
                         .sel(depth=110, method='nearest')
                         .interpolate_na('time'),
                         ,**kwargs)

aa.legend(['55m', '110m'])

f.savefig('images/shear-above-below-gap-nrl5.png')
#+END_SRC
#+CAPTION: Shear spectra above, below gap. So much noise in the upper ADCP?!
[[file:images/shear-above-below-gap-nrl5.png]]

#+BEGIN_SRC ipython :session
f, ax = plt.subplots(2, 1, constrained_layout=True, sharex=True)

for aa, pa in zip(ax, [False, True]):
    kwargs = dict(ax=aa, preserve_area=pa)

    dcpy.ts.PlotSpectrum(np.hypot(nrl4.vel.uz, nrl4.vel.vz)
                         .sel(depth=35, method='nearest')
                         .interpolate_na('time'),
                         ,**kwargs)

    dcpy.ts.PlotSpectrum(np.hypot(nrl4.vel.uz, nrl4.vel.vz)
                         .sel(depth=80, method='nearest')
                         .interpolate_na('time'),
                         ,**kwargs)

aa.legend(['35m', '80m'])

f.savefig('images/shear-above-below-gap-nrl4.png')
#+END_SRC
#+CAPTION: Shear spectra above, below gap. So much noise in the upper ADCP?!
[[file:images/shear-above-below-gap-nrl4.png]]

* Heat flux divergence @ 8N
** 8N sampling
#+BEGIN_SRC ipython :session
# f, ax = plt.subplots(3, 2, constrained_layout=True, sharex=True, sharey='row')

# for ii, mm in enumerate([nrl4, nrl5]):
#     Jq = mm.Jq.resample(time='12H').mean('time').interpolate_na('time')
#     ρ = mm.turb.ρ.resample(time='12H').mean('time')

#     Jq.plot.line(x='time', ax=ax[0, ii])

#     (Jq.differentiate('depth').isel(depth=0)
#      .plot.line(x='time', ax=ax[1, ii]))

#     ρ.plot.line(x='time', ax=ax[2, ii])
#     ρ.mean('depth').plot.line(x='time', color='k', lw=2, ax=ax[2, ii])


labels = []
hdl = []
f, ax = plt.subplots(2, 1, sharex=True, constrained_layout=True)
for ii, mm in enumerate([nrl3, nrl4, nrl5]):
    hh = (mm.turb.ρ.resample(time='12H').mean('time')
          .plot.line(x='time', color='C'+str(ii), ax=ax[0],
                     add_legend=False, yincrease=False))
    hdl.append(hh[0])
    labels.append(mm.name)

    (mm.zχpod.resample(time='12H').mean('time')
     .plot.line(x='time', color='C'+str(ii), ax=ax[1],
                add_legend=False, yincrease=False))

dcpy.plots.liney(bay.default_density_bins[1:-1], ax=ax[0])

plt.gca().legend(handles=hdl, labels=labels)
f.savefig('images/8N-sampling.png')
#+END_SRC
#+CAPTION:
[[file:images/8N-sampling.png]]

* NRL5 details
** M_2 soliton mixing?
#+BEGIN_SRC ipython :session :results none
trange = slice('2014-07-01', '2014-09-01')
#t518 = nrl5.χpod[518].convert_to_xarray('mmw')
#t519 = nrl5.χpod[519].convert_to_xarray('mmw')

f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True,
                     gridspec_kw={'height_ratios': [1, 1, 2]})
(nrl5.Jq.sel(time=trange).resample(time='D').mean('time')
 .plot.line(x='time', ax=ax[0],ylim=[-5, 0], add_legend=True))
# hdl1 = t518['T'].sel(time=trange).plot(x='time', ax=ax[0])
# hdl2 = t519['T'].sel(time=trange).plot(x='time', ax=ax[0])
# f.legend(handles=[hdl1[0], hdl2[0], hdl3[0]],
#          labels=['χpod @ 84', 'χpod @ 104'])

# nrl5.ε.values[nrl5.ε.values < 1e-12] = 1e-12
(nrl5.ε
 .sel(time=trange).rolling(time=6).mean()
 .plot.line(x='time', ax=ax[1], yscale='log', ylim=[1e-10, 1e-6],
            add_legend=False))

f0 = nrl5.inertial/86400
shear = (nrl5.vel.shear.rolling(depth=3, center=True).mean()
         .interpolate_na('time'))
(shear.sel(time=trange, depth=slice(10, None))
 .plot(yincrease=False, cmap=mpl.cm.RdYlBu_r, vmax=0.015, ax=ax[2]))

# bpshear = (shear.interpolate_na('time')
#            .pipe(dcpy.ts.xfilter, kind='bandpass', dim='time',
#                  flen=[1/1.3/f0, 1.3/f0]))
# (bpshear.sel(time=trange)
#  .plot.contourf(x='time', robust=True, yincrease=False, levels=20,
#                 cmap=mpl.cm.RdBu_r, ax=ax[2]))

(nrl5.ctd['T'].sel(time=trange).resample(time='H').mean('time')
 .plot.contour(levels=np.arange(15, 25, 2.5),
               colors='k', yincrease=False, linewidths=1))

# hdl = (nrl5.ctd['T'].sel(time=trange)
#        .plot.contourf(levels=20, x='time', yincrease=False,
#                       cmap=mpl.cm.RdYlBu_r, ax=ax[2], robust=True))
# (nrl5.ctd['T'].sel(time=trange)
#  .plot.contour(levels=hdl.levels, x='time', yincrease=False,
#                colors='k', ax=ax[2], linewidths=0.75))
nrl5.zχpod.sel(time=trange).plot.line(x='time', ax=ax[2], color='b',
                                      add_legend=False)

ax[1].set_title('')
[aa.set_xlabel('') for aa in ax]

ax[2].set_ylim([250, 15])
f.set_size_inches((14, 8))

f.savefig('images/m2-soliton-nrl5.png')
#+END_SRC
#+ATTR_HTML: :class full-width
#+CAPTION: M_2 solitons? And a mixing signal? High ε lines up with high shear *but this is shear calculated from the first bin!*
[[file:images/m2-soliton-nrl5.png]]


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgdpXv0t.png
plt.figure(constrained_layout=True);
(nrl5.vel.shear.sel(time=trange, depth=slice(100, None))
.plot(yincrease=False, cmap=mpl.cm.Greens, vmin=4e-3, vmax=0.014))
(nrl5.ctd['T'].sel(time=trange)
 .plot.contour(levels=20, colors='k', yincrease=False, linewidths=1))
plt.gca().set_ylim([250, 100])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[244]:
: (250, 100)
:END:

** isothermal spectra
TODO: needs to be changed to density
#+BEGIN_SRC ipython :session :results none
# need to change to density

# griddata is a bad idea because it interpolates in all dimensions
# tvec = ((nrl5.ctd.time - nrl5.ctd.time[0])
#         .values.astype('timedelta64[s]').astype('float32'))
# z = xr.broadcast(nrl5.ctd.depth[:-1], nrl5.ctd.time)[0]
# t = np.broadcast_to(tvec, z.shape)

# points = np.vstack([t.ravel(), z.values.ravel()])
# values = nrl5.ctd.S.isel(z=slice(None, -1)).values.ravel()
# grid_x, grid_y = np.meshgrid(tvec, nrl5.ctd.depth2.values)

# S = sp.interpolate.griddata(points.T, values, (grid_x, grid_y),
#                             method='linear', rescale=True)
# Smat = nrl5.ctd.T.copy(data=S)
# Smat.name = 'S'

#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile :results none
if 'isoT' not in locals():
    isoT = nrl5.isothermal_shear()

isoT['wz'] = isoT.uz + 1j * isoT.vz

f, ax = plt.subplots(2, 1, sharex=True, sharey=True, constrained_layout=True)
dcpy.ts.PlotSpectrum((nrl5.vel.uz + 1j*nrl5.vel.vz)
                     .sel(depth=isoT.depth.isel(T=5).mean(), method='nearest')
                     .interpolate_na('time'), twoside=False, ax=ax[0])

dcpy.ts.PlotSpectrum(isoT.wz.isel(T=5).interpolate_na('time'), twoside=False,
                     ax=ax[1])
dcpy.plots.linex([24/12.42, nrl5.inertial.values,
                  24/12.42+nrl5.inertial.values,
                  24/12.42-nrl5.inertial.values],
                 ax=ax)

ax[0].text(0.1, 0.1, 'shear at 128m = mean depth of 21.25C isotherm',
           transform=ax[0].transAxes)
ax[1].text(0.1, 0.1, 'isothermal shear for T = 21.25C',
           transform=ax[1].transAxes)

ax[0].set_xlabel('')
ax[1].set_title('')
plt.suptitle('Rotary shear spectra for NRL5 (SW; 2014-06-01, 2014-09-01)')
[aa.grid(True, axis='y', which='major') for aa in ax]

f.set_size_inches((8, 5))
f.savefig('images/nrl5-isoT-shear-spectra.png')
#+END_SRC

#+CAPTION: isothermal shear spectra for 21C isotherm ≈ 130-150m. I still see the -f±M_2 peaks in clockwise shear :/ What does this mean? Maybe doing this on isopycnals will fix this. *but* magnitude is reduced by a factor of 3-4. Maybe the rest is imperfect removal because of mean definitions / interpolation etc.
[[file:images/nrl5-isoT-shear-spectra.png]]
** attempt a seasonal cycle of NIW shear variance
#+BEGIN_SRC ipython :session
count = nrl5.vel.shear.count('time')
i0 = np.argmin(nrl5.vel.shear.where(count > 0.5*count.max()).count('time'))-2
i1 = i0+9

subset = (nrl5.vel.isel(depth=[i0, i1])
          .differentiate('depth').isel(depth=0))
shear_span = subset.u.interpolate_na('time') + 1j * subset.v.interpolate_na('time')

f, ax = plt.subplots(1, 1, constrained_layout=True)
dcpy.ts.PlotSpectrum(shear_span, twoside=False, ax=ax)
ax.set_title('NRL5 | shear estimated using bin above & below gap in velocity.')
f.set_size_inches(8, 5)
f.savefig('images/nrl5-depth-gap-span-shear-spectrum.png')
#+END_SRC
#+CAPTION: Using the bin slightly above and slightly below the gap in velocity shows a daily peak. Hmmm... Not sure this is that useful then. I must be seeing a lot of mixed layer signals.
[[file:images/nrl5-depth-gap-span-shear-spectrum.png]]


#+BEGIN_SRC ipython :session
if 'wind_input' not in locals():
    wind_input = xr.open_dataset('../estimates/wind-power-input-2014.nc')

bpshear0 = nrl5.calc_shear_bandpass(depth=nrl5.vel.depth[i0])
bpshear1 = nrl5.calc_shear_bandpass(depth=nrl5.vel.depth[i1])

f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True)

dt = (nrl5.niw.true_flux.time.diff('time').values.mean()
      .astype('timedelta64[s]').astype('float32'))
(nrl5.niw.true_flux * dt).plot(ax=ax[0], color='gray')
(nrl5.niw.true_flux.pipe(np.cumsum) * dt).plot(ax=ax[0].twinx(), color='k')
# (nrl3.niw.true_flux.pipe(np.cumsum) * dt).plot(ax=ax[0])

(nrl5.KT.resample(time='12H').mean('time')
 .plot.line(x='time', ax=ax[1], yscale='log'))

[nrl5.calc_shear_bandpass(depth=zz).f0
 .rolling(time=24*7).var()
 .plot(label=str(zz), ax=ax[-1])
 for zz in [30, 40, 120]]
ax[-1].legend()
ax[-1].set_ylim([0, 1.5e-5])
ax[-1].set_title('')
[aa.set_xlabel('') for aa in ax[:-1]]

f.savefig('images/nrl5-seasonal-shear-variance.png')
#+END_SRC
#+CAPTION: Seasonal cycle of near-inertial wave shear isn't very convincing. There's not much during the NE monsoon!
[[file:images/nrl5-seasonal-shear-variance.png]]

#+BEGIN_SRC ipython :session
f, ax = plt.subplots(2, 1, sharex=True, constrained_layout=True)

dm_ke = []
dm_sh = []

def _cd_plot(var, period, ax, label):
    demod = dcpy.ts.complex_demodulate(var, period, bw=0.1)
    amp = demod.amp.pipe(dcpy.ts.xfilter, flen=3*86400, dim='time', kind='hann')
    amp.plot(label=label, ax=ax)

    return amp

for m in [nrl3, nrl4, nrl5]:
    flen = np.array([1/1.3, 1.3]) * 1/m.inertial.values
    KE = ((0.5*np.abs(m.vel.w.sel(depth=slice(120, 200)))**2)
          .mean('depth'))

    if 'shear_fit' not in m.vel:
        u = (m.vel.u.sel(depth=slice(120, 160))
             .interpolate_na('time')
             .dropna('time', how='any'))
        v = (m.vel.u.sel(depth=slice(120, 160))
             .interpolate_na('time')
             .dropna('time', how='any'))
        uz = np.apply_along_axis(lambda x: np.polyfit(u.depth, x, 1)[0],
                                 u.get_axis_num('depth'), u.values)
        vz = np.apply_along_axis(lambda x: np.polyfit(u.depth, x, 1)[0],
                                 v.get_axis_num('depth'), v.values)
        m.vel['shear_fit'] = xr.DataArray(np.hypot(uz, vz), dims=['time'],
                                          coords={'time': u.time})

    # shear = m.vel.shear.sel(depth=slice(120, 200)).mean('depth')

    dm_ke.append(_cd_plot(KE, period=1/m.inertial.values, label=m.name, ax=ax[0]))
    dm_sh.append(_cd_plot(m.vel.shear_fit,
                          period=1/m.inertial.values,
                          label=m.name, ax=ax[1]))

    # dcpy.ts.PlotSpectrogram(KE.interpolate_na('time'), dt=1/24,
    #                         nfft=14*24, shift=1*24, multitaper=True)

(xr.concat(dm_ke, dim='moor').mean('moor')
 .plot(color='k', lw=2, label='mean', ax=ax[0]))

(xr.concat(dm_sh, dim='moor').mean('moor')
 .plot(color='k', lw=2, label='mean', ax=ax[1]))

nrl5.MarkSeasonsAndEvents(ax=ax[0])
nrl5.MarkSeasonsAndEvents(ax=ax[1])

[aa.set_xlabel('') for aa in ax]
ax[0].legend()
ax[0].set_title('8N NIW KE in thermocline (120-160m) | complex demod amplitude')
ax[1].set_title('8N NIW shear in thermocline (120-160m) | complex demod amplitude')
f.savefig('images/nrl-niw-KE-seasonal-cycle.png')

# f, ax = plt.subplots(2, 1, sharex=True, constrained_layout=True,
#                      gridspec_kw=dict(height_ratios=[1, 2]))
# nrl5.vel.shear_fit.sel(time='2015-03-12').plot(ax=ax[0])
# (np.hypot(u, v).sel(time='2015-03-12')
#  .plot(edgecolor='w', robust=True, yincrease=False, ax=ax[1]))
#+END_SRC
#+CAPTION: Averaged over 120-200m, and then over all moorings at 8N; there is a seasonal cycle in NIW KE. The shear is a linear fit to velocity profiles in that depth range. Steps: complex demodulate at inertial frequency; run 4 day hann smoother on amplitude (because the peak is broad, the amplitude time series has "high frequency" variability). Black line is mean of all 3.
 [[file:images/nrl-niw-KE-seasonal-cycle.png]]

#+BEGIN_SRC ipython :session
u = nrl5.vel.u.sel(depth=slice(120, 160)).interpolate_na('time')
v = nrl5.vel.v.sel(depth=slice(120, 160)).interpolate_na('time')

uz = np.apply_along_axis(lambda x: np.polyfit(u.depth, x, 1)[0],
                         u.get_axis_num('depth'), u.values)
vz = np.apply_along_axis(lambda x: np.polyfit(u.depth, x, 1)[0],
                         v.get_axis_num('depth'), v.values)

shear = xr.DataArray(np.hypot(uz, vz), dims=['time'], coords={'time': u.time})

f, ax = plt.subplots(1, 1, constrained_layout=True)
shear.plot(ax=ax)
nrl5.vel.shear.sel(depth=slice(120, 160)).mean('depth').plot()

ax.set_title('Shear between 120m and 160m NRL5')
ax.legend(['linear fit', 'mean (shear)'])
f.savefig('images/linear-fit-shear.png')
#+END_SRC
#+CAPTION: Comparing a linear fit over a range of depths vs shear averaged over those depths
[[file:images/linear-fit-shear.png]]

#+BEGIN_SRC ipython :session
KT = nrl5.KT.where(nrl5.KT > 3e-7).resample(time='D').mean('time').shift(time=2)
KT.attrs['long_name'] = 'Daily mean $K_T$'
niw = (nrl5.niw.true_flux.resample(time='D').std('time')
       .interp(time=KT.time))
niw.attrs['long_name'] = 'Daily std. NIW energy flux'

def _bin_plot(xvar, yvar, **kwargs):
    bins = pd.qcut(xvar.where(~np.isnan(yvar)), 8, retbins=True)[1]
    yvar.groupby_bins(xvar, bins=bins).mean().plot(lw=2, **kwargs)

f, ax = plt.subplots(1, 1, sharey=True, constrained_layout=True)
hdl = ax.plot(niw, KT.T, '.', alpha=0.5)

_bin_plot(niw, KT.isel(depth=0), color='C0')
_bin_plot(niw, KT.isel(depth=1), color='C1')
# ax.plot(niw, KT.where(KT > 1e-6).T, 'o')
ax.set_yscale('log')
ax.set_xlabel('Daily std. NIW energy flux [W/m²]')
ax.set_xlim([0, 0.015])
f.set_size_inches((8, 5))
f.savefig('images/nrl5-scatter-wind-input-KT.png')
#+END_SRC
#+CAPTION: Attempt to scatter wind-input daily variance against daily mean KT. This is "true" wind input estimated using sensed ML velocity and Tropflux winds. Note the reduction in number of data points for larger values of flux
[[file:images/nrl5-scatter-wind-input-KT.png]]

** NIW mixing
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgwBTzp9.png
trange = slice('2014-07-21', '2014-08-07')
f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True,
                     gridspec_kw={'height_ratios': [1, 1, 2]})
hdl1 = t518['T'].sel(time=trange).plot(x='time', ax=ax[0])
hdl2 = t519['T'].sel(time=trange).plot(x='time', ax=ax[0])
hdl3 = nrl5.ctd['T'].sel(time=trange, depth2=106).plot(x='time', ax=ax[0])
f.legend(handles=[hdl1[0], hdl2[0], hdl3[0]],
         labels=['χpod @ 84', 'χpod @ 104', 'T logger @ 104'])

(nrl5.ε.sel(time=trange)
 .plot.line(x='time', ax=ax[1], yscale='log', ylim=[1e-10, 1e-6],
            add_legend=False))

(nrl5.vel.shear.sel(time=trange, depth=slice(100, None))
 .plot(yincrease=False, cmap=mpl.cm.Reds, vmax=0.015))
(nrl5.ctd['T'].sel(time=trange)
 .plot.contour(levels=7, colors='k', yincrease=False, linewidths=1))

# hdl = (nrl5.ctd['T'].sel(time=trange)
#        .plot.contourf(levels=20, x='time', yincrease=False,
#                       cmap=mpl.cm.RdYlBu_r, ax=ax[2], robust=True))
# (nrl5.ctd['T'].sel(time=trange)
#  .plot.contour(levels=hdl.levels, x='time', yincrease=False,
#                colors='k', ax=ax[2], linewidths=0.75))
nrl5.zχpod.sel(time=trange).plot.line(x='time', ax=ax[2], color='b',
                                      add_legend=False)
v = nrl5.vel.v.sel(time=trange).resample(time='2H').mean(dim='time')
v.plot.contour(ax=ax[2], yincrease=False, levels=20, colors='w')

ax[1].set_title('')
[aa.set_xlabel('') for aa in ax]

ax[2].set_ylim([250, 75])
f.set_size_inches((16, 9))
#+END_SRC
** vel, shear spectra

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgzmw1zO.png

u = interpolate_shear(nrl5.vel.u, zpod).interpolate_na(dim='time')
v = interpolate_shear(nrl5.vel.v, zpod).interpolate_na(dim='time')
uz = interpolate_shear(nrl5.vel.uz, zpod).interpolate_na(dim='time')
vz = interpolate_shear(nrl5.vel.vz, zpod).interpolate_na(dim='time')

z0 = 200
u = nrl5.vel.u.sel(depth=z0).interpolate_na(dim='time')
v = nrl5.vel.v.sel(depth=z0).interpolate_na(dim='time')
uz = nrl5.vel.uz.sel(depth=z0).interpolate_na(dim='time')
vz = nrl5.vel.vz.sel(depth=z0).interpolate_na(dim='time')

fM2 = 24/12.42
f0 = nrl5.inertial

f, ax = plt.subplots(2, 1, sharex=True, constrained_layout=True)

dcpy.ts.PlotSpectrum((u+1j*v), multitaper=True, twoside=False, ax=ax[0])
dcpy.ts.PlotSpectrum((uz+1j*vz), multitaper=True, twoside=False, ax=ax[1])
dcpy.plots.linex([f0, fM2 - f0, fM2 + f0, 2*f0,
                  fM2, 2*fM2, 3*fM2, 4*fM2], ax=ax)

ax[0].set_title('PSD(u + iv)')
ax[0].set_xlabel('')
ax[1].set_title('PSD(u_z + iv_z)')

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[174]:
: Text(0.5, 1.0, 'PSD(u_z + iv_z)')
:END:

** pollard millard model
#+BEGIN_SRC ipython :session :results none
def read_ncep():
    uwnd = (xr.open_dataset('~/datasets/ncep/uwnd.10m.gauss.2014.nc')
            .uwnd.interp(lat=nrl5.lat, lon=nrl5.lon))
    vwnd = (xr.open_dataset('~/datasets/ncep/vwnd.10m.gauss.2014.nc')
            .vwnd.interp(lat=nrl5.lat, lon=nrl5.lon))

    taux = uwnd.copy(data=airsea.windstress.stress(uwnd) * np.sign(uwnd))
    tauy = vwnd.copy(data=airsea.windstress.stress(vwnd) * np.sign(vwnd))
    taux.attrs['long_name'] = '$τ_x$'
    taux.name = 'taux'
    tauy.attrs['long_name'] = '$τ_y$'
    tauy.name = 'tauy'

    return xr.merge([taux, tauy])

if 'ncep' not in locals():
    ncep = read_ncep()

f0 = dcpy.oceans.coriolis(nrl5.lat)/2/np.pi  # needed in cps
mld = 30
Ttrop = ((nrl5.tropflux.taux + 1j*nrl5.tropflux.tauy)
         .sel(time='2014').interpolate_na('time'))
Tncep = (ncep.taux + 1j*ncep.tauy)

Ttrop.attrs['long_name'] = 'Wind stress'
Ttrop.attrs['units'] = 'N/m²'
Tncep.attrs['long_name'] = 'Wind stress'
Tncep.attrs['units'] = 'N/m²'

tropinput = dcpy.oceans.calc_wind_power_input(Ttrop, mld, f0)
ncepinput = dcpy.oceans.calc_wind_power_input(Tncep, mld, f0)

f, ax = plt.subplots(4, 1, constrained_layout=True, sharex=True)

for T, windinput in zip([Ttrop, Tncep], [tropinput, ncepinput]):
    h = T.copy(data=np.abs(T)).plot(ax=ax[0])
    h[0].set_clip_on(False)
    h[0].set_in_layout(False)
    h = windinput.plot(ax=ax[1])
    h[0].set_clip_on(False)
    h[0].set_in_layout(False)

(nrl5.ε.where(nrl5.ε > 0)
 .resample(time='D').mean('time').sel(time='2014')
 .plot.line(x='time', ax=ax[2], yscale='log'))

(nrl5.KT
 .resample(time='D').mean('time').sel(time='2014')
 .plot.line(x='time', ax=ax[3], yscale='log'))

ax[0].legend(['tropflux', 'ncep'])
[aa.set_xlabel('') for aa in ax]
[aa.set_title('') for aa in ax]
ax[0].set_title('Compare wind input for Tropflux/NCEP at NRL5')

plt.savefig('images/nrl5-wind-input-tropflux-vs-ncep.png')
#+END_SRC
#+CAPTION: Near-inertial input is *not* directly correlated to wind-stress. Looks like NCEP understimates the peak stress events.
[[file:images/nrl5-wind-input-tropflux-vs-ncep.png]]

** tidal shear at NRL5
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgfJCfCZ.png
tidal_shear = dcpy.ts.xfilter(nrl5.vel.shear.interpolate_na('time'),
                              kind='bandpass',
                              flen=np.array([0.8, 1.2]) * 12.42 * 3600)

tidal_temp = dcpy.ts.xfilter(nrl5.ctd['T'],
                             kind='bandpass',
                             flen=np.array([0.9, 1.1]) * 12.42 * 3600)

f, ax = plt.subplots(2, 1, sharex=True)
(tidal_shear.sel(depth=120, method='nearest')
 .resample(time='H').mean(dim='time')
 .plot(x='time', yincrease=False, ax=ax[0]))
(nrl5.KT.resample(time='H').mean(dim='time')
 .plot.line(ax=ax[1], yscale='log', x='time'))

f, ax = plt.subplots(2, 1, sharex=True, constrained_layout=True,
                     gridspec_kw={'height_ratios': [2, 1]})
(tidal_shear.sel(time='2014')
 .resample(time='H').mean(dim='time')
 .plot(x='time', yincrease=False, robust=True, ax=ax[0]))
(nrl5.zχpod.plot.line(x='time', color='k', ax=ax[0]))
(nrl5.KT.sel(time='2014')
 .resample(time='D').mean(dim='time')
 .plot.line(ax=ax[1], yscale='log', x='time'))

f, ax = plt.subplots()
(tidal_temp.sel(time='2014')
 .resample(time='H').mean(dim='time')
 .plot.contour(x='time', yincrease=False, levels=20))
(nrl5.zχpod.resample(time='D').mean(dim='time')
 .plot.line(x='time', color='k'))

#+END_SRC
#+RESULTS:
:RESULTS:
# Out[123]:
:END:

** NRL5 shear time series
#+BEGIN_SRC ipython :session :ipyfile images/temp/img68tfyk.png
uz, vz = ((nrl5.vel[shear].sel(depth=slice(90, 140))
           .mean('depth')
           .interpolate_na(dim='time'))
          for shear in ['uz', 'vz'])

inertial_uz, inertial_vz = (uz.copy(data=dcpy.ts.BandPassButter(
    shear.values,
    freqs=nrl5.inertial.values*np.array([0.95, 1.05]),
    dt=1/24)).sel(time='2014')
                            for shear in [uz, vz])

inertial_shear = inertial_uz.copy(data=np.hypot(inertial_uz, inertial_vz))

shear = nrl5.vel.shear.sel(depth=slice(90, 140)).mean('depth')
N2 = nrl5.N2.isel(depth=1).interp(time=inertial_shear.time)

f, ax = plt.subplots(2, 1, constrained_layout=True, sharex=True)
(shear**2 - 4*N2).plot(ax=ax[0], ylim=(0, None))
(nrl5.KT.resample(time='D').mean(dim='time')
 .plot.line(x='time', yscale='log', ax=ax[1]))
ax[0].set_xlabel('')
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[343]:
: Text(0.5, 0, '')
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgcXpGjd.png
fM2 = 24/12.42

def plot_spec(spec, ax=None, levels=20):
    if ax is None:
        _, _ax = plt.subplots()

    var = (spec*spec.freq)
    # var = np.log10(spec)
    hdl = var.plot.contourf(levels=levels, yscale='log',
                            x='time', robust=True, ax=ax,
                            cmap=mpl.cm.RdPu, add_colorbar=True)

    var.plot.contour(
        levels=np.linspace(hdl.levels[-1], var.max(), 6)[1:],
        yscale='log', x='time', ax=ax, colors='w',
        linewidths=0.5)


goodt = slice(nrl5.KT.time[0], nrl5.KT.time[-1])
zpod = nrl5.zχpod.sel(num=2).interp(time=nrl5.vel.time.sel(time=goodt))

def interp_shear(shear):
    z = nrl5.zχpod.isel(num=1).median().values + 10
    return (shear.sel(depth=z, method='nearest')
            .interpolate_na(dim='time')
            .dropna('time'))



f0 = nrl5.inertial
fM2 = 24/12.42
plot_spec(shear.sel(time='2014'))
dcpy.plots.liney([0.9*(fM2-f0), 1.1*(fM2+f0),
                  0.9*(fM2*2-f0), 1.1*(fM2*2+f0),
                  0.9*(fM2*3-f0), 1.1*(fM2*3+f0),
                  0.6*f0, 1.5*f0], zorder=10)

f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True)
int_spec(shear, 0.9*(fM2-f0), 1.1*(fM2+f0)).plot(ax=ax[0], label='$M_2$')
int_spec(shear, 0.9*(fM2*2-f0), 1.1*(fM2*2-f0)).plot(ax=ax[0], label='$2M_2$')
# int_spec(shear, 0.9*(fM2*3-f0), 1.1*(fM2*3-f0)).plot(ax=ax[0], label='$3M_2$')
(int_spec(shear, 0.6*f0, 1.5*f0)
 .plot(ax=ax[0], label='$f_0$'))
ax[0].legend()

(nrl5.ε.where(nrl5.ε > 0).sel(time='2014')
 .resample(time='D').mean('time')
 .plot.line(x='time', ax=ax[1], yscale='log'))
ax[0].set_xlabel('')
t518 = nrl5.χpod[518].convert_to_xarray('mmw')
t519 = nrl5.χpod[519].convert_to_xarray('mmw')
t518['T'].plot(x='time', ax=ax[2])
t519['T'].plot(x='time', ax=ax[2])

plt.gca().set_xlim(['2014-01-01', '2014-12-31'])
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[18]:
: (735234.0, 735598.0)
:END:
** richardson number
Nothing conclusive; though it does decrease for the entirety of the time that AS water is present.

#+BEGIN_SRC ipython :session :results none
if 'S2' not in locals():
    shear = nrl5.linear_fit_shear(region=dict(depth=slice(110, 130), time='2014'))
    S2 = shear.shear ** 2

N2 = ((9.81/1025 * nrl5.ctd.ρ.diff('z')/nrl5.ctd.depth.diff('z'))
      .isel(z=1))
Ri = (N2.resample(time='H').mean()/S2).sel(time='2014')

f, ax = plt.subplots(4, 1, sharex=True)
(Ri.plot(ax=ax[0], yscale='log', ylim=[0.1, 1e2]))
ax[0].set_ylabel('hourly $Ri$')

((4*N2).resample(time='H').mean().sel(time='2014')
 .plot(label='$4N²$', ax=ax[1]))
(S2.sel(time='2014')
.plot(label='$S²$', ax=ax[1]))
ax[1].legend()
ax[1].set_ylabel('')

((Ri.where(Ri < 5).resample(time='D').count()/24)
 .plot(ax=ax[2], label='< 5'))
# ((Ri.where(Ri < 5).resample(time='D').count()/24)
#  .plot(ax=ax[2], label='< 5'))
((Ri.where(Ri < 10).resample(time='D').count()/24)
 .plot(ax=ax[2], label='< 10'))
ax[2].set_ylabel('Fraction of day')
ax[2].legend(title='hourly Ri')

(nrl5.KT.resample(time='D').mean('time').sel(time='2014')
 .plot.line(x='time', ax=ax[-1], yscale='log'))

[aa.set_xlabel('') for aa in ax]

f.savefig('images/nrl5-ri.png')
#+END_SRC
[[file:images/nrl5-ri.png]]

** shear variance by bandpassing
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgef1xCD.png
def calc_variance(freqs):
    return (dcpy.ts.BandPassButter(
        nrl5.vel.shear.sel(depth=120, method='nearest')
        .interpolate_na('time'),
        freqs, dim='time', dt=1/24, debug=False)
            .resample(time='D').var())

inertial = calc_variance(np.array([1/1.5, 1.5]) * nrl5.inertial.values)
M2 = calc_variance(np.array([1/1.05, 1.05]) * 24/12.42)
M4 = calc_variance(np.array([1/1.05, 1.05]) * 24/12.42*2)

plt.figure()
inertial.plot()
M2.plot()
M4.plot()
#+END_SRC
* NRL3 details
** isothermal shear for SWNE event
#+BEGIN_SRC ipython :session
if 'isoT3' not in locals():
    isoT3 = nrl3.isothermal_shear(trange=slice('2014-09-15', '2014-10-25'))

iT = 15
depth = isoT3.depth.isel(T=iT).mean()

f, ax = plt.subplots(2, 1, sharex=True, constrained_layout=True)

dcpy.ts.PlotSpectrum((nrl3.vel.uz + 1j * nrl3.vel.vz)
                     .sel(depth=depth, method='nearest')
                     .interpolate_na('time').dropna('time'),
                     twoside=False, ax=ax[0])
dcpy.ts.PlotSpectrum((isoT3.uz + 1j * isoT3.vz).isel(T=iT)
                     .interpolate_na('time').dropna('time'),
                     twoside=False, ax=ax[1])

dcpy.plots.linex([24/12.42, nrl5.inertial.values,
                  24/12.42+nrl5.inertial.values,
                  24/12.42-nrl5.inertial.values],
                 ax=ax)

ax[0].text(0.1, 0.1, 'shear at 128m = mean depth of 21.25C isotherm',
           transform=ax[0].transAxes)
ax[1].text(0.1, 0.1, 'isothermal shear for T =',
           transform=ax[1].transAxes)

ax[0].set_xlabel('')
ax[1].set_title('')
plt.suptitle('Rotary shear spectra for NRL3 (SWNE; 2014-10-01, 2014-10-25)')
[aa.grid(True, axis='y', which='major') for aa in ax]

f.set_size_inches((8, 5))
f.savefig('images/temp/imgVkzqL7.png')
#+END_SRC
#+CAPTION:
[[file:images/temp/imgVkzqL7.png]]
* Barrier layers
When the freshwater arrives, I see large values of Jqt at 30m/45m. This is at both 12N, 15N in both 2014, 2015.

- This observation contradicts the presence of layers hmmm...

- Some of these are where T_z changes sign frequently. (╯°□°）╯︵ ┻━┻

- Sally says that in the Gulf of Mexico she thinks that ambient water is getting subducted under river plumes and mixing there because of strong shear at the base. This is as opposed to the standard barrier layer idea that there is not much mixing happening beneath the mixed layer: i.e., the freshwater cap prevents wind-forced turbulence from penetrating downward?

- Ritabrata observes similar stuff: high mixing near the base and mixing shuts down in 10-20m range below the base.

Some examples follow.
#+NAME: barrier-rama15-2015
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama15-2015-feb.png :results raw
ax = ra15.Plotχpods(region={'time': slice('2015-02-01', '2015-03-31')},
                    filt='mean',  filter_len=6*3600, Tlim=[26.5,28])
_ = ax['T'].set_ylim([50,0])
_ = ax['Jq'].set_yscale('symlog', linthreshy=10, linscaley=0.5)
#+END_SRC
#+ATTR_HTML: :class full-width
#+CAPTION: In this one, the rise in turbulence at 30m coincides with *speed increasing*. 30m χpod sees relatively few changes in T_z sign, but high heat fluxes (compare with below). The "waviness" seems to be M_2.
#+RESULTS: barrier-rama15-2015
[[file:images/barrier-layer-rama15-2015-feb.png]]

When the freshwater arrives we see stronger M_2 tides, maybe a packet came by? But the variability is confined to 20m, 40m CTDs.

#+BEGIN_SRC ipython :session :ipyfile images/rama-15n-freshwater-M2.png
f, ax = plt.subplots(3,1, sharex=False, sharey=False)

(ra15.ctd.S.sel(depth=[10, 20, 40, 60],
                time=slice('2015-02-01', '2015-04-10'))
.plot.line(x='time', ax=ax[0]))

(ra15.ctd.S.sel(depth=[10, 20, 40, 60],
                time=slice('2015-02-22', '2015-03-01'))
.plot.line(x='time', ax=ax[1], add_legend=False))
ax[0].set_title('RAMA 15N, arrival of freshwater 2015 - Note M2 signal')

specargs =dict(dt=600/86400, nsmooth=2, multitaper=True, preserve_area=False, ax=ax[2])
dcpy.ts.PlotSpectrum(ra15.ctd.S.sel(depth=40,
                                    time=slice('2015-02-16', '2015-03-10')),
                     **specargs)
dcpy.ts.PlotSpectrum(ra15.ctd.S.sel(depth=40,
                                    time=slice('2015-03-20', '2015-04-10')),
                     **specargs)
ax[2].set_ylim([10**-5, 1])
ax[2].set_xlabel('Freq (cpd)')
dcpy.plots.linex([1/(2*np.pi/dcpy.oceans.coriolis(15)/86400),
                  24/12.42], ax=ax[2])

plt.gca().set_title('Spectra of salinity at 40m | RAMA 15N, 90E')
plt.legend(['2015-Feb-16 - 2015-Mar-10', '2015-Mar-20 - 2015-Apr-10'])
# plt.gca().set_yscale('linear')
# plt.gca().set_ylim([0, 1])

plt.setp(ax[0].get_xticklabels(), visible=True, rotation=20)
plt.setp(ax[1].get_xticklabels(), visible=True, rotation=20)

f.set_size_inches((8.5, 12.5))
plt.tight_layout()
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/rama-15n-freshwater-M2.png]]
:END:

10m velocity is not useful: 10m salinity behaves much differently. There's a near inertial packet Mar 13-17, otherwise just M2 in velocity.
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgt8hw0H.png
hdl, ax = (dcpy.ts.PlotSpectrum((ra15.vel.u+1j*ra15.vel.v)
                                .squeeze().sel(time=slice('2014-02-16',
                                                          '2014-03-10')),
                                multitaper=True, dt=30*60/86400))
hdl, ax = (dcpy.ts.PlotSpectrum((ra15.vel.u+1j*ra15.vel.v)
                                .squeeze().sel(time=slice('2014-03-12',
                                                          '2014-04-10')),
                                multitaper=True, dt=30*60/86400, ax=ax))

dcpy.plots.linex([1/(2*np.pi/dcpy.oceans.coriolis(15)/86400),
                  24/12.42], ax=ax)
ax[1].set_xlim([1e-1, 1e1])
ax[0].set_xlim([1e1, 1e-1])
#+END_SRC

#+RESULTS:
:RESULTS:
: (10.0, 0.1)
[[file:images/temp/imgt8hw0H.png]]
:END:

#+NAME: barrier-rama12-2014
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama12-2014-feb.png :results raw
ax = ra12.Plotχpods(region={'time': slice('2014-02-20', '2014-03-20')},
                    Tlim=[26.5, 28.75],
                    filt='hann',  filter_len=3*3600)
_ = ax['T'].set_ylim([60,0])
#+END_SRC
#+CAPTION: Here, both χpods see frequent changes in the sign of T_z and heat fluxes are large and change sign often. |T_z| stays decently big (0.01-0.1) for chunks of time --- these are associated with large fluxes. Maybe using internal T_z might make sense here.

#+NAME: barrier-rama12-2015
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama12-2015-apr.png :results raw
ax = ra12.Plotχpods(filt='hann',  filter_len=6*3600, met='tropflux')
_ = ax['T'].set_ylim([60,0])
_ =  ax['met'].set_xlim(('2015-04-10', '2015-05-10'))
#+END_SRC
#+CAPTION: Not that similar to above (but see 2015/04/15-2015/04/18). Here, 45m χpod sees large heat fluxes.
#+RESULTS: barrier-rama12-2015
[[file:images/barrier-layer-rama12-2015-apr.png]]
* Hudhud sensitivity to Jq
# Read data
#+BEGIN_SRC ipython :session
def read_Turb(filename):
    from scipy.io import loadmat
    f = loadmat(filename)

    def process_estimate(estimate):
        chi = xr.Dataset()
        tmatlab = estimate[0,0]['time'][0,0].squeeze()
        tcommon = ((-86400 + (tmatlab-366) * 86400).astype('timedelta64[s]')
                   + np.datetime64('0001-01-01')).astype('datetime64[ns]')

        chi['χ'] = xr.DataArray(estimate[0,0]['chi'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['Kt'] = xr.DataArray(estimate[0,0]['Kt'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['Jq'] = xr.DataArray(estimate[0,0]['Jq'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['ε'] = xr.DataArray(estimate[0,0]['eps'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])

        return chi

    Turb = dict()
    for field in f['Turb'].dtype.names:
        if field in ['mm1', 'mm2', 'pm1', 'pm2',
                     'mi11', 'mi22', 'pi11', 'pi22']:
            estimate = f['Turb'][field]
            Turb[field] = process_estimate(estimate)
    return Turb

dirname = '/home/deepak/pods/526/proc/'
est = dict()
for tz in [1e-4, 3e-4, 7.5e-4, 1e-3, 2e-3, 5e-3]:
    filename = dirname + 'Turb-{0:.1e}.mat'.format(tz)
    print(filename)
    est[tz] = read_Turb(filename)

if ra12.sst == xr.Dataset():
    ra12.ReadSST()
#+END_SRC

# plot results
#+BEGIN_SRC ipython :session
trange = slice('2014-10-07','2014-10-11')
hudhud = slice('2014-10-08','2014-10-10 12:00')

uTx = (ra12.sst.Tx.sel(time=trange)
       ,* ra12.vel.u.squeeze().resample(time='D').mean(dim='time'))
vTy = (ra12.sst.Ty.sel(time=trange)
       ,* ra12.vel.v.squeeze().resample(time='D').mean(dim='time'))


meanvel = ra12.vel.sel(time=trange).mean()
meanSST = ra12.sst.sel(time=hudhud).mean()
meanSST = ra12.sst.sel(time=hudhud).mean()

mld = 15
Qadv = -(uTx + vTy) * 1025 * 4200 * mld
Qmean = -(meanvel.u * meanSST.Tx + meanvel.v * meanSST.Ty) * 1025 * 4200 * mld
print(Qmean)
print(Qadv.sel(time=hudhud).mean())

barwidth = 1e-4
f, ax = plt.subplots(2, 1)
for ee in est.keys():
    Jqvec = est[ee]['mm1'].Jq
    (Jqvec
     .resample(time='H').mean()
     .sel(time=trange)
     .plot(ax=ax[1], lw=1, label=ee))

    hb = ax[0].bar(ee, Jqvec.where(Jqvec > 0).sel(time=hudhud).mean(),
                   barwidth)
    ax[0].bar(ee, Jqvec.where(Jqvec < 0).sel(time=hudhud).mean(),
              barwidth, color=hb[0].get_facecolor())
    ax[0].plot(ee, Jqvec.sel(time=hudhud).mean(), 'k.')

ax[0].set_title('Mean heat flux (+/-) during Hudhud as fn(min_dTdz)')

hwda = (ra12.Jq.sel(depth=15, time=trange)
        .plot(ax=ax[1], add_legend=False, label='wda'))
ax[1].legend()

dcpy.plots.liney([ra12.Jq.where(ra12.Jq > 0).sel(depth=15, time=hudhud).mean(),
                  ra12.Jq.where(ra12.Jq < 0).sel(depth=15, time=hudhud).mean()],
                 ax=ax, color=hwda[0].get_color(), zorder=8)
dcpy.plots.liney(0, ax=ax, zorder=10, color='k', ls='-')
dcpy.plots.liney([Qadv.sel(time=hudhud).mean(), Qmean],
                 ax=ax, color='k', zorder=10)

plt.savefig('/home/deepak/bay/images/526-heat-flux-dTdz.png', bbox_inches='tight')
#+END_SRC

#+CAPTION: Sensitivity to ~min_dTdz~. Looks like there are a lot of observations at T_z ~ 1e-3. For lower values of ~min_dTdz~, there is a lot of +/- cancellation. Which do I believe? Bottom time series is hourly averaged Jq (for comparison with sally's paper). The WDA estimate in pink is still 60s-average.
[[file:images/526-heat-flux-dTdz.png]]

#+CAPTION: Turns out removing IC fits removes a lot of data during Hudhud.
[[file:images/wda-526-hudhud-jq-masking.png]]

* ECCO $K_d$
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgrONH8U.png
ecco = xr.open_dataset('../datasets/ecco/interp_Kd_ECCOv4.nc');

Kd = ecco.Kd_ECCOv4
Kd = xr.DataArray(Kd.values,
                  coords={'lon': Kd.lon.sel(i1=1).values,
                          'lat': Kd.lat.sel(i2=1).values,
                          'dep': Kd.dep.values},
                  dims=['lat', 'lon', 'dep'])

np.log10(Kd.sel(dep=50)).plot.contourf(levels=15);
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[200]:
[[file:images/temp/imgrONH8U.png]]
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgfv1To1.png
np.log10(Kd).sel(lon=90, lat=[12, 15], method='nearest').plot.line(y='dep', yincrease=False)
np.log10(Kd).sel(lon=[85.5, 87, 88.5], lat=8, method='nearest').plot.line(y='dep', yincrease=False)
plt.gca().set_ylim([500, 0])
dcpy.plots.linex(np.log10([1e-6, 1e-5, 5e-4]))
dcpy.plots.liney([15, 30, 45])
plt.xlim([-6.5, -3])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[388]:
: (-6.5, -3)
[[file:images/temp/imgfv1To1.png]]
:END:

* O_2, nutrients
** climatological profiles: basin-wide average
#+NAME: read-nutrients
#+BEGIN_SRC ipython :session :ipyfile :results none
o2 = xr.open_dataset('../datasets/woa13/woa13_all_o00_01.nc',
                     decode_times=False)
o2seas = xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_o*_01.nc',
                           decode_times=False)

n = xr.open_dataset('../datasets/woa13/woa13_all_n00_01.nc',
                     decode_times=False)
nseas = xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_n*_01.nc',
                           decode_times=False)

p = xr.open_dataset('../datasets/woa13/woa13_all_p00_01.nc',
                    decode_times=False)
pseas = xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_p*_01.nc',
                          decode_times=False)
i = xr.open_dataset('../datasets/woa13/woa13_all_i00_01.nc',
                     decode_times=False)
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/bay-chem-annual-mean.png
import bay

def plot_nutrients(nut, nutseas, var, ax, **kwargs):
    mean = (nut[var+'_mn'].sel(**bay.region)
            .mean(dim=['lat', 'lon']).squeeze())
    if ax[0] is not None:
        (mean.plot(ax=ax[0], y='depth', yincrease=False, color='k',
                   lw=2, zorder=10, **kwargs))
        plt.gca().set_ylim([150, 0])

    if var != 'o':
        ((mean/mean.sel(depth=150, method='nearest'))
         .plot(ax=ax[1], y='depth', yincrease=False, **kwargs))
    else:
        ((mean/mean.max())
         .plot(ax=ax[1], y='depth', yincrease=False, **kwargs))

    if nutseas is not None:
        (nutseas[var+'_mn'].sel(**bay.region)
         .mean(dim=['lat', 'lon']).squeeze()
         .plot.line(ax=ax[0], y='depth', yincrease=False, hue='time', **kwargs))

f, ax = plt.subplots(1, 4, sharey=True)
f.set_size_inches(8,4)
plot_nutrients(o2, o2seas, 'o', [ax[0], ax[-1]], add_legend=False)
plot_nutrients(n, nseas, 'n', [ax[1], ax[-1]], add_legend=False)
plot_nutrients(p, pseas, 'p', [ax[2], ax[-1]])
plot_nutrients(i, None, 'i', [None, ax[-1]])

ax[-1].set_title('')
ax[-1].set_xlabel('Normalized profile')
ax[-1].set_xlim([0, 1])
ax[-1].legend(['O₂', 'N', 'P', 'Si'])

[aa.set_ylabel('') for aa in ax[1:]]
f.suptitle('Average oxygen, nutrient distributions (WOA13) for Bay of Bengal')
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[166]:
: Text(0.5,0.98,'Average oxygen, nutrient distributions (WOA13) for Bay of Bengal')
[[file:images/bay-chem-annual-mean.png]]
:END:
** seasonality in nutrient fluxes?
#+BEGIN_SRC ipython :session :ipyfile images/temp/img41q71z.png
import bay

region = dict(lon=slice(85.5, 88.5), lat=slice(5.5, 8.5))

nmean = (nseas.n_an
         .sel(**region)
         .mean(dim='lon')
         .mean(dim='lat'))
(nmean.groupby('time.season').mean(dim='season'))
#+END_SRC

** map the OMZ
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgCN0V8s.png
(o2seas.o_an.sel(**bay.region)
.sel(lon=87.5)
.plot.contour(col='time', col_wrap=3, robust=True, aspect=2,
              yincrease=False, ylim=[400, 0],
              cmap=mpl.cm.Blues, labels=True,
              cbar_kwargs={'label': '$$O_2$$'}))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[9]:
: <xarray.plot.facetgrid.FacetGrid at 0x7fda7d5f27f0>
:END:
** gyaan
cite:Sarma2016
1. Primary production is comparable to AS for NE and transitions but /lower/ for SW.
2. Cold-core eddies uplift nutrients?
3. Silicate is not a limiting nutrient
4. More depletion of N, P in the north

cite:Vinayachandran2005:
#+BEGIN_QUOTE
Biological productivity in the Bay of Bengal is believed to be considerably less than in the Arabian Sea, particularly during the summer monsoon [Kumar et al., 2002; Madhupratap et al., 2003]. A possible reason for this difference is that the Bay receives large quantities of freshwater from rainfall and rivers. The fresh water caps the upper layer of the northern Bay and neighboring coastal regions, leading to the formation of a barrier layer [Vinayachandran et al., 2002] that can affect thermodynamic processes in the mixed layer. Specifically, the strong stratification due to the barrier layer impedes the transfer of nutrients into the euphotic zone from below [Gomes et al., 2000].
#+END_QUOTE
* MISO signals
** MISO gyaan
strong correlation between SST variations and wind speed in 10-90 day band over North Indian Ocean.

correlation is over large spatial scales. moored observations might not be best platform?

+2+ 3 modes of /atmospheric/ variability:
  - *10-20 (25) day mode* moves westward from the Pacific Ocean
    - 5 km/day has some northward movement too
  - *30-40(60) day mode* /boreal summer ISO/  moving /approx/ north from the equatorial indian ocean
    - This mode sees largest SST response : 1-1.5C changes citep:Sengupta2001a. These perturbations propagate northward
    - The active-break cycle is forced by atmospheric dynamics at least in the summer
    - northward propagation could be a result of SST response.
    - 1°-2° latitude/day
    - _No contribution_ from reflected Rossby waves
  - *90-day mode* preferential excitement of Kelvin & Rossby waves by "larger scale, 90-day winds" + enhancement by reflected Rossby waves.

One view is that the 10-20 day and 30-40 day modes constructively interfere to form active spells (Krishnamurti, Masunari ...).

Prior to the active phase of the MISO, basin-wide warm SST anomalies up to 1°C occur in the entire BoB and favor the development of MISO convection [Sengupta et al., 2001; Kemball-Cook and Wang, 2001; Joseph and Sabin, 2008]. The MISO convection causes basin-wide SST cooling in the BoB, which suppresses convection and leads to the subsequent dry condition (break spell) [Vecchi and Harrison, 2002].

Wintertime intraseasonal variability = oceanic mesoscale.

Salinity changes well correlated with meridional velocity changes → NS advection of gradient. T-S relation would let you remove temperature advection signal? (MISOBOB whitepaper)
  [[file:images/misobob-15n90e-filtered-TSv.png]]
*** GS Bhat / Debasis talk
1. Air temperature shows peaks more than RAMA data. WHOI 18N SST shows more peaks
2. Spectra show different peaks, i.e. timescales are different, depending on variable used...
3. 20-day westward mode: propagates over from South China Sea, over Bay then moves northward.
4. Hole in total PPT and variance near Sri Lanka
5. 7-25, 25-80 day variances are max over water and very low over land
*** cite:Li2018
- CFSv2 better than CFSv1; operational by IITM
- ignroe the 10-20day; focus on 30-60d mode

#+BEGIN_QUOTE
Systematic biases for MISOs, however, still exist, exhibiting apparently weaker amplitude and slower northward propagation compared to observations. The eastern Arabian Sea (EAS)–western Bay of Bengal (WBB) region (EAS–WBB region; 128–208N, 658–858E) is found to be critical for the MISO prediction. In that region, the forecast and observed MISO trajectories begin to bifurcate from each other, and forecast errors grow rapidly. Further diagnosis reveals that local air–sea interaction in that region is severely underrepresented in CFSv2. Sea surface temperature (SST) response to surface heat flux forcing and convection response to SST forcing are both too weak, leading to the underestimated MISO amplitude.
#+END_QUOTE
*** cite:Han2005
- wind spectra peak is at 30-60 days; indian ocean response peak is at 90 days → resonance
- Reflected Rossby waves result in interior signal.
- Most of the energy is near the equator.
- Almost nothing along the 90E line, north of 10N ☹.
- Critical latitude for Rossby waves predicts importance of remote forcing in interior. North of 10N, we should see peaks for T > 70 days forced by equatorial winds.
*** cite:Cheng2013
  - apparently the 90 day peak is a thing.
*** cite:Vialard2012
  - Strongest SST response is seen in the north - off Oman and BoB north of 15N
  - Most of AS response → wind stress forcing
  - Concurrent with the northward propagation of atmospheric intraseasonal oscillations, the SST variations appear first at the southern tip of India (day 0), in the Somali upwelling (day 10), northern Bay of Bengal (day 19) and finally Oman upwelling (day 23), as the atmospheric intraseasonal oscillation moves northward.
*** cite:Li2017
  - Salinity stratification and SST
    - shallow MLD → traps heat → *enhanced SST variability*
    - barrier layer suppresses heat exchange between warm mixed layer and thermocline
      → maintains high SST and hence convective activity.

  - 10-80m barrier layers seen in RAMA measurements.

  - Passage of MISO → deeper MLD, ILD
    - MLD, ILD are shallower before convection and deeper after convection.
      - MLD ← winds | ILD ← heat flux
    - thinner barrier layers before & during active phase.
    - Barrier layer thickens but composite trends tend to be weak
      - different influencers for MLD/ILD ⇒ BLT = random cancellations
    - peak-to-peak changes are O(10-20m)
    [[file:images/li-2017-miso-map.png]]

  - removing the ISO signals in /all atmospheric forcing/ recreates pattern seen in unmodified simulation.
    → the observed MLD/BLT variability is all being driven by the oceanic mesoscale.
    - hence, MISO composites are averages over random phases of this variability?

  - Northern bay: SSS anomalies are driven by wind-forced advection
    #+ATTR_HTML: :width 100%
    #+CAPTION: t=0 is max PPT.
    [[file:images/li-2017-miso-wind-sss.png]]
    - break phase = westward surface currents = move low salinity water into the bay
    - active phase = eastward surface currents = move high salinity water across the bay & compress freshwater plume against land
    - form cyclonic/anticyclonic gyres (right after active/break) near coastal Bangaladesh = thermocline shoaling & baroclinic wave response.

  - *WHEN AVERAGED OVER LARGE AREA*
    - wind → MLD through mixing / freshwater advection
    - heat flux → Isothermal Layer depth

  - Local changes in ILD are mostly mesoscale variability.
*** cite:Li2017a
*Summary:* From May to mid-June, the shallow MLD and thin barrier layer greatly enhance intraseasonal SST anomalies, which can amplify convection fluctuations of the MISO through air-sea interaction and leads to intense but short duration post-convection break spells. When either the MLD or the BLT is large, intraseasonal SSTs tend to be weak.

- Duncan and Han [2009] found that Q_T  (latent + sensible)  is important in producing intraseasonal SSTs in the BoB, whereas Vialard et al. [2012] emphasized SWR as the dominant driver, and both studies suggested weak effect of wind stress forcing.
  - Our result to some degree reconciles the two previous studies, _confirming the dominance of surface heat flux and showing the equal contributions from SWR and Q_T_.

- The weak wind stress effect here is a dramatic difference from the cases in other regions. Wind stress-driven ocean processes, especially vertical entrainment, are of first-order importance in producing intraseasonal SSTs in other regions, such as the southern and equatorial Indian Ocean

- intraseasonal SST fluctuations affects convection primarily in May-June
  - thin mixed layer + thin barrier layer
  - weaker break + stronger active phase = more P
  - shallow MLD ⇒ more deepening during cooling phase; thin BLT means more entrainment cooling ⇒ more intense break (i.e. much larger -ve P anomaly)
  - As a result of this series of air-sea interaction processes, the MISOs developed under the double-small ocean condition induce strong intraseasonal fluctuations in rainfall variability with usually intense but short-duration break spells, while otherwise the break spells are weak but prolonged.
   [[file:images/li-2017-miso-mld-blt.png]]

- Barrier layer effects on SST seen in post-convection cooling not pre-convection warming.
*** cite:Vecchi2002
  - Under active atmospheric convection, SST cools in Bay > 4N.
  - Cooling eventually shuts down convection.
  - SST minima precedes convection (shutdown?) by ~ 10 days
  - warm SST anomaly precedes active convection
*** cite:Sengupta2001a
  - SST oscillations are driven by surface heat flux changes ← both wind speed + atmospheric deep convection. Mostly Shortwave!
  - ∂(SST)/∂t ∝ Q_net for SW monsoon but not so much in Oct --- they say this is due to barrier layer / fresh water advected over the mooring.

*** cite:McPhaden2009
- see long Rossby waves (120 day period) in RAMA record?

** Summary
cite:Sobel2010 show large TRMM 30-90 day variance between May and October in the Bay.
[[file:../images//sobel-trmm-variance.png]]

#+CAPTION: Subsurface anomalies line up with northward propagating features in SST, LWR.
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]

#+CAPTION: Southward propagating signals in 2011-Nov/Dec!
#+RESULTS:
[[file:images/bandpass-90e-2011.png]]

*** old                                                          :noexport:
I see northward propagating "anomalies" in Tropflux SWR.
[[file:images/90e-swr-anom.png]]
** in mixing
*** RAMA 12N
**** Coherence
- Note sure coherence is the way to do this given short records

The next figure shows coherence between Jq0 and  Jqt at 15m, 30m at the RAMA 12N mooring for the year 2014. Signs for all fluxes are such that +ve warms the surface.
Looks like we have significant coherence in the 20-60day band between daily averaged Jq0 and Jqt at 15m.
The 180 phase difference looks stable, is apparent in the filtered time series and seems to make physical sense (more surface heating → increases T_z → reduces J_q^t and vice versa).

Nothing at 30m
 - short(er) data record - instrument dies in september
 - not much temp fluctuations at that depth while the instrument was alive (see above).

#+CAPTION: (Top left) Band-passed time series. (bottom left) PSD for the unfiltered time series. (Right) coherence amplitude and phase between J_q^0 and J_q^t at both depths. Significance level marked by horizontal line. Pass band marked by vertical lines.
file:rama/images/ra12-jq0-jqt-coherence.png
** temp / salinity record
*** Stratification T_z
Filtered T_z?
#+BEGIN_SRC ipython :session :ipyfile images/ra12n-bandpass-strat.png
from dcpy.plots import offset_line_plot
f, ax = plt.subplots(4, 1, sharex=True)

trange = slice('2014-06', '2014-08')
T = rama.SelectVar('T', dict(lon=90))
Tz = (T.sel(lat=12)
      .dropna(dim='depth', how='all')
      .drop(-13, dim='depth')
      .diff(dim='depth'))
Tz /= Tz.sel(time=trange).std(dim='time')
Tzbp = (Tz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Tzbp /= Tzbp.sel(time=trange).std(dim='time')

S = rama.SelectVar('S', dict(lon=90))
Sz = (S.sel(lat=12)
      .dropna(dim='depth', how='all')
      .diff(dim='depth'))
Sz /= Sz.sel(time=trange).std(dim='time')
Szbp = (Sz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Szbp /= Szbp.sel(time=trange).std(dim='time')

dcpy.plots.offset_line_plot(
    Tz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[0])

dcpy.plots.offset_line_plot(
    Tzbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[1])

dcpy.plots.offset_line_plot(
    Sz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[2])

dcpy.plots.offset_line_plot(
    Szbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[3])

ax[0].set_ylabel('$ΔT$')
ax[1].set_ylabel('$ΔT$\'')
ax[2].set_ylabel('$ΔS$')
ax[3].set_ylabel('$ΔS$\'')

dcpy.plots.liney(0, ax=ax[0])
dcpy.plots.liney(0, ax=ax[1])

plt.suptitle('10-80 day bandpass filtered at χpod depths / normalized by std.', y=1.0)
plt.tight_layout()
plt.gcf().autofmt_xdate()
#+END_SRC

#+RESULTS:
[[file:images/ra12n-bandpass-strat.png]]
*** Subsurface MISO signals?
What am I looking for?
1. northward propagation of MISO signal
2. subsurface MISO signals in 30d-90d band

#+BEGIN_SRC ipython :session :ipyfile images/temp/asd02j.png :noweb yes
if 'rama' not in locals():
     print('reading rama')
     <<read-rama-array>>

flen = np.array([10.0, 80.0])
hdl, var = rama.hov('T', region=dict(lon=90, depth=[-1, -10, -20]),
                    row='depth', filt='bandpass',
                    filter_len=flen*86400)

plt.gcf().set_size_inches((8.5, 2.5))
plt.gca().set_xlim(['2011-01-01', '2013-07-01'])
plt.gcf().autofmt_xdate()
# plt.gcf().suptitle('bandpass ' + str(flen) + 'days')
#+END_SRC
#+CAPTION: Hovmöller plot of RAMA 90E data | Bandpassed 10, 80 days. Looks like _southward_ propagation in Nov/Dec 2011.
#+RESULTS:
[[file:images/temp/asd02j.png]]
#+BEGIN_SRC ipython :session :ipyfile images/rama-iso-T-std.png :noweb yes
if 'rama' not in locals():
    <<read-rama-array>>

from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

Tfilt = BandPassButter(rama.T.where(rama.T < 40), freqs=freqs, dim='time')

MayToOct = np.logical_and(Tfilt.time.dt.month >=5,
                          Tfilt.time.dt.month <= 10)

def plot_temp_std_along_lon(Tfilt, inmask, lon):
    f, ax = plt.subplots(2, 2, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx], cmap=mpl.cm.Reds))

        # normalize at each lat,lon by maximum in depth
        Tnorm = Tstd / Tstd.max(dim='depth')
        Tnorm.name = 'normalized to \n show structure'
        (Tnorm.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx+2], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_along_lon(Tfilt, MayToOct, lon=90)
#+END_SRC
#+CAPTION: Lon = 90: Max 30-90 day std dev is within 5S-5N as expected from Han (2005). Seems independent of season. Subsurface peak = thermocline? Agrees with Girishkumar et al (2013)
#+RESULTS:
[[file:images/rama-iso-T-std.png]]

#+BEGIN_SRC ipython :session :ipyfile images/iso-T-std-lat-lon-map.png
def plot_temp_std_lat_lon(Tfilt, inmask):
    ''' Takes max. std along depth and plots in (lon, lat) space'''
    f, ax = plt.subplots(2, 1, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.dropna(dim='depth', how='all')
             .dropna(dim='lat', how='all')
             .max(dim=['depth']).transpose()
             .plot(ax=ax[idx], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_lat_lon(Tfilt, MayToOct)
#+END_SRC
#+CAPTION: Taking max(std) along depth → (lon, lat) map. Some sign of near-equatorial maxima.
#+RESULTS:
[[file:images/iso-T-std-lat-lon-map.png]]


#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907n9q.png
from dcpy.ts import apply_along_dim_1d

freqs = [1/30.0, 1/60.0]

T = rama.T.copy()

T.values[T.values > 40] = np.nan

apply_along_dim_1d(T, 'time', dcpy.ts.FillGaps, x=T.time, maxlen=20)

bp = (BandPassButter(T.sel(lon=90, lat=[15, 12, 8])
                     .dropna(dim='time', how='all'),
                     freqs=freqs, dim=['time'])
      .dropna(dim='depth', how='all'))

bp.plot.contourf(row='lat', x='time', levels=40)
plt.gcf().set_size_inches((8.5, 4.5))
plt.gca().set_ylim([-140, 0])
# plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img3907n9q.png]]

#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img9554Dcu.png
from dcpy.plots import offset_line_plot

T = rama.SelectVar('T', dict(lon=90.0))

T = T.groupby('time.month') - T.groupby('time.month').mean(dim='time')
Tclim = T.groupby('time.dayofyear').mean(dim='time')
Tanom = T.groupby('time.dayofyear') - Tclim


offset_line_plot(T.sel(depth=-1)
           .dropna(dim='time', how='all'),
          x='time', y='lat')
plt.gca().set_xlim('2011', '2014')

# Tanom.sel(depth=-1).plot()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC

#+RESULTS:
[[file:images/temp/img9554Dcu.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-90e-2014.png :noweb yes
freqs = [1/10.0, 1/80.0]
time = '2015'

<<bandpass-mosaic>>
#+END_SRC
#+CAPTION: Southward propagating signals in 2011-Nov/Dec, but not so much in 2014?
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]
*** Spectra
#+call: read-mur()

#+NAME: calc-spec
#+BEGIN_SRC ipython :session :results none
import xarray as xr
from dcpy.ts import SpectralDensity

var = rama.SelectVar('T', region=dict(lon=90, lat=12)).dropna(dim='depth', how='all')

iz = var.get_axis_num('depth')

spec = []
for zz in range(var.shape[iz]):
    S, f, conf = SpectralDensity(var.isel(depth=zz), dt=1,
                                 multitaper=False, nsmooth=2,
                                 fillgaps=True, maxlen=60)
    # create a DataArray
    spec.append(xr.DataArray(S, coords=[f], dims=['freq'],
                             attrs={'depth': var.depth.values[zz]},
                             name='PSD'))
#+END_SRC

:code-notes:
1. Let's try FFT - yes, using ~apply()~ works like doing things manually. +But results look weird+ xarray isn't respecting missing_value; haven't figured out why :(

2. bah gaps are non-uniform at all depths. can't do the groupby-apply thing. lets make a list of DataArrays and iterate over them when we plot.

3. xarray line-plots are only for 1D data.

:END:
#+CALL: calc-spec()
#+BEGIN_SRC ipython :session :ipyfile images/12n-spectra.png :exports results
if 'mur' in locals():
    S, f, conf = dcpy.ts.SpectralDensity(mur['sst'].sel(lon=90, lat=12), multitaper=True)
    plt.loglog(f, S*10**1.25, label='SST', lw=0.5)

for si, ss in enumerate(spec[0:8]):
    (ss*10**-si**1.15).plot(label=str(ss.depth), lw=0.5)

plt.title('12N 90E')
ax = plt.gca()
ax.set_xscale('log')
ax.set_yscale('log')
ax.legend()
plt.gcf().set_size_inches(8.5, 5.5)
plt.xlim([10**-3.5, 1])
#+END_SRC

#+RESULTS:
[[file:../images/12n-spectra.png]]

*** spectra old :noexport:
#+BEGIN_SRC ipython :session :ipyfile images/temp/img16594-DQ.png
data = rama.SelectVar('T', region=dict(lon=90, lat=12, depth=10))

S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=True)
plt.loglog(f, S)
S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=False)
plt.loglog(f, S)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img16594-DQ.png]]

#+BEGIN_SRC ipython :session
%matplotlib inline

import moor.moor as moor
import chipy.chipy as chipy

moor = importlib.reload(moor)
chipy = importlib.reload(chipy)

import os
if 'rama' not in os.getcwd():
    os.chdir('/home/deepak/rama/scripts/')

ra12 = moor.moor(90, 12, 'RAMA 12N', '../RAMA13/')
# ra12.AddChipod(526, 15, 'mm', '2017-07-10.mat')
# ra12.AddChipod(527, 30, 'mm', '2017-07-10.mat')
ra12.ReadMet('../RAMA13/rama_mooring_data/', WindType='pmel')
# ra12.ReadCTD('../RamaPrelimProcessed/RAMA13.mat', 'ramaprelim')
ra12.ReadCTD('../data/', 'rama')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :session :ipyfile images/temp/py28335Frc.png
dcpy.ts = importlib.reload(dcpy.ts)
dcpy.oceans = importlib.reload(dcpy.oceans)
dcpy.plots = importlib.reload(dcpy.plots)

freqs = [1/(2*np.pi/dcpy.oceans.inertial(ra12.lat)/86400),
         dcpy.ts.AliasFreq(1/(12.42/24), 1),
         1/30, 1/90]

nsmooth = 4
subset = None
mtflag = True

plt.figure(figsize=(6.5, 10.5))
ax0 = plt.subplot(211)
dcpy.ts.PlotSpectrum(ra12.ctd.Tlong, SubsetLength=subset, ax=ax0,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
ax0.set_ylabel('PSD (T)')
if mtflag:
    ax0.set_title('Multitaper')

dcpy.plots.linex(freqs)
ax1 = plt.subplot(212, sharex=ax0)
dcpy.ts.PlotSpectrum(ra12.ctd.Slong, SubsetLength=subset, ax=ax1,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
dcpy.plots.linex(freqs)
ax1.set_ylabel('PSD (S)')
ax1.set_xlabel('Freq (cpd)')

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//temp/py28335Frc.png]]

** winds at EBOB and rama
#+BEGIN_SRC ipython :session :ipyfile images/bob-winds.png
from scipy.interpolate import interpn

tau = nc.MFDataset('../tropflux/tau_tropflux*')
flx = nc.MFDataset('../tropflux/netflux_tropflux*')

ttime = tau['time'][:]
ftime = flx['time'][:]

ax = [1, 1, 1, 1]
ax[0] = plt.subplot(4, 1, 1)
ax[0].set_title('RAMA')
ax[1] = plt.subplot(4, 1, 2, sharex=ax[0])
ax[1].set_title('EBOB')
ax[2] = plt.subplot(4, 1, 3, sharex=ax[0])
ax[2].set_title('RAMA')
ax[3] = plt.subplot(4, 1, 4, sharex=ax[0])
ax[3].set_title('EBOB')

for latm, lonm in zip([12, 18, 5.5, 8],
                     [90, 90, 85.5, 88.5]):

    if latm < 12:
        ind = 1
    else:
        ind = 0

    label = str(latm) + 'N, ' + str(lonm) + 'E'
    τtrop = interpn((ttime,
                     tau['latitude'][:],
                     tau['longitude'][:]),
                    tau['tau'][:, :, :],
                    (ttime, latm, lonm))
    ftrop = interpn((ttime,
                     flx['latitude'][:],
                     flx['longitude'][:]),
                    flx['netflux'][:, :, :],
                    (ttime, latm, lonm))
    ttrop = ttime \
            + dt.date2num(dt.datetime.date(1950, 1, 1))

    ax[ind].plot(ttrop, τtrop, label=label)
    ax[ind+2].plot(ttrop, ftrop, label=label)

for ind in [0,1]:
    ax[ind].xaxis_date()
    ax[ind].legend()
    ax[ind].set_ylim([0, 0.4])
    ax[ind].set_ylabel('τ (N/m²)')
    ax[ind+2].set_ylabel('flux (W/m²)')

ax[0].set_xlim([dt.datetime.datetime(2013, 11, 29, 0, 0, 0),
                dt.datetime.datetime(2015, 1, 1, 0, 0, 0)])
ax[2].axhline(0, color='gray')
ax[3].axhline(0, color='gray')
plt.gcf().autofmt_xdate()
plt.tight_layout()
#+END_SRC
#+RESULTS:
[[file:../images//bob-winds.png]]
** in SWR
Look at anomalies:
1. Subtract yearly average.
2. Subtract daily climatology (2001-2017)

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-anom.png :noweb yes
if 'swr' not in locals():
    <<read-tropflux-swr>>
swr['swr'].load()

grpstr = 'time.dayofyear'

# pick location
sw = swr['swr'].sel(longitude=90.5, latitude=slice(0.5, 22.5))
# remove yearly average
swa = (sw.groupby('time.year')
       - sw.groupby('time.year').mean(dim='time'))
# make daily climatology
clim = sw.groupby(grpstr).mean(dim='time')
# get daily anomalies
anom = sw.groupby(grpstr) - clim

f, ax = plt.subplots(3, 1, sharey=True)

(anom.sel(time=slice('2014-05', '2014-09'))
     .plot(x='time', y='latitude', ax=ax[0]))
(anom.sel(time=slice('2015-05', '2015-09'))
     .plot(x='time', y='latitude', ax=ax[1]))

(anom.sel(time=slice('2013', '2016'))
     .groupby('time.dayofyear')
     .mean(dim='time')
     .plot(x='dayofyear', y='latitude', ax=ax[2]))
ax[2].set_title('anomalies averaged over 2013-2016')

ax[0].set_xlabel('')
ax[1].set_xlabel('')
ax[1].set_title('')

plt.tight_layout()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC
#+CAPTION: Shortwave radiation anomalies w.r.t daily climatology [2001-2017]. Definitely see northward propagating anomalies along 90°E. Propagation is most evident for lat > 8°N. Winter is quite for lat > 10.
#+RESULTS:
[[file:images/90e-swr-anom.png]]

Let's try 10-80day filter like cite:Sengupta2001a
#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SWR.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

if 'swr' not in locals():
    swr = xr.open_mfdataset('../datasets/tropflux/swr*.nc')

swr['swr'].load()

bp = (
    swr['swr'].sel(longitude=[85, 90], method='nearest')
    .pipe(BandPassButter, freqs, dt=1, dim='time')
)

bp.sel(time='2014').plot(x='time', row='longitude')

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC
#+CAPTION: bandpass filter yields same results as above (slightly smoother).
#+RESULTS:
[[file:images/bandpass-SWR.png]]

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-spec.png
dcpy.ts.PlotSpectrum(swr['swr'].sel(latitude=[15, 12, 8], longitude=90, method='nearest'), multitaper=True, nsmooth=5, scale=5)
dcpy.plots.linex([1/10.0, 1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0, 1/120, 1/180, 1/360])
plt.title('Tropflux SWR spectra along 90E')
plt.legend(('15N', '12N', '8N'))
#+END_SRC
#+CAPTION: Spectra of SW radiation along 90°E. Seasonal cycle harmonics are very evident 360, 180, 90, 45. 120-day peak at 8N, 12N.
#+RESULTS:
[[file:images/90e-swr-spec.png]]

** SST analysis
*** test snapshot
#+CALL: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907o-U.png
mur['sst'].isel(time=1).plot()
#+END_SRC
#+CAPTION: Test snapshot
#+RESULTS:
[[file:../images//temp/img3907o-U.png]]
*** spec
#+call: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/mur-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

# psd = xrft.power_spectrum(mur['sst'].sel(lon=90, lat=12), dim=['time'], density=True, window=True, detrend='constant')
scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = mur.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('MUR SST spectra along RAMA line')
plt.legend()
#+END_SRC
#+CAPTION: MUR SST spectra 2013-2016
#+RESULTS:
[[file:images/mur-spectra-RAMA-line.png]]


#+BEGIN_SRC ipython :session :ipyfile images/cmc-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = cmc.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('CMC SST spectra along RAMA line (2007-2017)')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:images/cmc-spectra-RAMA-line.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SST.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]


(cmc['sst'].sel(lon=[85, 90], method='nearest')
           .where(cmc.mask == 1)
           .pipe(BandPassButter, freqs, dt=1, dim='time')
           .sel(time='2014')
           .plot(x='time', row='lon'))

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC

#+RESULTS:
[[file:images/bandpass-SST.png]]
*** SST variance map
#+BEGIN_SRC ipython :session :results none
freqs = [1/30.0, 1/90.0]

bp = dcpy.ts.BandPassButter(sst, freqs=freqs, dim=['time'])
bp = bp.dropna(dim='time', how='all')

# dcpy.ts.PlotSpectrum(mur['sst'].sel(lon=90, lat=12))
# dcpy.plots.linex(freqs)
# dcpy.ts.PlotSpectrum(bp.sel(lon=90, lat=12))
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907dce.png]]
#+BEGIN_SRC ipython :session :results none
import matplotlib.animation

def animate(i):
    import matplotlib.pyplot as plt
    plt.clf()
    hdl = bp.isel(time=i).plot()
    return hdl

anim = mpl.animation.FuncAnimation(plt.gcf(), animate)

anim.save('sst-iso.mp4', fps=5)
#+END_SRC
** scalogram?
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgu5NuXe.png
dcpy.ts.plot_detailed_scalogram(m.tropflux.swr.dropna(dim='time'))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[336]:
#+BEGIN_EXAMPLE
  array([<matplotlib.axes._subplots.AxesSubplot object at 0x7f1822c49978>,
  <matplotlib.axes._subplots.AxesSubplot object at 0x7f1822bf5a20>],
  dtype=object)
#+END_EXAMPLE
:END:

* Model biases
** Summary
1. There is a dry bias over central India.
2. cold bias above 80m and warm bias below 100m.
3. saline bias above 80m too
** papers

- cite:Koul2018
  - Using an ocean initial condition obtained by assimilating Argo improves stratification profile in Bay of Bengal → reduces mixing → reduces bias.
  - Apparently one approach is to use "synthetic salinity profiles" where S = T-S relationship × T. Using plain Argo works better than Argo + synthetic salinity.
  - Improved upper ocean state improves precipitation forecasts.

- cite:Chowdary2016
 #+BEGIN_QUOTE
 The surface salinity bias in MOM5 is smaller than in CFSv2 due to prescribed local freshwater flux and seasonally varying river discharge. However, the bias is higher around 70 m in summer and 40 m in fall. This bias is attributed to excessive vertical mixing in the upper ocean. Despite the fact that representation of salinity in INC-GODAS is more realistic due to data assimilation, the vertical mixing scheme still imposes systematic errors.
 #+END_QUOTE

  1. CFSv2 shows very high salinity in the upper 20 m north of 14°N for all seasons.
  2. CFSv2 displays a large cold bias for the upper 80 m of the water column, a positive bias in salinity from the surface to 100 m depth, and a positive bias in density up to 60 m depth
  3. CFSv2 displays a too-weak stability for the upper 100 m as compared to WOA13
  4. vertical shear is higher in all models compared to ECCO2
  5. CFSv2, biases are consistent with excessive mixing, bringing cold, saline water upward and resulting in a positive bias in temperature below 80 m and a reduced bias in salinity below 60 m (Figure 2d,e). This prescribed mixing is likely triggered by subcritical Richardson numbers, due to a combination of high shear and low stratification in the model.
  6. However, precipitation in general is underestimated over most of the BoB, which arises from the biased rainfall simulation from the GFS.This strong positive E−P in the model would contribute to the high salinity bias, especially in the surface layer of the BoB in CFSv2.

  #+BEGIN_QUOTE
  Much of the surface layer in the BoB is freshwater stratified, so subject to the “interior ocean mixing” portion of KPP. Internal wave breaking in this layer is likely much more related to locally wind-generated near-inertial internal waves than the background levels assumed in KPP (Johnston et al., 2016, in this issue), and needs to be parameterized differently
  #+END_QUOTE

- cite:Chowdary2016a:
 #+BEGIN_QUOTE
  CFSv2 ... displays warm (cold) subsurface (surface) temperature bias in the tropical Indian Ocean (TIO), with deeper than observed mixed layer and thermocline. In the model, the maximum warm bias is reported between 150- and 200-m depth. Detailed analysis reveals that the enhanced vertical mixing by strong vertical shear of horizontal currents is primarily responsible for TIO subsurface warming.
 #+END_QUOTE
  1. CFSv2 is known to suffer from strong cold sea surface temperature (SST) bias over the TIO
  2. The cold bias in TIO SST is common to almost all phase 5 of the Coupled Model Intercomparison Project (CMIP5) climate models.
  3. Strong shear enhances the mixing of the upper ocean and weakens stability, leading to subsurface warming in the TIO. This excess mixing supports positive salinity bias in the upper few hundred meters.
  4. To estimate bias in CFSv2 VTHF (vertical turbulent heat flux), we have generated K_h from stand-alone ocean model MOM5 (considered as a reference profile), which is forced with observed winds.
     [[file:images/chowdary-2016-cfs-biases.png]]
  5. the subsurface warm bias is mainly caused by excess vertical shear of horizontal currents’ induced downward transfer of heat.

- cite:Chaudhari2013
  - CFS (*not CFSv2*) SST shows cold bias in EBoB region
* vel spectra
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907nzu.png
u = rama.SelectVar('u', region=dict(lon=90, lat=12))
v = rama.SelectVar('v', region=dict(lon=90, lat=12))
KE = 0.5*np.hypot(u,v)

dcpy.ts.PlotSpectrum(KE)
dcpy.ts.PlotSpectrum(KE, multitaper=True)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907nzu.png]]


#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907fRQ.png
np.sqrt(N2).plot()
plt.ylabel('N (1/s)')
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907fRQ.png]]

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907mHE.png
KE = np.hypot(ra12.vel.u, ra12.vel.v)*2

dcpy.ts.PlotSpectrum(KE, dt=30*60.0, multitaper=False, label='KE 10m')

# figure out N²
woa = dcpy.oceans.ReadWoa(lon=90, lat=12, return_xr=True)
N2, _, pn2 = sw.bfrq(woa['S'], woa['T'], woa['depth'], lat=12)

N2 = xr.DataArray(np.squeeze(N2), coords=[np.squeeze(pn2)], dims=['depth'])
N = np.sqrt(N2)
omg, K_omg, P_omg, _, _, _ = dcpy.oceans.GM(lat=12.0,
                                            N=N.sel(depth=10, method='nearest').values,
                                            N0=N.sel(depth=50, method='nearest').values)

# plot frequency spectra
ax = plt.gca()
ax.loglog(omg/(2*np.pi), 2*np.pi*K_omg, label='GM81 KE')
ax.loglog(omg/(2*np.pi), 2*np.pi*P_omg, label='GM81 PE')
ax.legend(frameon=False)
ax.set_title('energy spectra')
ax.set_xlabel('frequency (cps)')
ax.set_ylabel('power spectral density (m^2/s^2/cps)')

#+END_SRC
#+CAPTION: Attempt at GM spectra for KE
#+RESULTS:
[[file:../images//temp/img3907mHE.png]]

* TS plots
#+BEGIN_SRC ipython :session :results none
import pickle

ctd = dict([[m.short_name, m.ctd]
            for m in [ra12, ra15, nrl1, nrl2, nrl3, nrl4, nrl5]])
with open('all-ctd.pickle', 'wb') as f:
    pickle.dump(ctd, f, pickle.HIGHEST_PROTOCOL)
#+END_SRC

#+BEGIN_SRC ipython :session :results none
if 'turb' not in locals():
    turb = xr.open_dataset('./bay_merged_10min.nc')

if 'ctd' not in locals():
    import pickle
    with open('all-ctd.pickle', 'rb') as f:
        ctd = pickle.load(f)

bay.plots.KT_TS(turb, ctd, 'all')
plt.savefig('images/KT-TS.png')

bay.plots.KT_TS(turb, ctd, 'rama')
plt.savefig('images/KT-TS-rama.png')

bay.plots.KT_TS(turb, ctd, 'ebob')
plt.savefig('images/KT-TS-ebob.png')

#+END_SRC

[[file:images/KT-TS.png]]
[[file:images/KT-TS-ebob.png]]
[[file:images/KT-TS-rama.png]]


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgWOpRL6.png
import tqdm

f, ax = plt.subplots(3, 4, sharex=True, sharey=True, constrained_layout=True)
f.set_constrained_layout_pads(wpad=1/72, hpad=1/72, wspace=0.0, hspace=0.0)

seasons = ['NE', 'NESW', 'SW', 'SWNE']

axes = dict()
axes['KT'] = dict(zip(seasons, ax[0, :]))
axes['Jq'] = dict(zip(seasons, ax[1, :]))
axes['Js'] = dict(zip(seasons, ax[2, :]))

for var in tqdm.tqdm(['KT', 'Jq', 'Js']):
    bay.plots.KT_TS(turb, ctd, 'all', var, axes=axes[var],
                    cbar_kwargs={'orientation': 'vertical'})

[aa.set_xlabel('') for aa in ax[:-1, :].flat]
[aa.set_ylabel('') for aa in ax[:, 1:].flat]
[aa.set_xlabel('S') for aa in ax[-1, :].flat]
[aa.set_ylabel('T') for aa in ax[:, 0].flat]
plt.savefig('images/TS-all-turb.png')
#+END_SRC

#+ATTR_HTML: :class full-width
[[file:images/TS-all-turb.png]]

#+BEGIN_SRC ipython :session :ipyfile images/TS.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.TSPlot(ax=ax3)
nrl5.TSPlot(ax=ax1)
ra12.TSPlot(ax=ax2)

ax1.set_xlim([32, 36])
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//TS.png]]

#+BEGIN_SRC ipython :session :ipyfile images/KT-seasonal.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.ChipodSeasonalSummary(ax=ax3)
nrl5.ChipodSeasonalSummary(ax=ax1)
ra12.ChipodSeasonalSummary(ax=ax2)

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//KT-seasonal.png]]
* data processing
#+BEGIN_SRC ipython :session
Snew = xr.zeros_like(nrl5.ctd.T) * np.nan

for tt in Snew.time:
    Snew.loc[:, tt] = np.interp(nrl5.ctd.depth2,
                                nrl5.ctd.depth.loc[:, tt],
                                nrl5.ctd.S.loc[:, tt],
                                left=np.nan, right=np.nan)

Snew.attrs = nrl5.ctd.S.attrs
Snew.name = 'S'
Snew.to_netcdf('../intermediate-files/'+nrl5.name+'-sgrid.nc')

#+END_SRC

* MLD climatology

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907e_A.png
mld = dcpy.oceans.argo_mld_clim()

ax = plt.gca()
for lat in range(0, 22, 2):
    mld.mld_da_mean.sel(lon=90, lat=lat,
                        method='nearest', tolerance=1).plot(ax=ax, label=str(lat))

plt.title('lon=90.5')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907e_A.png]]

* ARGO data : S_min and S_max
[[file:../images//argo-smin-smax.png]]
* code tests
** MLD calc
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgJlnzfg.png
f, ax = plt.subplots(1,3)

it = 35000
ra15.ctd['T'].isel(time=it).plot(ax=ax[0])
dcpy.plots.linex(ra15.ild.isel(time=it), ax=ax[0])

ra15.ctd['S'].isel(time=it).plot(ax=ax[1])
dcpy.plots.linex(ra15.sld.isel(time=it), ax=ax[1])

ra15.ctd['ρ'].isel(time=it).plot(ax=ax[2])
dcpy.plots.linex(ra15.mld.isel(time=it), ax=ax[2])
#+END_SRC

#+RESULTS:
:RESULTS:
:END:
* sampling considerations
** ISO signals
Can I  see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907IKt.png
dt = 1  # day
N = 365  # number of days
smth = [1, 2, 3, 4, 5]  # nsmooth
periods = np.array([10.0, 20.0, 30.0, 50.0, 60.0, 90.0])  # peaks

ax = []
ax.append(plt.subplot(211))
ax.append(plt.subplot(212))

t = np.arange(N)
ts = dcpy.ts.synthetic(N, dt, 1, -3)

for tt in periods:
    ts += 1e3 * np.sin(2*3.14/tt * t)

for ss in smth:
    dcpy.ts.PlotSpectrum(ts, ax=ax[0], scale=5**-ss,
                         nsmooth=ss, label=str(ss))
    dcpy.ts.PlotSpectrum(ts, ax=ax[1], scale=5**-ss,
                         nsmooth=ss, label=str(ss),
                         multitaper=True)

ax[0].set_title('Varying smoothing | ' + str(N) + ' day daily timeseries')
ax[1].set_title('multitaper')
plt.legend()
# dcpy.ts.PlotSpectrum(ts, nsmooth=smth, multitaper=True)
dcpy.plots.linex(1/periods)
#+END_SRC
#+CAPTION: Can I see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+RESULTS:
[[file:../images//temp/img3907IKt.png]]o
** χpod depths for RAMA17

#+name: read-rama-10m
#+BEGIN_SRC ipython :session :results none
import xarray as xr
import pandas as pd

rama10 = xr.open_mfdataset('rama/data/t*90e_10m.cdf')
salhr = xr.open_mfdataset('rama/data/s[0-9]*90e_hr.cdf')

newtrange = pd.date_range(start=rama10.time.values.min(),
                          end=rama10.time.values.max(), freq='10min')
#+END_SRC

#+call: read-rama-10m()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427kYC.png
# ra12 = xr.open_dataset('rama/data/t12n90e_10m.cdf')
T = rama10.T_20.sel(depth=[10, 20, 40, 60])
T = T.reindex({'time': newtrange})
T = T.where(T < 40).squeeze()
Tz = -T.diff(dim='depth')/T.depth.diff(dim='depth')
Tz['depth'] = (T.depth.values[:-1] + T.depth.values[1:])/2
Tz.name = '$T_z$'

S = salhr.S_41.sel(lat=12, depth=[10, 20, 40, 60])
S = S.reindex({'time': pd.date_range(start=S.time.values.min(),
                                     end=S.time.values.max(), freq='1H')})
S = S.where(S < 40).squeeze()
Sz = -S.diff(dim='depth')/S.depth.diff(dim='depth')
Sz.name = '$S_z$'

N2 = -9.81 * (-1.7e-4 * Tz + 7.6e-4 * Sz)
#+END_SRC

#+RESULTS:
[[file:images/temp/img10427kYC.png]]

#+BEGIN_SRC ipython :session :ipyfile images/min-Tz-rama.png
min_Tz = 1e-3

def count(x):
    return (x.where(np.abs(x) < 1e-3).count(dim='time'))/x.count(dim='time')*100

lat = [15, 12, 8, 4, 0]

f, ax = plt.subplots(len(lat), 1, sharex=True, sharey=True)

for (axx, ll) in zip(ax, lat):
    dcpy.plots.offset_line_plot(Tz.sel(lat=ll)
                                .groupby('time.dayofyear')
                                .apply(count),
                                x='dayofyear', y='depth',
                                offset=0, remove_mean=False, ax=axx)
    axx.set_title(str(ll)+'N')

f.suptitle('% observations in a day with $T_z$ < 1e-3', y=1.05)
ax[0].set_ylim([0, 100])

ax[-1].set_xlabel('day of year')

plt.tight_layout()
plt.gcf().set_size_inches((6.5, 6.5))
#+END_SRC
#+CAPTION: How likely is it that we can compute χ for an instrument at 30m vs instrument at 45m
#+RESULTS:
[[file:images/min-Tz-rama.png]]

[[file:images/li-et-al-may-oct-mld.png]]

#+call: read-ra12()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427SMu.png

#+END_SRC
* GM
** diffusivity
#+BEGIN_SRC ipython :session

f30 = dcpy.oceans.coriolis(30)
N0 = 5.2e-3
K0 = 5e-5

lat = xr.DataArray([5, 6.5, 8, 12, 15], dims=['lat'])
lat['lat'] = lat

f0 = dcpy.oceans.coriolis(lat)
N = np.sqrt(argo.N2.mean('time'))
K = K0 * f0 * np.arccosh(N/f0) / f30 / np.arccosh(N0/f30)

f, ax = plt.subplots(1, 1, constrained_layout=True)
K.plot(y='pres', hue='lat', yincrease=False)
f.savefig('images/gm-diffusivity.png')
#+END_SRC
#+CAPTION: GM predicted diffusivity as function of N & latitude.
[[file:images/gm-diffusivity.png]]

** spectral models
#+BEGIN_SRC ipython :session
import numpy as np
import xarray as xr
import xrscipy as xrsp

from GM81 import gm


class gm81:

    def __init__(self, N=2.5e-3, b=1300, f0=7.3e-5,
                 jmax=100, nfreq=401, nk=201):
        '''
        Inputs
        ------
        b : e-folding scale of N(z)
        N : buoyancy frequency

        jmax : (optional) maximum number of vertical modes
        nfreq : (optional) number of log-spaced frequencies
        nk : (optional) number of log-spaced wavenumbers
        '''

        self.b = b
        self.N = N
        self.f0 = f0
        self.N0 = 5.2e-3

        # frequency
        omg = xr.DataArray(np.logspace(np.log10(1.01*self.f0),
                                       np.log10(self.N),
                                       nfreq),
                           dims='ω', attrs={'units': 'rad/s'})
        self.ω = omg.assign_coords(ω=omg)

        # horizontal wavenumber
        k = xr.DataArray(2 * np.pi * np.logspace(-6, -2, nk),
                         dims='k', attrs={'units': 'rad/m'}, name='k')
        self.k = k.assign_coords(k=k)

        # mode number
        j = xr.DataArray(np.arange(1, jmax), dims='j', name='j')
        self.j = j.assign_coords(j=j)

    def __repr__(self):
        return ('GM81: b = , N = , f0 = ')

    def _maybe_integrate(self, S, kind):
        if kind == 'ω' or kind == 'freq':
            return xrsp.integrate.trapz(S, 'j')

    def KE(self, kind='ω'):
        K = gm.K_omg_j(self.ω, self.j, self.f0, self.N, self.N0, self.b)
        return self._maybe_integrate(K, kind)

    def zeta(self, kind='ω'):
        Z = gm.zeta_omg_j(self.ω, self.j, self.f0, self.N, self.N0, self.b)
        return self._maybe_integrate(Z, kind)


if 'argo' not in locals():
    argo = (dcpy.oceans.read_argo_clim()
            .sel(lat=nrl5.lat, lon=nrl5.lon, method='nearest')
            .sel(time='2014')
            .load()
            .transpose())

    argo['rho'] = xr.DataArray(
        sw.pden(argo.S, argo.T, xr.broadcast(argo.pres, argo.S)[0]),
        dims=argo.S.dims, coords=argo.S.coords)

    argo['N2'] = 9.81/1025 * argo.rho.differentiate('pres')


nrl5.vel['KE'] = 0.5 * np.hypot(nrl5.vel.u, nrl5.vel.v)

depth = 200

Tzlo = (nrl5.ctd.T.mean('time').differentiate('depth2')
        .sel(depth2=depth, method='nearest'))
# Tzlo = dcpy.ts.xfilter(Tz, 5*86400, kind='lowpass')
Thi = dcpy.ts.xfilter(nrl5.ctd.T.sel(depth2=depth, method='nearest'), 5*86400,
                      kind='highpass')
ζ = Thi/Tzlo

# KE spectrum
f, axx = plt.subplots(4, 2, constrained_layout=True, sharex='col', sharey='col')
ax = dict()
ax['KE'] = dict(zip(bay.seasons, axx[:, 0]))
ax['ζ'] = dict(zip(bay.seasons, axx[:, 1]))

KEgroups = nrl5.vel.u.groupby(nrl5.vel.time.monsoon.labels)
ζgroups = ζ.groupby(ζ.time.monsoon.labels)

for ((label, kgrp), (_, zgrp)) in zip(KEgroups, ζgroups):
    dcpy.ts.PlotSpectrum((kgrp.sel(time=slice('2013-12', '2014-11'))
                          .dropna('time', how='all'))
                         .sel(depth=depth, method='nearest'),
                         cycles_per='s', twoside=False, ax=ax['KE'][label],
                         label=label)

    dcpy.ts.PlotSpectrum((zgrp.sel(time=slice('2013-12', '2014-11'))
                          .dropna('time', how='all')),
                         cycles_per='s', twoside=False, ax=ax['ζ'][label],
                         label=label)

    N = np.sqrt(argo.N2
                .sel(pres=depth, method='nearest')
                .where(argo.N2.time.monsoon.labels == label)
                .mean('time'))

    g = gm81(N=N, f0=dcpy.oceans.coriolis(8), b=1300)
    gmKE = g.KE('ω')/2
    gmKE['ω'] = gmKE['ω'] / 2 / np.pi
    gmKE['ω'].attrs['units'] = 'cps'
    gmKE.plot(ax=ax['KE'][label])

    gmζ = g.zeta('ω')
    gmζ['ω'] = gmζ['ω'] / 2 / np.pi
    gmζ['ω'].attrs['units'] = 'cps'
    gmζ.plot(ax=ax['ζ'][label])

[aa.set_title('') for aa in axx.flat]
# [aa.set_xlabel('') for aa in axx.flat[:-1]]

axx[0, 0].set_xlim((0.6 * dcpy.oceans.coriolis(8)/2/np.pi, 1/600/2))

ax['KE']['NE'].set_title('KE spectra')
ax['ζ']['NE'].set_title('Displacement spectra')
dcpy.plots.linex(g.f0/2/np.pi, ax=axx.flat)

# f.savefig('images/nrl5-gm-spectra.png')
#+END_SRC
#+CAPTION:
[[file:images/gm-spectra.png]]


#+BEGIN_SRC ipython :session
import numpy as np
import xrscipy as xrsp

class levine02:
    def __init__(self, f0, N, Nprofile, Eref=1, Nref=5.2e-3, js=3,
                 jmax=100, nfreq=801, nk=401):

        self.Nref = Nref
        self.Eref = Eref
        self.js = js
        self.N = N
        self.Nprofile = Nprofile
        self.ωS2 = 2 * np.pi / 43200
        self.f0 = f0

        # frequency
        omg = xr.DataArray(np.logspace(np.log10(1.01*self.f0),
                                       np.log10(self.N),
                                       nfreq),
                           dims='ω', attrs={'units': 'Hz'})
        self.ω = omg.assign_coords(ω=omg)

        # horizontal wavenumber
        k = xr.DataArray(2 * np.pi * np.logspace(-6, -2, nk),
                         dims='k', attrs={'units': 'rad/m'}, name='k')
        self.k = k.assign_coords(k=k)

        # mode number
        j = xr.DataArray(np.arange(1, jmax), dims='j', name='j')
        self.j = j.assign_coords(j=j)

        # determine WKB scaled vertical waveguide thickness and save
        self.D = (1/self.Nref
                  ,* xrsp.integrate.trapz(self.Nprofile,
                                         self.Nprofile.dims[0]).values)

        J = 1/(xrsp.integrate.trapz(1/(self.j**2 + self.js**2), 'j'))
        self.H = J/(self.j**2 + self.js**2)
        self.B = 2/np.pi * self.f0/(self.ω * np.sqrt(self.ω**2 - self.f0**2))

        C = np.arccos(self.f0/self.Nref) - np.arccos(self.f0/self.ωS2)
        other = ((1 + self.f0/self.ωS2) * (self.ω/self.ωS2)**3
                 / ((self.ω/self.ωS2)**(2.5) + self.f0/self.ωS2))
        self.Bhat = (np.pi/2 * self.B/C *
                     xr.where(self.ω > self.ωS2, 1, other))

        self.E = self.Eref * self.Bhat * self.H

Nprofile = argo.N2.mean('time').pipe(np.sqrt)
l02 = levine02(f0=dcpy.oceans.coriolis(30), N=0.02, Nprofile=Nprofile)

xrsp.integrate.trapz(l02.E, 'j').plot(xscale='log', yscale='log')
# f, ax = plt.subplots(1, 1, constrained_layout=True)


# f.savefig('images/levine.png')
  #+END_SRC
#+CAPTION:
[[file:images/levine.png]]

* χ processing
** Winters & D'Asaro methodology
*** Smyth et al 2001
As of now, it looks like the Smyth approach is to use a single value for a patch. The Winters & D'Asaro approach is the "high resolution" version I guess.
*** Convection
*** determining sign
1. Use mooring dT/dz (10-20m scale)
2. Use sign of hourly moving median (6 points).
3. For |dT/dz| < 1e-3; use sign of two hourly median

[[file:~/work/bay/images/wda-tz-sign.png]]

[[file:~/work/bay/images/wda-tz-sign-2.png]]

*** noise levels
The differentiator uses the /analog/ signal as input; so it never differentaties bit-noise in T. i.e. the noise floor in Tp and T are _different._

~chi_chi_proc~ checks for Tp noise floor.

When doing the WDA estimate, I need to check for the T noise floor when sorting temperature.
*** Use just the sorted gradient or re-evalute with mooring gradient?
[[file:images/wda-Jq-comparison.png]]
** really low turbulence

- instrument is being pumped through what looks like really quiet layers.
- 15 sec period roughly : signal is also seen in pressure time series.

[[file:images/518-low-turbulence.png]]
#+CAPTION: zoom-in of first image
[[file:images/518-low-turbulence-zoom-1.png]]
#+CAPTION: zoom-in of first image
[[file:images/518-low-turbulence-zoom-2.png]]
** 1 sec IC fits
Use 526 2017-07-06 to test: this has kstart, kstop, ki saved for the entire year.

1. I can get ~k_stop~ decently well in ~combine_turbulence~. Not doing that well with ~k_start.~
2. Part of the reason is that I'm not actually getting k_b right which is mystifying.
3. If I can do ~k_start~ I can also check how many points are in fitting range.
   1. Though really, I should redo all calculations :(.

#+CAPTION: Comparing estimated k_b with saved k_b. Why is this wrong?!  This might be because chi, epsilon is recalculated right at the end but the k_b I saved was not.
[[file:images/526-k_b-est-saved.png]]

#+CAPTION: This figure show histograms of ε when k_i > k_{stop}. It compares one where I estimate kstop and other where kstop was saved during iterations.
[[file:images/526-eps-ki-filter-hist.png]]

#+CAPTION: Here I compare ε distributions after when k_i < k_stop (straddling the transition) and k_i < k_start (always in vc range). These use the saved ranges.
[[file:images/526-chi-ki-filtering.png]]
** using pressure instead of accelerometer

Tested with RAMA14-810
#+CAPTION: Δp is quantized! Bit resolution ≈ 2 cm. I smooth over 0.5 seconds.
[[file:images/810-p-velz-a-velz.png]]

#+ATTR_HTML: :width 50%
#+CAPTION: Agrees with Perlin & Moum (2012), though here $dp/dt$ is smaller.
[[file:images/810-compare-spd.png]]
#+CAPTION: mean/median larger by a factor of 2 (only tested for 20-Feb-2015)
[[file:images/810-compare-chi-eps.png]]

#+CAPTION: slope ≈ 1.5 (only tested for 20-Feb-2015)
[[file:images/810-compare-hist2-chi-eps.png]]

bibliography:~/Papers/bibtexLibrary.bib

* Satellite data
SMAP: https://podaac.jpl.nasa.gov/dataset/SMAP_RSS_L3_SSS_SMI_8DAY-RUNNINGMEAN_V2?ids=ProcessingLevel:Collections&values=*3*:SMAP-SSS

MODIS Chl-a:
https://podaac.jpl.nasa.gov/dataset/MODIS_Aqua_L3_CHLA_Daily_4km_V2014.0_R?ids=Measurement:Variable&values=Ocean%20Optics:Ocean%20Color

** Visible imagery
This might be a good product: https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mod09q1_v006.
I got there from here: https://modis.gsfc.nasa.gov/data/dataprod/mod09.php

will need to follow cite:Gumley2010.
* Paper / presentation figures
** summary paper
*** Figure 1: map + depths on argo climatology
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgeMzvg3.png
import cartopy.crs as ccrs

with plt.rc_context({'font.size': 11,
                     'axes.facecolor': 'white',
                     'savefig.transparent': False}):

    f = plt.figure(constrained_layout=True)

    n=3
    n0=2
    # gs = mpl.gridspec.GridSpec(2, n, figure=f)
    # ax1 = f.add_subplot(gs[:, :n0], projection=ccrs.PlateCarree())
    # ax2 = f.add_subplot(gs[0, n0:])
    # ax3 = f.add_subplot(gs[1, n0:])

    gs = mpl.gridspec.GridSpec(n, 2, figure=f)
    ax1 = f.add_subplot(gs[:n0, :], projection=ccrs.PlateCarree())
    ax2 = f.add_subplot(gs[n0:, 0])
    ax3 = f.add_subplot(gs[n0:, 1])

    f.set_size_inches((4.75, 8))

    bay.make_labeled_map(ax=ax1)
    bay.mark_χpod_depths_on_clim(ax=[ax2, ax3])

    for label, ax in zip(['a', 'b', 'c'], [ax1, ax2, ax3]):
        ax.text(0.025, 0.05, label+')', transform=ax.transAxes,
                fontsize='medium')

    [tt.set_rotation(30) for tt in ax1.get_xticklabels()]
    ax3.set_ylabel('')
    ax3.set_yticklabels([])

    plt.savefig('images/paper1/map.pdf', bbox_inches='tight')
#+END_SRC

*** Figure 2: Seasonal patterns of EKE, surface currents, wind & NIW input
#+BEGIN_SRC ipython :session :results none
import cartopy.crs as ccrs

if 'oscar' not in locals():
    oscar = (xr.open_mfdataset('/home/deepak/work/datasets/oscar/oscar_vel*.nc',
                               concat_dim='time')
             .sel(latitude=slice(bay.region['lat'].stop,
                                 bay.region['lat'].start),
                  longitude=bay.region['lon'],
                  time=slice('2013-12-01', '2014-11-30')))
    oscar = (oscar
             .groupby(oscar.time.monsoon.splitlabels).mean('time')
             .load().squeeze()
             .sortby('latitude'))

if 'ssha' not in locals():
    ssha = (xr.open_dataset('../datasets/ssh/'
                            + 'dataset-duacs-rep-global-merged-allsat'
                            + '-phy-l4-v3_1522711420825.nc')
            .sel(time=slice('2013-12-01', '2014-11-30'))
            .load())
    ssha['EKE'] = 0.5 * (ssha.ugosa**2 + ssha.vgosa**2)
    eke = (ssha.EKE.groupby(ssha.EKE.time.monsoon.splitlabels)
           .mean(dim='time'))

if 'tropflux' not in locals():
    tropflux = (xr.open_mfdataset('../datasets/tropflux/tau*_tropflux_1d_*.nc')
                .drop('tau')
                .sel(time=slice('2013-12-01', '2014-11-30'),
                     latitude=slice(2, 25),
                     longitude=slice(78, 96))
                .load())
    tropflux = (tropflux.groupby(tropflux.time.monsoon.splitlabels)
                .mean(dim='time'))

if 'sss' not in locals():
    aq = dcpy.oceans.read_aquarius()
    sss = aq.sss.sel(latitude=slice(2, 25),
                     longitude=slice(78, 96))
    sss = (sss.groupby(sss.time.monsoon.splitlabels)
           .mean(dim='time')
           .load())

if 'wind_input' not in locals():
    wind_input = xr.open_dataset('~/bay/estimates/merra2-wind-power-input-2014.nc')
    mean_niw = (wind_input.groupby(wind_input.time.monsoon.splitlabels).mean('time'))
    niw = (wind_input.wind_input
           .sel(time=slice('2013-12-01', '2014-11-30'))
           .groupby(wind_input.time.monsoon.splitlabels)
           .apply(xrsp.integrate.trapz, coord='time'))

# if 'true_input' not in locals():
#     true_input = (xr.open_dataset('~/bay/estimates/mooring-near-inertial-input.nc')
#                   .sel(time=slice('2014-01-01', '2014-11-30'))
#                   .true_flux)
#     true_input.values[np.isnan(true_input.values)] = 0
#     grp = true_input.groupby(true_input.time.monsoon.splitlabels)
#     true_input = (true_input
#                   .groupby(true_input.time.monsoon.splitlabels)
#                   .apply(xrsp.integrate.trapz, coord='time'))
#     true_input = true_input.where(np.abs(true_input) > 0)

osc = oscar.sel(latitude=slice(None, None, 2),
                longitude=slice(None, None, 2))

def common(ax):
    ax.set_xticks(range(80, 96, 4))
    ax.set_yticks(range(4, 24, 4))
    bay.plot_coastline(ax)
    ax.set_extent([80, 94, 4, 24])
    # bay.mark_moors(ax=ax, color='black', colortext='white',
    #                fontsize=7, markersize=8)

f, ax = plt.subplots(2, 5, sharex=True, sharey=True,
                     subplot_kw=dict(projection=ccrs.PlateCarree()),
                     constrained_layout=False)
[common(aa) for aa in ax.flat]

axes = dict()
if ax.shape[0] > ax.shape[1]:
    axes['oce'] = dict(zip(bay.splitseasons, ax[:, 0]))
    axes['atm'] = dict(zip(bay.splitseasons, ax[:, 1]))
else:
    axes['oce'] = dict(zip(bay.splitseasons, ax[0, :]))
    axes['atm'] = dict(zip(bay.splitseasons, ax[1, :]))

for season in bay.splitseasons:
    heke = (eke.sel(monsoon=season)
            .plot.contourf(ax=axes['oce'][season],
                           x='longitude', y='latitude',
                           cmap=mpl.cm.OrRd,
                           levels=np.linspace(0, 0.3, 40),
                           add_colorbar=False))

    hoscar = axes['oce'][season].quiver(osc.longitude, osc.latitude,
                                        osc.u.sel(monsoon=season),
                                        osc.v.sel(monsoon=season),
                                        width=0.006,
                                        scale=3)

    # hsss = (sss.sel(monsoon=season)
    #         .plot.contour(ax=axes['oce'][season],
    #                       x='longitude', y='latitude',
    #                       levels=[29, 30, 31, 32, 33, 34],
    #                       colors='k', linewidths=1))
    # hlab = axes['oce'][season].clabel(hsss, fontsize='smaller', fmt='%2.0f')
    # [hh.set_backgroundcolor('lightgray') for hh in hlab]

    kwargs = dict(cmap=mpl.cm.GnBu, vmin=0, vmax=10)
    hniw = ((niw/1000).sel(monsoon=season)
            .plot.contourf(ax=axes['atm'][season], levels=40,
                           add_colorbar=False, **kwargs))

    _, lon, lat = xr.broadcast(true_input.sel(monsoon=season),
                               true_input.lon, true_input.lat)
    # htrue = axes['atm'][season].scatter(
    #     lon.values.ravel(), lat.values.ravel(),
    #     c=(true_input/1000).sel(monsoon=season).values.ravel(),
    #     edgecolor='darkgray', linewidths=1, **kwargs)

    htau = axes['atm'][season].quiver(niw.lon[::2], niw.lat[::2],
                                      mean_niw.taux.sel(monsoon=season)[::2, ::2],
                                      mean_niw.tauy.sel(monsoon=season)[::2, ::2],
                                      scale=0.4, width=0.006)

    if season == 'NE':
        keykwargs = dict(coordinates='axes', labelpos='S',
                         fontproperties=dict(size=8))
        axes['oce']['NE'].quiverkey(hoscar, 0.2, 0.96, 0.5, '0.5 m/s',
                                    ,**keykwargs)

        axes['atm']['NE'].quiverkey(htau, 0.25, 0.96, 0.1, '0.1 N/m²',
                                    ,**keykwargs)

    axes['oce'][season].set_title(season)

    # [axes[row][season].text(0.05, 0.875, season,
    #                         transform=axes[row][season].transAxes,
    #                         color='k', zorder=10)
    # for row in axes]



def clean_axis(ax):
    ax.set_xlabel('')
    ax.set_ylabel('')

[clean_axis(aa) for aa in ax.flat]
[axes['atm'][aa].set_title('') for aa in axes['atm']]
[aa.set_xlabel('Longitude') for aa in ax[1, :]]
[aa.set_ylabel('Latitude') for aa in ax[:, 0]]

hcb1 = plt.colorbar(heke, ax=ax[0, :3], orientation='horizontal',
                    label='EKE [m²/s²]', shrink=0.7, anchor=(0.3, 1.0))
hcb2 = plt.colorbar(hniw, ax=ax[0, 2:], orientation='horizontal',
                    label='Near-inertial wind input [kJ/m²]',
                    shrink=0.7, anchor=(0.8, 1.0))
hcb1.set_ticks(np.arange(0, 0.31, 0.05))
hcb2.set_ticks(np.arange(0, 11, 2))

f.set_size_inches(6, 5)
plt.subplots_adjust(left=0.080, right=0.99, bottom=0.1, wspace=0.05,
                    hspace=0.4, top=0.99)

plt.savefig('images/paper1/spatial-maps.pdf', transparent=False,
            bbox_inches='tight')

# clim = (aq.sss.sel(longitude=slice(75, 98),
#                    latitude=slice(0, 24))
#         .groupby('time.month').mean(dim='time'))
# clim.plot(col='month', col_wrap=3, robust=True)
# hc = clim.plot.contour(col='month', col_wrap=3, levels=np.arange(29, 36), Colors='k')
# plt.clabel(hc, fmt='%2.0f')
# pptlevels=[600,  1200, 1800]
# ppt = trmm.sel(monsoon=season).precipitation
# hppt = (ppt.where(ppt > pptlevels[0]-2)
#         .plot.contourf(ax=axes[season], x='lon', y='lat',
#                        levels=pptlevels,
#                        cmap=ppt_cmap, zorder=4,
#                        add_colorbar=False))
# (ppt.where(ppt > pptlevels[0]-2)
#  .plot.contour(ax=axes[season], x='lon', y='lat',
#                levels=pptlevels, zorder=4,
#                colors=raincolor, linewidths=1))

# cmap = (sns.blend_palette(
#     [[0.988235, 0.988235, 0.992157],
#      [0.811765, 0.831373, 0.886275],
#      [0.627451, 0.678431, 0.788235],
#      [0.521569, 0.615686, 0.729412],
#      [0.584314, 0.698039, 0.749020],
#      [0.690196, 0.803922, 0.772549],
#      [0.847059, 0.905882, 0.796078],
#      [1.000000, 0.980392, 0.756863],
#      [0.996078, 0.839216, 0.447059],
#      [0.996078, 0.670588, 0.286275],
#      [0.992157, 0.501961, 0.219608],
#      [0.968627, 0.270588, 0.152941],
#      [0.835294, 0.070588, 0.125490],
#      [0.674510, 0.000000, 0.149020],
#      [0.509804, 0.000000, 0.149020]],
#     n_colors=21, as_cmap=True))

#+END_SRC


**** old one
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgRUuf4A.png
bay = importlib.reload(bay)

moor_names = {
'ra12': 'RAMA 12N',
'ra15': 'RAMA 15N',
'nrl1': 'NRL 1',
'nrl3': 'NRL 3',
'nrl4': 'NRL 4',
'nrl5': 'NRL 5',
}

import cartopy.crs as ccrs

if 'ssha' not in locals():
    ssha = (xr.open_dataset('../datasets/ssh/'
                            + 'dataset-duacs-rep-global-merged-allsat-phy-l4-v3_1522711420825.nc')
            .sel(time='2014')
            .load())
    ssha['EKE'] = 0.5 * (ssha.ugosa**2 + ssha.vgosa**2)
    eke = (ssha.EKE.groupby(ssha.EKE.time.monsoon.labels)
           .mean(dim='time'))

if 'tropflux' not in locals():
    tropflux = (xr.open_mfdataset('../datasets/tropflux/tau*_tropflux_1d_*.nc')
                .drop('tau')
                .sel(time='2014',
                     latitude=slice(2, 25),
                     longitude=slice(78, 96))
                .load())
    tropflux = (tropflux.groupby(tropflux.time.monsoon.labels)
                .mean(dim='time'))

if 'trmm' not in locals():
    trmm = (dcpy.oceans.read_trmm()
            .sel(time='2014',
                 lat=slice(2, 25),
                 lon=slice(78, 96)))
    trmm = (trmm.groupby(trmm.time.monsoon.labels)
            .sum(dim='time')
            .load())

if 'sss' not in locals():
    aq = dcpy.oceans.read_aquarius()
    sss = aq.sss.sel(latitude=slice(2, 25),
                     longitude=slice(78, 96))
    sss = (sss.groupby(sss.time.monsoon.labels)
           .mean(dim='time')
           .load())

def clean_inset_axes(ax):
    ax.set_ylabel('')
    ax.set_xlabel('')
    ax.set_title('')

    ax.grid(True, axis='x', which='both',
            color='w', lw=1)
    ax.grid(False, axis='y', which='major')
    ax.set_axisbelow(True)


# N = 200
# cmap = mpl.cm.GnBu(np.arange(N))
# cmap[:, -1] = np.linspace(0.25, 0.5, N)
# ppt_cmap = mpl.colors.ListedColormap(cmap[60:])

raincolor = '#3BBBC5'
cmap = np.asarray(sns.light_palette(raincolor, n_colors=10))
cmap[:, -1] = 0.35
ppt_cmap = mpl.colors.ListedColormap(cmap)

def make_depth_cmap():

    cmap = dict()
    cmap['ra12'] = sns.color_palette('GnBu', 4)[1:]
    cmap['ra15'] = sns.dark_palette('darkorange', 3)[1:]

    cmap['ra15'].reverse()

    paired = sns.color_palette('Paired')
    del paired[6:8] # orange clashes
    for idx, name in enumerate(['nrl1', 'nrl3', 'nrl4', 'nrl5']):
        cmap[name] = paired[2*idx:2*idx+2]

    return cmap

depth_cmap = make_depth_cmap()

seasons = ['NE', 'NESW', 'SW', 'SWNE']

f = plt.figure(constrained_layout=True)
gs = mpl.gridspec.GridSpec(12, 3, figure=f)

axes = dict()
insets = dict()
for idx, seas in enumerate(seasons):
    axes[seas] = f.add_subplot(gs[slice(idx*3, idx*3+3), 1],
                               projection=ccrs.PlateCarree())
    itop = idx*3
    insets[seas] = dict()
    insets[seas]['ra15'] = f.add_subplot(gs[itop, 2])
    insets[seas]['nrl5'] = f.add_subplot(gs[itop+2, 2])
    insets[seas]['ra12'] = f.add_subplot(gs[itop+1, 2])

    insets[seas]['nrl4'] = f.add_subplot(gs[itop, 0])
    insets[seas]['nrl3'] = f.add_subplot(gs[itop+1, 0])
    insets[seas]['nrl1'] = f.add_subplot(gs[itop+2, 0])

    for m in insets[seas]:
        insets[seas][m].text(0.95, 0.95, moor_names[m],
                             transform=insets[seas][m].transAxes,
                             ha='right', va='top', fontsize=9)
        insets[seas][m].spines['left'].set_visible(False)
        insets[seas][m].tick_params(direction='in', pad=2)


for season in axes:
    bay.plot_coastline(ax=axes[season])
    axes[season].set_extent([78, 96, 2, 20])
    bay.mark_moors(ax=axes[season],
                   color='black', colortext='white',
                   fontsize=8.5, markersize=9)
    # bay.mark_moors(ax=axes[season], color='k')

    hdl = (eke.sel(monsoon=season)
           .plot.contourf(ax=axes[season], x='longitude', y='latitude',
                          cmap=mpl.cm.OrRd,
                          levels=np.linspace(8e-3, 0.3, 40),
                          add_colorbar=False))

    hq = axes[season].quiver(tropflux.longitude, tropflux.latitude,
                             tropflux.taux.sel(monsoon=season),
                             tropflux.tauy.sel(monsoon=season),
                             scale=1, zorder=5)

    pptlevels=[600,  1200, 1800]
    ppt = trmm.sel(monsoon=season).precipitation
    hppt = (ppt.where(ppt > pptlevels[0]-2)
            .plot.contourf(ax=axes[season], x='lon', y='lat',
                           levels=pptlevels,
                           cmap=ppt_cmap, zorder=4,
                           add_colorbar=False))
    (ppt.where(ppt > pptlevels[0]-2)
     .plot.contour(ax=axes[season], x='lon', y='lat',
                   levels=pptlevels, zorder=4,
                   colors=raincolor, linewidths=1))

    hsss = (sss.sel(monsoon=season)
            .plot.contour(ax=axes[season],
                          x='longitude', y='latitude',
                          levels=[29, 30, 31, 32, 33, 34],
                          colors='k', linewidths=1))
    plt.clabel(hsss, fontsize='smaller', fmt='%2.0f')

    axes[season].set_title('')

    axes[season].text(0.05, 0.875, season,
                      transform=axes[season].transAxes,
                      color='k', zorder=10)

# axes[season].quiverkey(hq, 0.1, 0.01, 0.1, label='0.1 N/m²',
#                        coordinates='figure')

def map_insets(func, grouped, mname):
    for season, subset in grouped:
        ax = insets[season][mname]
        for iz, zz in enumerate(subset.depth):
            if subset.lon == 90:  # RAMA
                zval = zz
            else:
                zval = subset.z.sel(depth=zz).mean()

            label = '{0:.0f}'.format(zval.values)
            color = depth_cmap[mname][iz]

            func(subset.sel(depth=zz), ax=ax, color=color)

            ax.text(0.95, 0.75-0.23*iz, label+'m', color=color,
                    transform=ax.transAxes, ha='right', va='top',
                    fontsize=9)

        clean_inset_axes(ax)

    return hdl

def hist(subset, ax, color):
    data = (np.log10(subset)
            .resample(time='H').mean(dim='time'))

    # hdl = (data.plot.hist(ax=ax,
    #                       density=True,
    #                       bins=60,
    #                       histtype='step'))

    df = (data.drop(['lat', 'lon'])
          .to_dataframe()
          .reset_index())

    sns.kdeplot(df.KT.dropna(), ax=ax,
                legend=False, color=color)

    ax.set_xlim([-7, -1])
    ax.set_xticks(np.arange(-7, -1, 1))
    ax.set_yticks([])
    ax.set_yticklabels([])

def timeseries(subset, ax):
    hdl = (subset
           .resample(time='D').mean(dim='time')
           .plot.line(x='time', ax=ax,
                      yscale='log'))

for mname, moor in zip(['ra12', 'ra15',
                        'nrl1', 'nrl3', 'nrl4', 'nrl5'],
                       [ra12, ra15, nrl1, nrl3, nrl4, nrl5]):
    grouped = moor.KT.groupby(moor.KT.time.monsoon.labels)
    map_insets(hist, grouped, mname)

for season in ['NE', 'NESW', 'SW', 'SWNE']:
    insets[season]['ra15'].set_xticklabels([])
    insets[season]['ra12'].set_xticklabels([])
    insets[season]['nrl3'].set_xticklabels([])
    insets[season]['nrl4'].set_xticklabels([])

insets['SWNE']['nrl5'].set_xlabel('Hourly averaged $K_T$ [m²/s]')
insets['SWNE']['nrl1'].set_xlabel('Hourly averaged $K_T$ [m²/s]')

insets['NE']['nrl5'].set_ylim([0, 4])
insets['NESW']['nrl5'].set_ylim([0, 4])
for hh in [insets['NE']['nrl5'].get_children()[1],
           insets['NESW']['nrl5'].get_children()[1]]:
    hh.set_in_layout(False)
    hh.set_clip_on(False)

f.set_constrained_layout_pads(wspace=0., hspace=0.,
                              h_pad=0.0, w_pad=-0.1)
f.set_size_inches((6.0, 8.5))

plt.savefig('images/paper1/spatial-maps.pdf',
            transparent=False, pad_inches=0)

# clim = (aq.sss.sel(longitude=slice(75, 98),
#                    latitude=slice(0, 24))
#         .groupby('time.month').mean(dim='time'))
# clim.plot(col='month', col_wrap=3, robust=True)
# hc = clim.plot.contour(col='month', col_wrap=3, levels=np.arange(29, 36), Colors='k')
# plt.clabel(hc, fmt='%2.0f')


cmap = (sns.blend_palette(
    [[0.988235, 0.988235, 0.992157],
     [0.811765, 0.831373, 0.886275],
     [0.627451, 0.678431, 0.788235],
     [0.521569, 0.615686, 0.729412],
     [0.584314, 0.698039, 0.749020],
     [0.690196, 0.803922, 0.772549],
     [0.847059, 0.905882, 0.796078],
     [1.000000, 0.980392, 0.756863],
     [0.996078, 0.839216, 0.447059],
     [0.996078, 0.670588, 0.286275],
     [0.992157, 0.501961, 0.219608],
     [0.968627, 0.270588, 0.152941],
     [0.835294, 0.070588, 0.125490],
     [0.674510, 0.000000, 0.149020],
     [0.509804, 0.000000, 0.149020]],
    n_colors=21, as_cmap=True))

# eke.sel(monsoon='SW').plot.contourf(levels=120, cmap=cmap)
# eke.sel(monsoon='SW').plot.contour(ax=plt.gca(), levels=12,
#                                    colors='#E0E1B8',
#                                    linewidths=0.4)
#+END_SRC

Divide up depths per season
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgXx7AIu.png

plt.figure();
nrl4.KT.z.resample(time='D').mean(dim='time').plot.line(x='time')
nrl4.MarkSeasonsAndEvents()
#+END_SRC
*** Figure 3: RAMA 12N time series
#+BEGIN_SRC ipython :session
if 'ra12' not in locals():
    ra12 = bay.read_ra12()

f, axx = plt.subplots(3, 1, sharex=True, constrained_layout=True)
f.set_constrained_layout_pads(hspace=0.001, h_pad=0)

ax12 = bay.plots.plot_moor(ra12, idepth=0, axx=axx)
ax12['jq'].set_ylim([-50, 50])
# ax12['js'].set_ylim([-1e-2, 2e-1])

flux = ra12.flux.Jq0.sel(time='2014').resample(time='D').mean('time')
ax12['flux'] = ax12['met'].twinx()
ra12.PlotFlux(ax12['flux'], flux.time.values, flux)
ax12['flux'].spines['right'].set_visible(True)
ax12['flux'].set_ylabel('Daily avg. net surface\nheat flux [W/m²]')
dcpy.plots.label_subplots(axx)

f.set_size_inches((8, 4))

f.savefig('images/paper1/rama12.pdf')
#+END_SRC
#+CAPTION:
[[file:images/paper1/rama12.pdf]]
*** Figure 4: NRL time series

#+BEGIN_SRC ipython :session :results none
if 'nrl5' not in locals():
    nrl5 = bay.read_nrl5()

if 'shear_fit5' not in locals():
    shear_fit5 = nrl5.linear_fit_shear(dict(depth=slice(110, 160), time='2014'))

from dcpy.plots import annotate_end, set_axes_color

f5, axx5 = plt.subplots(4, 1, sharex=True, constrained_layout=True)
f5.set_constrained_layout_pads(hspace=0.001, h_pad=0)

niw_shear = dcpy.ts.BandPassButter(shear_fit5.shear,
                                   freqs=np.array([1/2, 2])*nrl5.inertial.values,
                                   dt=1/24, debug=False)

hshear = (((niw_shear).rolling(time=3*24).std() * 1e3)
          .plot(ax=axx5[-1], _labels=False, color='k'))
hshear[0].set_clip_on(False)
hshear[0].set_in_layout(False)
nrl5.MarkSeasonsAndEvents(events=False, ax=axx5[-1])
axx5[-1].set_ylabel('Near-inertial shear\nstd [$10^{-3}$ s$^{-2}$]')
axx5[-1].set_ylim([0, 5])

axnrl5 = bay.plots.plot_moor(nrl5, idepth=1, axx=axx5)
axnrl5['jq'].set_ylim([-20, 0])
axnrl5['js'].set_ylim([-1e-2, 2e-1])

# fill in the 20m gap with linear interpolation
# then interpolate velocity to CTD depths
# then difference to get shear
zinterp = nrl5.ctd.depth.isel(z=slice(1, 3))
vel_interp = (nrl5.vel[['u', 'v']].interpolate_na('depth')
              .interp(time=zinterp.time, depth=zinterp))
shear_interp = (np.hypot(vel_interp.u.diff('z')/15, vel_interp.v.diff('z')/15)
                .squeeze())

N2 = ((9.81/1025 * nrl5.ctd.ρ.diff('z')/nrl5.ctd.depth.diff('z'))
      .isel(z=1))
Ri = (N2.where(N2 > 0)/shear_interp**2).sel(time='2014')

axnrl5['ri'] = axx5[-1].twinx()
(((Ri.where(Ri < 5)).resample(time='D').count()/144)
 .plot(ax=axnrl5['ri'], label='< 10', _labels=False, color='C0'))
set_axes_color(axnrl5['ri'], 'C0', spine='right')
axnrl5['ri'].set_ylabel('Fraction of day\nwith Ri < 5')

axnrl5['input'] = axnrl5['met'].twinx()
axnrl5['input'].plot(nrl5.niw.time, nrl5.niw.true_flux*1000, color='C0')
axnrl5['input'].set_ylabel('Near-inertial input\n$Π$[mW/m²]')
set_axes_color(axnrl5['input'], 'C0', spine='right')

dcpy.plots.label_subplots(axx5, x=0.025, y=0.83)

f5.savefig('images/paper1/nrl5.pdf')


# shear_interp = (nrl5.vel.shear
#                 .interp(time=zpod.time, depth=zpod.isel(num=1))
#                 .interpolate_na('time'))
# axnrl5['depth'] = axx5[-1].twinx()

# (nrl5.zχpod.isel(num=1).resample(time='D').mean('time')
#  .plot.line(x='time', ax=axnrl5['depth'], color='C0'))
# set_axes_color(axnrl5['depth'], 'C0', spine='right')
# axnrl5['depth'].set_title('')

# bpshear = mooring.calc_shear_bandpass(depth=120).to_array('band')
# (bpshear.sel(time='2014').sel(band=['f0', 'M4'])
#  .rolling(time=24*5).var()
#  .plot.line(x='time', add_legend=True, ax=axx5[-1]))

# bpshear2 = nrl5.calc_shear_bandpass(depth=50).to_array('band')
# (bpshear2.sel(time='2014').sel(band='f0')
#  .rolling(time=24*5).var()
#  .plot.line(x='time', ax=axx5[-1]))

# shear = (nrl5.calc_shear_bandpass(depth=120).sel(time='2014')
#          .resample(time='D').var())

# hm2 = (shear['M2']/1e-6).plot(ax=axnrl5['shear'])
# hm4 = (shear['M4']/1e-6).plot(ax=axnrl5['shear'])
# hf0 = (shear['f0']/1e-6).plot(ax=axnrl5['shear'])
# for hh in [hm2, hm4, hf0]:
#     hh[0].set_clip_on(False)
#     hh[0].set_in_layout(False)
# _, htm2 = annotate_end(hm2[0], '$M_2$')
# _, htm4 = annotate_end(hm4[0], '$M_4$', va='top')
# _, htf0 = annotate_end(hf0[0], '$f_0$')
# # _, hiw0 = annotate_end(hiw[0], '$> f_0$', va='center')

# axra12 = plot_moor(ra12, idepth=0)
# jqd = jq0.resample(time='D').mean()
# axes['jq0'] = axra12['met'].twinx()
# ra12.PlotFlux(axra12['jq0'], jqd.time.values, jqd.values)

# # axes['shear'].set_ylim([0, 2.5])
#+END_SRC
[[file:images/paper1/nrl5.pdf]]

*** Figure 5: Vertical profile of K_T distributions

#+BEGIN_SRC ipython :session :results none
import bay
bay = importlib.reload(bay)

moors = ['RAMA12', 'RAMA15', 'NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5']

bay.make_vert_distrib_plot('KT', label_moorings=False)

plt.savefig('images/vert-profile.svg', bbox_inches='tight')
plt.savefig('images/paper1/bay-KT-vert-profile.pdf', bbox_inches='tight')
plt.savefig('images/bay-KT-vert-profile.png', bbox_inches='tight')
#+END_SRC
[[file:images/bay-KT-vert-profile.png]]

**** add in mean wind stress?
#+BEGIN_SRC ipython :session :results none
import bay
bay = importlib.reload(bay)

moors = ['RAMA12', 'RAMA15', 'NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5']

# bay.make_vert_distrib_plot('KT', label_moorings=False)

if 'df' not in locals():
    df = bay.nc_to_binned_df(bins=bay.default_density_bins, moor=None)
    df['KT'] = np.log10(df['KT'])

# f = plt.figure()
# gs = mpl.gridspec.GridSpec(2, 4, figure=f, height_ratios=(1, 8))

# axx1 = []
# for ii in range(4):
#     axx1.append(f.add_subplot(gs[0, ii]))

# axx2 = []
# for ii in range(4):
#     axx2.append(f.add_subplot(gs[1, ii]))

# f, axx = plt.subplots(2, 4, gridspec_kw={'height_ratios': (1, 12)},
#                       sharey='row')
# ax = dict(zip(bay.seasons, axx[1, :]))
# bay.vert_distrib(df, df.bin,
#                  f=f, ax=ax,
#                  label_moorings=False,
#                  percentile=True)

# [aa.set_title('') for aa in axx[1, :]]

# months = {'NE': 'Dec-Feb', 'NESW': 'Mar-Apr',
#           'SW': 'Jun-Sep', 'SWNE': 'Oct-Nov'}
# [axx[0, idx].set_title(list(months.keys())[idx] + '\n' + months[mm])
#  for idx, mm in enumerate(ax)]

# # read Tropflux here
# if 'tropflux' not in locals():
#     tropflux = (xr.open_mfdataset('../datasets/tropflux/tau*_tropflux_1d_*.nc')
#                 .drop('tau')
#                 .sel(time=slice('2013-12-01', '2014-11-30'),
#                      latitude=slice(2, 25),
#                      longitude=slice(78, 96))
#                 .load())
#     tropflux = (tropflux.groupby(tropflux.time.monsoon.labels)
#                 .mean(dim='time'))

# mean_winds = tropflux.mean(['latitude', 'longitude'])
# std_winds = tropflux.std(['latitude', 'longitude'])
# for ii, ss in enumerate(bay.seasons):
#     hh = axx[0, ii].quiver(0, 0, mean_winds.sel(monsoon=ss).taux,
#                            mean_winds.sel(monsoon=ss).tauy, scale=0.3)
#     hh.set_clip_on(False)
#     hh.set_in_layout(False)
#     axx[0, ii].spines['left'].set_visible(False)
#     axx[0, ii].spines['bottom'].set_visible(False)
#     axx[0, ii].set_xticks([])
#     axx[0, ii].set_yticks([])

plt.subplots_adjust(wspace=-0.2)

# plt.savefig('images/vert-profile.svg', bbox_inches='tight')
# plt.savefig('images/paper1/bay-KT-vert-profile.pdf', bbox_inches='tight')
# plt.savefig('images/bay-KT-vert-profile.png', bbox_inches='tight')
#+END_SRC
[[file:images/bay-KT-vert-profile.png]]

*** Figure 6: bootstrap CI
#+BEGIN_SRC ipython :session
import scikits.bootstrap as bs
import tqdm

if 'turb' not in locals():
    turb = bay.nc_to_binned_df()

if 'df' not in locals():
    dflist = []
    for (season, name), group in tqdm.tqdm(
            turb[['KT', 'z']].groupby([turb.season, turb.bin])):

        ci = bs.ci(group.KT)
        dflist.append(pd.DataFrame({'season': season,
                                    'bin': name,
                                    'KT': group.KT.mean(),
                                    'ci': [ci],
                                    'z': sp.stats.trim_mean(group.z, 0.1)},
                                   index=[0]))

    df = pd.concat(dflist)
    df['season'] = df.season.astype('category')
    df['bin'] = df['bin'].astype('category')

bay.plots.vert_distrib(df, df.bin, kind='mean_ci_profile',
                       label_moorings=False, add_offset=True,
                       xlim=[-7.5, -2])
plt.subplots_adjust(wspace=0)

plt.savefig('images/paper1/mean-profile.pdf', bbox_inches='tight')
#+END_SRC
#+CAPTION:
[[file:images/paper1/mean-profile.pdf]]

*** OLD Figure 6: Vertical profiles of KT, Jq, etc. for 8N
#+BEGIN_SRC ipython :session :results none
f, ax = plt.subplots(4, 1, sharey=True, sharex='col')
axes = dict(zip(bay.seasons, ax))

grouped = ebob.groupby(['season', 'bin'])

for (season, rhobin), group in grouped:
    axes[season].boxplot(group['Jq'],
                         positions=[group.z.median()],
                         vert=False, sym='.',
                         whis=500,
                         widths=5)

axes[season].set_ylim([120, 0])
axes[season].set_yticks(range(120, 0, -20))
#+END_SRC

#+BEGIN_SRC ipython :session :results none
if 'df' not in locals():
    df = bay.nc_to_binned_df('./bay_merged_10min.nc')

ebob = df.where(df.lat == 8).dropna(how='all')
# ebob['moor'] = ebob.moor.astype('category')
# ebob['season'] = ebob.season.astype('category')
# ebob['bin'] = ebob.bin.astype('category')

ebob['JqT'] = ebob['Jq'] * ebob['T']
ebob['JsS'] = ebob['Js'] * ebob['S']
ebob = ebob.where(np.abs(ebob['Jq']) < 1000)
ebob = ebob.where(np.abs(ebob['Js']) < 0.5) # 0.1 takes out a lot!

grouped = ebob.groupby(['season', 'bin'])
averaged = grouped.mean().where(grouped.count() > 1440).to_xarray()
stddev = grouped.std().where(grouped.count() > 1440).to_xarray()

averaged['T'] = averaged['JqT'] / averaged['Jq']
averaged['S'] = averaged['JsS'] / averaged['Js']
stddev['T'] = 0
stddev['S'] = 0

# if 'argo_seas' not in locals():
#     argo = (dcpy.oceans.read_argo_clim()
#             .sel(lat=slice(7.5, 8.5), lon=slice(85.5, 88.5), time='2014')
#             .drop(['Tmean', 'Tanom', 'BATHYMETRY_MASK',
#                    'Smean', 'Sanom'])
#             .mean(['lat', 'lon']))
#     argo_seas = (argo.groupby(argo.time.monsoon.labels)
#                  .mean(dim='time').compute())


# df = averaged.to_dataframe().reset_index()

# 1. make this a salt/heat/density flux weighted mean sal, temp, rho
# 2. add argo climatology profiles?
# 3.

varnames = ['T', 'S', 'KT', 'Jq', 'Js']

f = plt.figure(constrained_layout=True)
f.set_constrained_layout_pads(wspace=0/72, w_pad=0, hspace=0, h_pad=0)
gs = mpl.gridspec.GridSpec(2, len(varnames), figure=f, height_ratios=[20, 1])
ax = list()
ax.append(f.add_subplot(gs[0, 0]))
for idx in range(1, len(varnames)):
    ax.append(f.add_subplot(gs[0, idx], sharey=ax[0]))

axes = dict(zip(varnames, ax))
axes['leg'] = f.add_subplot(gs[1, :])

hdl = list()
for var in varnames:
    for ss in averaged.season:
        if var == 'T' or var == 'S':
            fmt = 'o-'
        else:
            fmt = 'o-'

        hdl.append(axes[var].errorbar(averaged.sel(season=ss)[var].values,
                                      averaged.sel(season=ss).z.values,
                                      xerr=0, fmt=fmt, ms=2))
        # if var == 'T' or var == 'S':
        #     argo_seas[var].sel(monsoon=ss, pres=slice(0, 120)).plot(
        #         ax=axes[var], color=hdl[0].get_color(), y='pres', _labels=False)

    axes[var].tick_params(which='both', labeltop=True, labelbottom=False,
                          top=True, bottom=False)
    axes[var].set_xlabel(var)
    axes[var].xaxis.set_label_position('top')
    axes[var].spines['top'].set_visible(True)
    axes[var].spines['bottom'].set_visible(False)
    axes[var].spines['left'].set_bounds(110, 30)

axes['T'].set_ylabel('Depth [m]')

[axes[aa].axvline(0, color='gray', ls='--', zorder=-10)
 for aa in ['Jq', 'Js']]
axes['S'].axvline(35, color='gray', ls='--', zorder=-10)
axes['Js'].set_xlim([-0.0005, 0.003])
axes['Jq'].set_xlim([-10, 2])

axes['KT'].grid(True, axis='x')
axes['KT'].set_xticks([1e-6, 1e-5, 1e-4])
axes['KT'].set_xlim([1e-7, 0.3e-3])
axes['KT'].set_xscale('log')

axes['T'].set_xlabel('Flux weighted T')
axes['S'].set_xlabel('Flux weighted S')
axes['KT'].set_xlabel('$K_T$ [m²/s]')
axes['Jq'].set_xlabel('$J_q^t$ [W/m²]')
axes['Js'].set_xlabel('$J_s^t$ [g/m²/s]')

axes['Js'].set_ylim([110, 25])

[aa.tick_params(labelleft=False) for aa in ax[1:]]

axes['leg'].legend(labels=bay.seasons, ncol=4, handles=hdl[:4], loc='center')
axes['leg'].set_yticks([])
axes['leg'].set_xticks([])
[spine.set_visible(False) for spine in axes['leg'].spines.values()]

f.set_size_inches((6, 3.5))
plt.savefig('images/paper1/smc-vertical-flux.pdf')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[575]:
:END:

*** further filter ra12
   #+BEGIN_SRC ipython :session
f, ax = plt.subplots(1, 1, constrained_layout=True)

nrl1.χpod[501].chi['mm'].Kt.plot(yscale='log')
nrl1.KT.isel(depth=1).plot(yscale='log')
#+END_SRC

#+BEGIN_SRC ipython :session :results none
# import copy

# ra12_backup = copy.copy(ra12)

ra12.CombineTurb()

# plt.figure()
Jq = ra12.Jq.sel(depth=15, time='2014')
tzm = ra12.χpod[526].chi['mm1'].dTdz.interp(time=Jq.time)

# Jq.resample(time='D').mean('time').plot()
# (-np.sign(tzm) * np.abs(Jq)).resample(time='D').mean('time').plot()
# (-np.sign(tzm) * np.abs(Jq.where(np.abs(tzm) > 8e-4))).resample(time='D').mean('time').plot()
# (Jq.where(np.abs(tzm) > 1e-3)).resample(time='D').mean('time').plot()

Jq0 = ra12.flux.Jq0.interp(time=Jq.time)
Lmo = ra12.monin_obukhov().interp(time=Jq.time)
mld = ra12.mld.interp(time=Jq.time)

mask = np.logical_and(np.logical_and(np.abs(tzm) < 1e-3, mld > 15),
                      Jq0 < 0)
mask2 = np.abs(tzm) < 1e-3

# mm1.Jq.resample(time='D').mean('time').plot()

for jj in [Jq, Jq.where(~mask), Jq.where(~mask2)]:
    jj.resample(time='D').mean('time').plot()
#+END_SRC
*** RAMA vs NRL combined :noexport:
#+BEGIN_SRC ipython :session :results none
if 'ra12' not in locals():
    ra12 = bay.read_ra12()
if 'nrl5' not in locals():
    nrl5 = bay.read_nrl5()

from dcpy.plots import annotate_end

def set_ax_color(ax, color, spine='left'):
    ax.spines[spine].set_color(color)
    [tt.set_color(color) for tt in ax.get_yticklabels()]
    ax.yaxis.label.set_color(color)
    ax.tick_params('y', colors=color)

def int_spec(spec, lofreq, hifreq):
    ''' Integrate spectrogram between lofreq, hifreq.
        Returns time series.'''

    subset = (spec.where(np.logical_and(spec.freq > lofreq,
                                        spec.freq < hifreq))
              .dropna(dim='freq', how='all'))

    timeseries = xr.DataArray(np.trapz(subset, subset.freq),
                              dims='time', coords={'time': subset.time})

    return timeseries

def interp_shear(shear):
    z = nrl5.zχpod.isel(num=1).median().values + 10
    return (shear.sel(depth=z, method='nearest')
            .interpolate_na(dim='time')
            .dropna('time'))

mm1 = ra12.χpod[526].convert_to_xarray('mm1')
# mmw = ra12.χpod[526].convert_to_xarray('mm1w')
# tzm = mm1.dTdz.interp(time=mmw.time)
# ra12.χpod[526].Jq['mm1w'] = (-np.sign(tzm) * np.abs(
#     np.where(np.abs(tzm) > 1e-3, ra12.χpod[526].Jq['mm1w'], np.nan)))
# ra12.CombineTurb()

# rama12 : filter out convective time periods
jq0 = ra12.flux.Jq0.interp_like(ra12.Jq)
tzm = mm1.dTdz.interp_like(ra12.Jq)
N2 = ra12.N2.isel(depth=0)
jq0.values[np.isnan(jq0)] = 2
mask = ~np.logical_and(
    np.logical_and(jq0 < 0,
                   ra12.Jq.depth[0] < ra12.mld.interp_like(ra12.Jq)),
    np.abs(tzm) < 1e-3)

ra12.Jq[0, :] = ra12.Jq.isel(depth=0).where(mask)

# f, ax = plt.subplots(2, 1, sharex=True)
# ra12.Jq.isel(depth=0).plot(ax=ax[0])
# ra12.Jq.isel(depth=0).where(mask).plot(ax=ax[0])
# ra12.Jq.isel(depth=0).where(np.abs(tzm) > 1e-3).plot(ax=ax[0])
# ra12.Jq.isel(depth=0).resample(time='D').mean('time').plot(ax=ax[1])
# ra12.Jq.isel(depth=0).where(mask).resample(time='D').mean('time').plot(ax=ax[1])
# ra12.Jq.isel(depth=0).where(np.abs(tzm) > 1e-3).resample(time='D').mean('time').plot(ax=ax[1])

trange = '2014'
fM2 = 24/12.42
f0 = nrl5.inertial

# text label locations
x0 = 0.025
y0 = 0.8

f, axx = plt.subplots(7, 1, sharex=True, constrained_layout=True)
f.set_constrained_layout_pads(hspace=0.001, h_pad=0)
axes = dict(zip(['met12', 'jq12', 'KT', 'jq8', 'met8',
                 'coverage', 'shear'], axx))

hmet12 = (ra12.met.τ.resample(time='D').mean()
          .sel(time=trange).plot(ax=axes['met12'], color='k', lw=1.2))
hmet12[0].set_clip_on(False)
hmet12[0].set_in_layout(False)

# energy_input = np.cumsum(niw.wind_input.sel(lat=nrl5.lat,
#                                             lon=nrl5.lon,
#                                             method='nearest')
#            * np.diff(niw.time).astype('timedelta64[s]').astype('float32').mean())
nrl5.tropflux.tau.sel(time=trange).plot(ax=axes['met8'], color='k', lw=1.2)
axes['input'] = axes['met8'].twinx()
axes['input'].plot(nrl5.niw.time, nrl5.niw.true_flux*1000, color='gray')
axes['input'].spines['right'].set_visible(True)

# shear_pod = interp_shear(nrl5.vel.uz) + 1j*interp_shear(nrl5.vel.vz)
# shearspec = (dcpy.ts.Spectrogram(np.abs(shear_pod), dim='time',
#                                 nfft=30*24, shift=2*24,
#                                 multitaper=True, decimate=False, dt=1/24)
#              .sel(time=trange))
# hm2 = ((int_spec(shearspec, 0.9*(fM2-f0), 1.1*(fM2+f0))/1e-6)
#        .plot(ax=axes['shear'], label='$M_2$'))
# hm4 = ((int_spec(shearspec, 0.9*(fM2*2-f0), 1.1*(fM2*2-f0))/1e-6)
#        .plot(ax=axes['shear'], label='$M_4$'))
# hf0 = ((int_spec(shearspec, 0.6*f0, 1.5*f0)/1e-6)
#        .plot(ax=axes['shear'], label='$f_0$', color='C4'))
# hiw = ((int_spec(shearspec, 0.6*f0, shearspec.freq.max())/1e-6)
#        .plot(ax=axes['shear'], label='> f_0', color='k', yscale='log'))

shear = (nrl5.calc_shear_bandpass(depth=120).sel(time='2014')
         .resample(time='D').var())

hm2 = (shear['M2']/1e-6).plot(ax=axes['shear'])
hm4 = (shear['M4']/1e-6).plot(ax=axes['shear'])
hf0 = (shear['f0']/1e-6).plot(ax=axes['shear'])
for hh in [hm2, hm4, hf0]:
    hh[0].set_clip_on(False)
    hh[0].set_in_layout(False)
_, htm2 = annotate_end(hm2[0], '$M_2$')
_, htm4 = annotate_end(hm4[0], '$M_4$', va='top')
_, htf0 = annotate_end(hf0[0], '$f_0$')
# _, hiw0 = annotate_end(hiw[0], '$> f_0$', va='center')

handles = dict()
handles['KT'] = dict()
handles['KT']['r'] = (ra12.KT.isel(depth=0).sel(time=trange)
                      .resample(time='D').mean('time')
                      .plot(ax=axes['KT'], _labels=False, lw=1.2))
handles['KT']['n'] = (nrl5.KT.isel(depth=1).sel(time=trange)
                      .resample(time='D').mean('time')
                      .plot(ax=axes['KT'], _labels=False, lw=1.2))
axes['KT'].text(x0, y0, 'c) Daily avg. K_T [m²/s]' +
                xr.plot.utils.label_from_attrs(nrl5.KT),
                transform=axes['KT'].transAxes)

annotate_end(handles['KT']['r'][0], label='12N 15m', va='center')
annotate_end(handles['KT']['n'][0], label='8N 104m')

for m, z,  axname, hname in zip([ra12, nrl5], [0, 1],
                                ['jq12', 'jq8'], ['r', 'n']):
    axes['js'+axname[2:]] = axes[axname].twinx()
    axs = axes['js'+axname[2:]]
    hq = (m.turb['Jq'].isel(depth=z).sel(time=trange)
          .resample(time='D').mean('time')
          .plot(ax=axes[axname], _labels=False, lw=1.2,
                color=handles['KT'][hname][0].get_color()))

    hs = ((m.turb['Js']/1e-2).isel(depth=z).sel(time=trange)
          .resample(time='D').mean('time')
          .plot(ax=axs, _labels=False, lw=1.2, color='gray'))
    for hh in [hq, hs]:
        hh[0].set_clip_on(False)
        hh[0].set_in_layout(False)

    axs.set_zorder(-1)
    axs.spines['right'].set_visible(True)

# hsr = (ra12.ctd.S.isel(depth=1).sel(time=trange)
#        .resample(time='6H').mean(dim='time')
#        .plot(ax=axes['S'], _labels=False))
# hsn = (nrl5.ctd.S.isel(z=0).sel(time=trange)
#        .resample(time='6H').mean(dim='time')
#        .plot(ax=axes['S'], _labels=False))

# _, htsr = annotate_end(hsr[0], label='12N 10m', va='top')
# _, htsn = annotate_end(hsn[0], label='8N 105m')

# annotate_end(handles['Tz']['r'][0], label='12N 10m')
# annotate_end(handles['Tz']['n'][0], label='8N 105m')

jqd = jq0.resample(time='D').mean()
axes['jq0'] = axes['met12'].twinx()
ra12.PlotFlux(axes['jq0'], jqd.time.values, jqd.values)

# labels
htxt = [axes['met12'].text(time, 0.35, season, va='bottom', zorder=-1)
        for time, season
        in zip(['2014-02-01', '2014-03-21', '2014-07-16', '2014-10-20',
                '2014-12-15'],
               ['NE', 'NESW', 'SW', 'SWNE', 'NE'])]

axes['met12'].text(x0, y0, 'a) Forcing at 12N', transform=axes['met12'].transAxes)
axes['jq12'].text(x0, y0, 'b) Turbulent fluxes at 12N',
                   transform=axes['jq12'].transAxes)
axes['jq8'].text(x0, y0, 'd) Turbulent fluxes  at 8N',
                 transform=axes['jq8'].transAxes)
axes['met8'].text(x0, y0, 'e) Forcing at 8N', transform=axes['met8'].transAxes)
axes['coverage'].text(x0, 0.05, 'f) Fraction daily coverage', va='bottom',
                      transform=axes['coverage'].transAxes)
# axes['S'].text(x0, y0, 'h) Salinity [psu]', transform=axes['S'].transAxes)
axes['shear'].text(x0, y0, 'g) Shear variance at 8N [$10^{-6}$ units]',
                   transform=axes['shear'].transAxes)

for jj in [ra12.Jq.isel(depth=0), nrl5.Jq.isel(depth=1)]:
    ((jj.sel(time=trange).groupby(jj.sel(time=trange).time.dt.floor('D'))
      .count()/144)
     .plot(ax=axes['coverage']))

# customize axes
axes['met12'].set_xlim(('2014-01', '2015-01'))
axes['met12'].set_ylim([0, 0.35])
axes['met12'].set_ylabel('$τ$ [N/m²]')
axes['jq0'].set_ylabel('$J_q^0$ [W/m²]')
axes['jq0'].set_ylim([-200, 200])
axes['jq0'].set_zorder(-1)
axes['jq0'].spines['right'].set_visible(True)

axes['met8'].set_ylabel('$τ$ [N/m²]')
axes['input'].set_zorder(-2)
axes['input'].set_ylabel('Π [mW/m²]')
axes['input'].set_ylim([-50, 50])

axes['KT'].set_ylabel('')
axes['KT'].set_ylim([1e-7, 1e-1])
axes['KT'].set_yticks([1e-6, 1e-5, 1e-4, 1e-3])
axes['KT'].set_yscale('log')
axes['KT'].grid(False, axis='x')
axes['KT'].grid(True, which='both', axis='y')

axes['jq12'].set_ylim([-50, 50])
axes['jq8'].set_ylim([-15, 15])
axes['js8'].set_ylim([-1e-2, 2e-1])
axes['jq8'].grid(False)
[axes[aa].set_ylabel('$J_q^t$ [W/m²]') for aa in ['jq12', 'jq8']]
[axes[aa].set_ylabel('$J_s^t$ \n [$10^{-2}$ g/m²/s]') for aa in ['js12', 'js8']]
set_ax_color(axes['jq12'], handles['KT']['r'][0].get_color())
set_ax_color(axes['jq8'], handles['KT']['n'][0].get_color())
[set_ax_color(axes[aa], 'gray', 'right') for aa in ['js12', 'js8']]

axes['coverage'].set_ylabel('')
axes['coverage'].set_yticks([0, 0.5, 1])

# axes['shear'].set_ylim([0, 2.5])

# fmt = axes['shear'].yaxis.get_major_formatter()
# fmt.set_scientific(True)
# axes['shear'].yaxis.set_major_formatter(fmt)

[aa.set_xlabel('') for aa in axx]
[aa.set_title('') for aa in axx]
[nrl5.MarkSeasonsAndEvents(ax=axes[aa], events=False)
 for aa in ['jq0', 'js12', 'js8', 'KT', 'shear', 'input', 'coverage']]

axes['shear'].xaxis.set_tick_params(rotation=0)
[tt.set_ha('center') for tt in axes['shear'].get_xticklabels()]
axes['shear'].xaxis.set_major_formatter(mpl.dates.DateFormatter('%b-%d'))
axes['shear'].set_xlabel('2014')

f.set_size_inches((7, 8))

f.savefig('images/paper1/rama-vs-nrl.pdf')
#+END_SRC
[[file:images/paper1/rama-vs-nrl.pdf]]
** misobob 2018 meeting figures
*** NRL5 time series
#+BEGIN_SRC ipython :session
if 'nrl5' not in locals():
    nrl5 = bay.read_nrl5()

# interpolate shear to χpod bin
zpod = nrl5.zχpod.interp(time=nrl5.vel.time).dropna('time')

if 'shear_fit5' not in locals():
    shear_fit5 = nrl5.linear_fit_shear(dict(depth=slice(110, 140), time='2014'))

shear_lowpass = (shear_fit5.shear.copy(
    data=dcpy.ts.LowPassButter(shear_fit5.shear, 1/2 * nrl5.inertial.values /24)))

shear_interp = (nrl5.vel.shear
                .interp(time=zpod.time, depth=zpod.isel(num=1))
                .interpolate_na('time'))

niw_shear = dcpy.ts.BandPassButter(shear_fit5.shear,
                                   freqs=np.array([1/2, 2])*nrl5.inertial.values,
                                   dt=1/24, debug=False)

N2 = ((9.81/1025 * nrl5.ctd.ρ.diff('z')/nrl5.ctd.depth.diff('z'))
      .isel(z=1))
Ri = (N2.resample(time='H').mean()/shear_interp**2).sel(time='2014')

args = dict(color='C1', _labels=False)

with mpl.rc_context({'font.size': 12}):
    f, ax = plt.subplots(4, 1, sharex=True, constrained_layout=True)

    # nrl5.ssh.EKE.plot(ax=ax[0])

    nrl5.niw.true_flux.plot(ax=ax[0], **args)
    ax2 = ax[0].twinx()
    nrl5.tropflux.tau.sel(time='2014').plot(ax=ax2, color='k', _labels=False)
    dcpy.plots.set_axes_color(ax[0], 'C1')
    ax2.spines['right'].set_visible(True)
    ax2.set_ylabel('τ')
    ax[0].set_ylabel('$u.τ$')

    (1.414 * niw_shear).rolling(time=3*24).std().plot(ax=ax[1], **args)
    # (shear_lowpass).plot(ax=ax[0], **args)

    # (nrl5.N2.isel(depth=1).resample(time='12H').mean('time')
    #  .plot.line(ax=ax[1], x='time', **args))

    # Ri.where(Ri < 50).resample(time='D').median().plot(ax=ax[2], color='C1')
    (((Ri.where(Ri < 10)).resample(time='D').count()/24)
     .plot(ax=ax[2], label='< 10', **args))

    hkt = (nrl5.KT.isel(depth=1)
           .resample(time='D').mean('time')
           .plot.line(ax=ax[-1], yscale='log', x='time', **args))

    for aa, tt in zip(ax,
                      ['Wind stress τ, Local near-inertial input u.τ',
                       'Near-inertial shear (3 day std x sqrt(2)) [1/s]',
                       'Fraction of day with Ri < 10 (20m / hourly)',
                       'Daily mean $K_T$ [m²/s]']):
        aa.text(0.03, 0.85, tt, transform=aa.transAxes,
                backgroundcolor=[0.5, 0.5, 0.5, 0.1])

    [nrl5.MarkSeasonsAndEvents(aa, events=False) for aa in ax]
    [aa.set_xlabel('') for aa in ax]
    [aa.set_ylabel('') for aa in ax]
    [aa.set_title('') for aa in ax]
    [tt.set_rotation(0) for tt in ax[-1].get_xticklabels()]
    ax[-1].set_xlim('2014-01', '2015-01')

    f.set_size_inches((8, 4))
    f.savefig('images/nrl5-shear-N2-Ri-Kt.png')
  #+END_SRC
#+CAPTION:
[[file:images/nrl5-shear-N2-Ri-Kt.png]]
*** NRL5 tidal pumping of inertial shear
#+BEGIN_SRC ipython :session
with mpl.rc_context({'font.size': 14}):

    trange = slice('2014-07-28', '2014-08-07')
    #t518 = nrl5.χpod[518].convert_to_xarray('mmw')
    #t519 = nrl5.χpod[519].convert_to_xarray('mmw')

    f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True,
                         gridspec_kw={'height_ratios': [1, 2, 2]})
    hj0 = (nrl5.Jq.isel(depth=1).sel(time=trange)
           .resample(time='H').mean('time')
           .plot.line(x='time', ax=ax[0], ylim=[-20, 0],
                      add_legend=True, color='C1'))
    # hdl1 = t518['T'].sel(time=trange).plot(x='time', ax=ax[0])
    # hj1 = (nrl5.Jq.isel(depth=1).sel(time=trange)
    #        .resample(time='D').mean('time')
    #        .plot.line(x='time', ax=ax[0], ylim=[-20, 0],
    #                   add_legend=True, color='C1', lw=2))
    # hj1[0].set_clip_on(False)
    # hj1[0].set_in_layout(False)

    # hdl1 = t518['T'].sel(time=trange).plot(x='time', ax=ax[0])
    # hdl2 = t519['T'].sel(time=trange).plot(x='time', ax=ax[0])
    # f.legend(handles=[hdl1[0], hdl2[0], hdl3[0]],
    #          labels=['χpod @ 84', 'χpod @ 104'])

    # nrl5.ε.values[nrl5.ε.values < 1e-12] = 1e-12
    (nrl5.KT.isel(depth=1).sel(time=trange)
     .resample(time='H').mean('time')
     .plot.line(x='time', ax=ax[0], yscale='log', ylim=[1e-7, 1e-3],
                add_legend=False, color='C1'))

    (nrl5.KT.isel(depth=1).sel(time=trange)
     .resample(time='D').mean('time')
     .plot.line(x='time', ax=ax[0], yscale='log', ylim=[1e-7, 1e-3],
                add_legend=False, color='C1', lw=2))

    (nrl5.vel.v.sel(time=trange, depth=slice(100, 200))
     .plot(levels=20, ax=ax[1], yincrease=False, robust=True))

    f0 = nrl5.inertial/86400
    shear = (nrl5.vel.shear)
    hsh = (shear.sel(time=trange, depth=slice(100, 200))
           .plot(yincrease=False, cmap=mpl.cm.RdYlBu_r, vmax=0.02, ax=ax[2],
                 cbar_kwargs=dict(shrink=0.8)))

    (nrl5.zχpod.sel(time=trange, num=2)
     .plot.line(x='time', ax=ax[2], color='w',
                lw=4, add_legend=False, _labels=False))
    hpod = (nrl5.zχpod.sel(time=trange, num=2)
            .plot.line(x='time', ax=ax[2], color='m',
                       lw=2, add_legend=False, _labels=False))
    dcpy.plots.annotate_end(hpod[0], 'χpod')

    hT = (nrl5.ctd['T'].sel(time=trange)
          .plot.contour(levels=np.arange(17.5, 22.6, 2.5),
                        colors='k', yincrease=False, linewidths=1, zorder=4))
    hlabels = dcpy.plots.contour_label_spines(hT, prefix='T=', rotation=0,
                                              fontsize=15, fmt='%.1f')

    ax[0].text(0.05, 0.9, 'Hourly, daily averaged diffusivity',
               transform=ax[0].transAxes,
               backgroundcolor=[0.5, 0.5, 0.5, 0.1])

    ax[1].set_title('')
    [aa.set_xlabel('') for aa in ax]

    # ax[-1].set_xlim((trange.start, pd.to_datetime(trange.stop).floor('D')))
    ax[-1].set_ylabel('P [dbar]')
    ax[-1].xaxis.set_major_formatter(mpl.dates.DateFormatter('%b-%d'))
    [tt.set_rotation(0) for tt in ax[-1].get_xticklabels()]
    ax[0].set_title('')
    f.set_size_inches((15, 6.25))

    f.savefig('images/nrl5-tide-inertial-shear.png')
#+END_SRC
#+CAPTION:
[[file:images/nrl5-tide-inertial-shear.png]]

** OSM 2018 figures
*** rama vs nrl | met & K_T
#+BEGIN_SRC ipython :session :results none
ax, hkr = ra12.met_turb_summary(region={'time': '2014', 'depth': 15}, naxes=2)
hdl_pointr, hdl_textr = dcpy.plots.annotate_end(hkr[0], '12N 15m')
ax['met'].set_xlabel('')
plt.gcf().set_size_inches((6, 3.25))

ha = []
arrowprops = dict(arrowstyle="<->", connectionstyle="arc3")
for date, bottom, top in zip(['2014-04-15', '2014-07-15', '2014-10-9', '2014-11-6'],
                             [5e-5, 5e-3, 5e-3, 2e-3],
                             [1, 1, 1, 1]):
    ha.append(ax['Kt'].annotate("",
                                xy=(date, bottom), xycoords='data',
                                xytext=(date, top), textcoords='data',
                                arrowprops=arrowprops))
    ha[-1].set_clip_on(False)
    ha[-1].set_in_layout(False)

htxt = []
htxt.append(
    ax['met'].text('2014-02-01', 0.35, 'NE', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-04-01', 0.35, 'NESW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-07-16', 0.35, 'SW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-10-20', 0.35, 'SWNE', va='bottom', zorder=-1)
)

ax['met'].set_xlim(('2014-01', '2015-01'))
ax['met'].set_ylim([0, 0.35])
ax['Kt'].xaxis.set_major_formatter(mpl.dates.DateFormatter('%b-%d'))
ax['Kt'].set_xlabel('2014')
ax['Kt'].set_ylabel('Daily avg. $K_T$ (m²/s)')
ax['Kt'].xaxis.set_tick_params(rotation=0)
plt.savefig('images/rama-vs-nrl-0.png', bbox_inches='tight')

ktnrl = (nrl5.KT.sel(time='2014')
         .dropna(dim='depth', how='all')
         .resample(time='D').mean(dim='time')
         .isel(depth=1))
hdl = ax['Kt'].plot(ktnrl.time, ktnrl, lw=0.75)
hdl_pointn, hdl_text4 = dcpy.plots.annotate_end(hdl[0], '8N 100m')

for hh in ha:
    hh.set_visible(False)

ha = []
arrowprops = dict(arrowstyle="->", connectionstyle="arc3")
ha.append(ax['Kt'].annotate("near-molecular!",
                       xytext=('2014-04-01', 7e-6), xycoords='data',
                       xy=('2014-04-15', 2e-7), textcoords='data',
                            arrowprops=arrowprops, ha='right'))

plt.gcf().set_size_inches((6, 3.25))
plt.savefig('images/rama-vs-nrl-1.png', bbox_inches='tight')

# extent = full_extent(ax['Kt']).transformed(f.transFigure.inverted())
# # We can now make the rectangle in figure coords using the "transform" kwarg.
# rect = mpl.patches.Rectangle([extent.xmin, extent.ymin],
#                              extent.width, extent.height,
#                              facecolor='yellow', edgecolor='none', zorder=-1,
#                              transform=fig.transFigure)
# f.patches.append(rect)

ax['Jq0'].set_visible(False)
ax['met'].set_visible(False)

plt.savefig('images/rama-vs-nrl-KT.png', bbox_inches='tight')

hkr[0].set_visible(False)
hdl_textr.set_visible(False)
hdl_pointr[0].set_visible(False)

ha.append(ax['Kt'].annotate("Arabian Sea water arrives",
                       xytext=('2014-06-01', 1e-3), xycoords='data',
                       xy=('2014-07-01', 5e-7), textcoords='data',
                            arrowprops=arrowprops, ha='right'))

ha.append(ax['Kt'].annotate("Near-inertial wave burst",
                       xytext=('2014-09-01', 1e-2), xycoords='data',
                       xy=('2014-07-27', 1e-3), textcoords='data',
                            arrowprops=arrowprops, ha='center'))

plt.savefig('images/nrl5-KT-labels.png', bbox_inches='tight')

#ax['met'].set_visible(True)

# (turb.S.sel(**nrlregion)
#  .dropna(dim='depth', how='all')
#  .resample(time='D').mean(dim='time')
#  .isel(depth=0)).plot.line(x='time', ax=ax['met'],
#                            color=hdl[0].get_color())

# ax['met'].set_ylim([34, 36])
# ax['met'].set_title('')
# ax['Kt'].xaxis.set_tick_params(rotation=0)
# plt.savefig('images/rama-vs-nrl-KT-nrl-sal.png', bbox_inches='tight')

#+END_SRC
[[file:images/rama-vs-nrl-1.png]]
*** rama vs nrl | K_T distributions
#+BEGIN_SRC ipython :session :ipyfile images/rama-vs-nrl-kt-violin.png
<<define-vert_distrib>>

moor_mask = np.logical_or(
    np.logical_and(KTdf.moor == 'RAMA12', np.round(KTdf.depth)==15),
    np.logical_and(KTdf.moor == 'NRL5', np.round(KTdf.depth) == 104))
new_deep_mask = np.logical_and(mask_deep, moor_mask)
subset = KTdf[moor_mask]

bins = [1018, 1022.5, 1026]
subset = bin_ktdf(subset, bins)

subset.loc[subset.moor == 'NRL5', 'z'] -= 85
subset.loc[subset.bin == 'ML', 'z'] -= 10
subset.loc[subset.bin == 'BL', 'z'] -= 5

with plt.rc_context({'font.size': 8}):
    f, ax = vert_distrib(subset, subset.bin, varname='KT',
                         label_moorings=False, label_bins=True, adjust_fig=False,
                         width=8, percentile=False, add_offset=False)

    for aa in ax:
         ax[aa].yaxis.set_visible(True)
         ax[aa].spines['left'].set_visible(True)

    ax['NE'].set_yticklabels(['', '', '15', '//', '', '100'])
    ax['NE'].set_ylim([28, 0])
    plt.gcf().set_size_inches((6.2, 1.8))
    plt.suptitle('$\log_{10}$ hourly averaged $K_T$ (m²/s)', y=-0.15, va='baseline')
    plt.subplots_adjust(wspace=0.07)
    sns.despine(fig=f, left=False, bottom=False, trim=True)

plt.savefig('images/rama-vs-nrl-kt.svg')
# plt.tight_layout(w_pad=-1)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1754]:
:END:

*** nrl5 adcp near-inertial
#+BEGIN_SRC ipython :session :ipyfile images/nrl5-near-inertial-adcp.png
#from dcpy.ts import xfilter
#f,  axx = plt.subplots(3, 1, sharex=True)
# ax = dict(Kt=axx[0], u=axx[1], v=axx[2])
# (nrl5.KT.isel(depth=1)
# .sel(**nrl5.select_region(['Storm+IW'])).plot(ax=ax['Kt']))
# ax['KT'].set_yscale('log')
# axv
with plt.rc_context({'font.size': 14}):
    ax, hc = nrl5.PlotVel(region='Storm+IW')
    ax['u'].set_ylim([250, 0])
    ax['v'].set_ylim([250, 0])
    ax['v'].set_xlabel('')

arrowprops = dict(arrowstyle="<-", connectionstyle="arc3")

hanno.remove()
hanno = ax['v'].annotate("",
                       xy=('2014-07-18', 70), xycoords='data',
                       xytext=('2014-08-7', 150), textcoords='data',
                       arrowprops=arrowprops)
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[1681]:
[[file:images/nrl5-near-inertial-adcp.png]]
:END:

*** χpod depths on ARGO climatology
#+BEGIN_SRC ipython :session
with plt.rc_context({'font.size': 14,
                     'axes.facecolor': 'white',
                     'savefig.transparent': False}):

   bay.mark_χpod_depths_on_clim(orientation='vertical')
   plt.gcf().set_size_inches(3, 8)
   plt.gcf().savefig('images/argo-clim-χpod-depths-vertical.png')

#+END_SRC
[[file:images/argo-clim-χpod-depths-vertical.png]]

* test bootstrap
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgMFPMNy.png
import numpy as np
import bootstrapped.bootstrap as bs
import bootstrapped.stats_functions as bs_stats

mean = 100
stdev = 10

population = np.random.normal(loc=mean, scale=stdev, size=50000)

# take 1k 'samples' from the larger population
samples = population[:1000]

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[570]:
:END:

* test slab model
#+BEGIN_SRC ipython :session
from dcpy.oceans import coriolis, calc_wind_power_input

ρ0 = 1025
time = pd.date_range('01-01-2014', '06-01-2014', freq='H')
H = 50
f0 = coriolis(15)
r = 0.15 * f0
τx = xr.DataArray(0.1 * np.cos(
    -f0 * (time-time[0]).astype('timedelta64[s]') .astype('float32')),
                  dims=['time'], coords={'time': time})
τy = xr.DataArray(0.1 * np.sin(
    -f0 * (time-time[0]).astype('timedelta64[s]') .astype('float32')),
                  dims=['time'], coords={'time': time})
T = (τx + 1j * τy)

σ = np.fft.fftshift(np.fft.fftfreq(len(T)))
That = xr.DataArray(np.fft.fftshift(np.fft.fft(T)),
                    dims=['σ'], coords={'σ': σ})

Zhat = -1j * σ/(r + 1j * f0)/(1j*σ + (r + 1j*f0)) * That/H/ρ0

expected = xr.DataArray(np.fft.ifft(np.fft.ifftshift(Zhat)),
                        dims=['time'], coords={'time': time})

_, actual = calc_wind_power_input(T, H, f0)

f, ax = plt.subplots(2, 1, constrained_layout=True)
expected.pipe(np.real).plot(ax=ax[0])
actual.pipe(np.real).plot(ax=ax[0])

expected.pipe(np.imag).plot(ax=ax[1])
actual.pipe(np.imag).plot(ax=ax[1])

# f.savefig('images/test-slab-model.png')
#+END_SRC
#+CAPTION:
[[file:images/test-slab-model.png]]
