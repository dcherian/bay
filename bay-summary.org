#+TITLE: Bay of Bengal notes
#+SETUPFILE: ~/org/notebook.org

* Map
#+NAME: map
#+BEGIN_SRC ipython :session :results none
import bay

bay.make_labeled_map()
plt.gcf().set_size_inches((6, 8))
plt.savefig('../images/map.svg')
plt.savefig('../images/map.png', bbox_inches='tight')
#+END_SRC
#+CAPTION: χ-pod locations.
#+ATTR_HTML: :width 55%
[[file:images/map.png]]

#+BEGIN_SRC ipython :session :results none
import bay
pods = {
    'RAMA67':
        {'lon': 67, 'lat': 0, 'label': 'RAMA',
         'ha': 'center', 'va': 'bottom',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA80':
        {'lon': 80, 'lat': 0, 'label': 'RAMA',
         'ha': 'center', 'va': 'bottom',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA90':
        {'lon': 90, 'lat': 0, 'label': 'RAMA',
         'ha': 'left', 'va': 'center',
         'depths': {
             '15 m': '',
             '30 m': ''}},
    'RAMA4':
        {'lon': 90, 'lat': 4, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '45 m': ''}},
    'RAMA12':
        {'lon': 90, 'lat': 12, 'label': 'RAMA',
         'ha': 'center', 'va': 'top',
         'depths': {
             '15 m': '',
             '45 m': ''}},
    'RAMA15':
        {'lon': 90, 'lat': 15, 'label': 'RAMA',
         'ha': 'right', 'va': 'center',
         'depths': {
             '15 m': '2018, 19',
             '30 m': '2018, 19',
             '45 m': '2018, 19',
             '55 m': '2018, 19',
             '65 m': '2018, 19'}},
}

ax, colors = bay.make_map(pods, DX=1, DY=1, add_year=False)

ax.set_xlim([65, 96])
ax.set_ylim([-2, 24])
ax.set_xticks([65, 67, 70, 75, 80, 85, 90, 95])
ax.set_yticks([0, 4, 8, 12, 15, 18, 20, 22, 24])

ax.set_title('MISOBOB $χ$pod deployments (2018, 19)')
plt.savefig('../images/map-misobob.svg')
plt.savefig('../images/map-misobob.png', bbox_inches='tight')
#+END_SRC
#+ATTR_HTML: :width 55%
[[file:images/map-misobob.png]]

** emily :noexport:
#+CAPTION: χpod locations for ASIRI/EBOB/MISOBOB
#+ATTR_HTML: :width 55%
[[file:../images/MixingmapASIRIPiston.png]]
* All χpods
** RAMA
#+ATTR_HTML: :class full-width
[[file:images/summary-RAMA-12N-2014.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-RAMA-12N-2015.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-RAMA-15N.png]]

** EBOB

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL1.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL2.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL3.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL4.png]]

#+ATTR_HTML: :class full-width
[[file:images/summary-NRL5.png]]

* vertical distribution of $K_T$
** Make plot
*** Mangle together and change to dataframe :noexport:
#+CALL: read-all-moorings()
#+NAME: make-merged-KT
#+BEGIN_SRC ipython :session :results none
import bay

moorings = [ra12, ra15, nrl1, nrl3, nrl4, nrl5]
bay.make_merged_nc(moorings)

#KTm = xr.open_dataset('merged_KT.nc', autoclose=True)
#ρbins = histedges_equalN(np.ravel(KTm.ρ), 11)
#Sbins = histedges_equalN(np.ravel(KTm.S), 11)

#KTdf = bin_and_to_dataframe(KTm, ρbins)
#+END_SRC
*** means/medians profile
#+NAME: vert-profile
#+BEGIN_SRC ipython :session :results none
import bay
bay = importlib.reload(bay)

moors = ['RAMA12', 'RAMA15', 'NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5']

bay.make_vert_distrib_plot('KT')
plt.savefig('images/vert-profile.svg', bbox_inches='tight')
plt.savefig('images/bay-KT-vert-profile.png', bbox_inches='tight')
#+END_SRC
#+ATTR_HTML: :class full-width
[[file:images/bay-KT-vert-profile.png]]

Some sensitivities:
1. Changing 505 to 'mmw': not much

2. High mixing at 70-100m depth in SW monsoon, compared to NE monsoon.
   1. Connected to SMC/SLD?
   2. Near-inertial waves from storms could be a thing
   3. Something happens in NRL5, around SW monsoon start to see temperature inversions semi-regularly (rare, but regular)

3. High values near surface are usually base of mixed layer/barrier layer χpods (527, 814)


#+NAME: save-distrib-for-each-mooring
#+BEGIN_SRC ipython :session :results none
import bay
bay = importlib.reload(bay)

bins = [1018, 1021, 1022, 1022.5, 1023, 1023.5, 1024.25, 1029]
moors = ['RAMA12', 'RAMA15', 'NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5']

for mm in moors:
    bay.make_vert_distrib_plot('KT', bins, mm)
    plt.gcf().suptitle(mm)
    plt.savefig('images/vert-profile-moor/'+mm+'.png', bbox_inches='tight')
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgrtIJ8z.png
season = 'SW'
bin_name = 24.0

ρmid = (KTdf.bin
        .apply(lambda x: x.mid-1000 if type(x) is not str else None))

if type(bin_name) is str:
    mask = KTdf.bin == bin_name
else:
    mask = (abs(ρmid - bin_name) < 0.2)

# mask = np.logical_and(mask, KTdf.season == season)
subset = KTdf[mask]
f, ax = vert_distrib(subset, subset.moor, varname='ρ')
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[702]:
:END:

#+NAME: sal-distrib
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgbp6rfN.png :results drawer
<<define-vert_distrib>>

Sbins = pd.qcut(KTdf.S, 11)

f, ax = plot_distrib(KTdf, bins, varname='S', xlines=[32, 35])
# plot_distrib(KTdf.where(KTdf.S > 34.9), bins, pal=[[0.5,0.5,0.5]]*13, f=f, ax=ax)
#+END_SRC
#+RESULTS: sal-distrib
:RESULTS:
[[file:images/temp/imgbp6rfN.png]]
:END:
*** full distrib seaborn
#+NAME: define-seaborn_vert_distrib
#+BEGIN_SRC ipython :session :results none
pal_dist = sns.color_palette("GnBu_d", n_colors=13)
pal_dist.reverse()

def seaborn_vert_distrib(KTdf, category, kind='kde'):
    stylekwargs = dict(style="ticks",
                       rc={'axes.facecolor': 'None',
                           'figure.facecolor': 'None'})
    bandwidth = 'scott'
    # pal_dist=sns.cubehelix_palette(11, rot=-.25, light=.7)
    # pal_dist = [pal_dist[0]]*13

    pal_boxplot = sns.color_palette("muted",
                                    n_colors=len(KTdf['latlon'].unique()))
    pal_boxplot[1] = (0,0,0)
    pal_boxdict = dict(zip(KTdf['latlon'].unique(), pal_boxplot))

    # pal = sns.cubehelix_palette(11, rot=-.25, light=0.7)

    def label(x, color, label):
        def stat_label(name, x, fmt, suffix=''):
            q75, q25 = np.percentile(x, [75, 25])
            return ((name+': {0:'+fmt+'}'+suffix
                     +', {1:'+fmt+'}'+suffix
                     +', {2:'+fmt+'}'+suffix)
                    .format(q25, x.mean(), q75))

        extract = KTdf.take(x.index)
        ax = plt.gca()
        label = float(label)
        if category == 'ρbinned':
            lab = (stat_label('S', extract.S, '.1f') + '\n'
                   + stat_label('z', extract.z, '.0f', 'm') + '\n'
                   +'σ: {0:2.1f}kg/m³'.format(label-1000))
        elif category == 'Sbinned':
            lab = '{0:2.1f}'.format(label)
        elif category == 'mean_depth':
            lab = '{0:.0f}m'.format(label)

        ax.text(1, 0.05, lab,
                color=(sns.light_palette((210, 90, 20), input="husl"))[3],
                fontsize=8,
                ha="right", va="bottom", transform=ax.transAxes)

    def mark_distributions_by_location(x, color, label):
        ax = plt.gca().twinx()
        gby = KTdf.take(x.index).groupby('latlon');

        for index, (name, grp) in enumerate(gby):
            props = {'linewidth': 1, 'color': pal_boxdict[name]}
            ax.boxplot(grp['KT'], vert=False, sym='', widths=0.08,
                       showbox=False,
                       showmeans=False, positions=[0.2+0.1*index],
                       boxprops={**props}, whiskerprops={**props},
                       medianprops={**props}, capprops={**props})

        ax.set_ylim([0, 2])
        ax.set_yticks([])

        # with sns.axes_style(**stylekwargs):
        #     sns.boxplot(data=KTdf.take(x.index), x='KT', hue='latlon',
        #                 ax=ax, orient='h', width=0.1)

    def mark_mean_mdn(x, color, label):
        ax = plt.gca()

        mean = np.log10(np.nanmean(10**x))
        median = np.log10(np.nanmedian(10**x))
        yloc = 0.5
        plt.plot(mean, yloc, color=color, marker='x')
        # plt.plot(mean, yloc, color='w', marker='x', fillstyle='none')
        plt.plot(median, yloc, color=color, marker='o', ms=10)
        plt.plot(median, yloc, color='w', marker='o', ms=11, fillstyle='none')

    with sns.axes_style(**stylekwargs):
        g = sns.FacetGrid(KTdf, row=category, col="season",
                          col_order=['NE', 'NESW', 'SW', 'SWNE'],
                          hue=category, xlim=[-7, 0],
                          sharex=True, sharey=True, palette=pal_dist,
                          aspect=4, size=1)


        kdekwargs = {'clip': [-8, 0],
                     'clip_on': False,
                     'cut': 0,
                     'bw': bandwidth}

        distkwargs = {'bins': 50, 'hist':True, 'rug':False, 'norm_hist':True,
                      'kde':False, 'kde_kws':{'lw': 1, **kdekwargs}}
        if kind == 'kde':
            g.map(sns.kdeplot, "KT", shade=True, alpha=0.6, lw=1.5, **kdekwargs)
            g.map(sns.kdeplot, "KT", color="w", lw=2, **kdekwargs)

        elif kind == 'dist':
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'alpha': 1})
            g.map(sns.distplot, "KT", **distkwargs,
                  hist_kws={'histtype': 'step', 'color': 'w',
                            'lw': 1, 'alpha': 1})

        g.map(plt.axhline, y=0, lw=2, clip_on=False)

        g.map(label, "KT")
        g.map(mark_mean_mdn, "KT")
        g.map(mark_distributions_by_location, "KT")
        g.fig.subplots_adjust(hspace=-0.58)
        g.set_xlabels('$K_T$')
        g.set_titles('')
        g.set(yticks=[], ylim=[0, 2])
        _ = g.despine(left=True)

        g.axes[1,0].set_title('NE\n(Dec-Mar)')
        g.axes[1,1].set_title('NE → SW\n(Apr-May)')
        g.axes[1,2].set_title('SW\n(Jun-Sep)')
        g.axes[1,3].set_title('SW → NE\n(Oct-Nov)')

        for index, tt in enumerate(KTdf['latlon'].unique()):
            plt.gcf().text(0.98,0.97-index*0.015, tt,
                           color=pal_boxplot[index],
                           ha='right', va='top')
            plt.suptitle('Columns are seasons, rows are density bins', y=0.95)

        return g

#+END_SRC

#+NAME: KT-vert-hist
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist.png :results drawer
<<define-seaborn_vert_distrib>>
KTdf['ρbinned'] = pd.qcut(KTdf.ρ, 11, precision=1)
KTdf.ρbinned = KTdf.ρbinned.apply(lambda x: x.mid)
g = seaborn_vert_distrib(KTdf, "ρbinned", 'dist')
#+END_SRC
#+RESULTS: KT-vert-hist
:RESULTS:
# Out[24]:
[[file:images/bay-KT-vert-hist.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/bay-sampling-hist.png :results drawer
<<define-seaborn_vert_distrib>>
KTdf.bin = pd.qcut(KTdf.ρ, 11, precision=1)
g = seaborn_vert_distrib(KTdf, "bin", 'dist')
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-vert-hist-depths.png
<<define-seaborn_vert_distrib>>
seaborn_vert_distrib(KTdf, 'mean_depth', 'kde')
#+END_SRC
#+RESULTS:
[[file:images/bay-KT-vert-hist-depths.png]]
*** old attempts
**** without MLD binning : only ρ binning
#+CAPTION: After extending unit 814 with pitot
[[file:images/bay-KT-vert-profile-pre-mld-bin.png]]

**** by latitude
#+NAME: kt-by-lat
#+BEGIN_SRC ipython :session :ipyfile images/bay-KT-by-lat.png
KTdf.loc[KTdf['depth'] == 43.0, 'depth'] = 45.0
KTdf.loc[KTdf['depth'] == 68.5, 'depth'] = 69.0
KTdf.loc[KTdf['depth'] == 89.4, 'depth'] = 88.2
g = sns.FacetGrid(KTdf, row='depth', col='lat', hue='season',
                  sharex=True, sharey=True,
                  hue_order=['NE', 'NESW', 'SW', 'SWNE'],
                  col_order=[5., 8., 12.0, 15.0],
                  margin_titles=True, legend_out=False,
                  size=1.2, aspect=2)

kdekwargs = {'clip': [-8, 0],
             'clip_on': False,
             'bw': 0.2}

g.map(sns.kdeplot, "KT", shade=False, lw=1.5, **kdekwargs)
g.add_legend()
g.set(xlim=[-8,0], ylim=[0, 1], yticks=[])
sns.despine(left=True)
plt.subplots_adjust(hspace=-0.15)
#+END_SRC
#+RESULTS: kt-by-lat
[[file:images/bay-KT-by-lat.png]]
** Bin testing
Test out binning so that there are equal number of observations (NaN filtered) in each bin
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgSAH1E0.png :results drawer
def histedges_equalN(x, nbin):
    # from https://stackoverflow.com/questions/39418380/histogram-with-equal-number-of-points-in-each-bin
    x = x[np.logical_not(np.isnan(x))]
    npt = len(x)
    return np.interp(np.linspace(0, npt, nbin + 1),
                     np.arange(npt),
                     np.sort(x))

turb.ρ.plot.hist(bins='fd', density=True)
ρbins = histedges_equalN(np.ravel(turb.ρ), 12)
_ = turb.ρ.plot.hist(bins=ρbins, density=True, edgecolor='k', facecolor='none')
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/temp/imgSAH1E0.png]]
:END:


#+NAME: argo-clim-density
#+BEGIN_SRC ipython :session :ipyfile images/mean-density-at-moorings.png
import dcpy.oceans
import seawater as sw

latitude = [12, 15, 5, 6.5, 8, 8, 8]
longitude = [90, 90, 85.5, 85.5, 85.5, 87, 88.5]
name = ['RA12', 'RA15', 'NRL1', 'NRL3', 'NRL4', 'NRL5']

_, ax = plt.subplots(1, 3, sharey=True)
if 'argoS' not in locals():
    argoS = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Salinity_2016.nc',
                            decode_times=False, autoclose=True)
    argoT = xr.open_dataset('~/datasets/argoclim/RG_ArgoClim_Temperature_2016.nc',
                            decode_times=False, autoclose=True)

for (lon, lat, moorname) in zip(longitude, latitude, name):
    S = argoS.ARGO_SALINITY_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    T = argoT.ARGO_TEMPERATURE_MEAN.sel(LONGITUDE=lon, LATITUDE=lat, method='nearest')
    ρ = sw.pden(S, T, argoS.PRESSURE)

    ax[0].plot(S, argoS.PRESSURE, label=moorname)
    ax[1].plot(T, argoS.PRESSURE, label=moorname)
    ax[2].plot(ρ, argoS.PRESSURE, label=moorname)

plt.ylim([120, 0])
plt.gcf().legend()
dcpy.plots.linex(Sbins, ax=ax[0])
dcpy.plots.linex(ρbins, ax=ax[2])
ax[0].set_ylabel('Pressure')
ax[0].set_xlabel('S')
ax[1].set_xlabel('T')
ax[1].set_xlim([20, 30])
ax[2].set_xlabel('ρ')
plt.gcf().suptitle('Roemmich & Gilson ARGO Climatology')
plt.gcf().set_size_inches((5.5, 2.5))
#+END_SRC
#+CAPTION: Mark density bins on ARGO climatology density profile
#+RESULTS: argo-clim-density
[[file:images/mean-density-at-moorings.png]]

#+NAME: TS-sampled-distribution
#+BEGIN_SRC ipython :session :ipyfile images/TSρ-sampled-by-χpod.png :results drawer
f, ax = plt.subplots(2,1)
sns.violinplot(data=KTdf.dropna(), x="depth", y="ρ", ax=ax[0])
sns.violinplot(data=KTdf.dropna(), x="depth", y="S", ax=ax[1])
# sns.violinplot(data=KTdf.dropna(), x="depth", y="T", ax=ax[2])
plt.gcf().autofmt_xdate()
ρbins2 = [ 1019.45,  1020.43,  1021.05,  1021.68,
           1022.49,  1022.94,  1023.49,  1026.27]
dcpy.plots.liney(ρbins, ax=ax[0])
dcpy.plots.liney(Sbins, ax=ax[1])
plt.gcf().set_size_inches((8.5, 7.5))
plt.tight_layout()
#+END_SRC
#+RESULTS: TS-sampled-distribution
:RESULTS:
[[file:images/TSρ-sampled-by-χpod.png]]
:END:

#+NAME: kmeans
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgiZJc38.png
data = KTdf.ρ
centroids, _ = sp.cluster.vq.kmeans(data, 10)
idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(10):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1])

#+END_SRC
#+RESULTS: kmeans
[[file:images/temp/imgiZJc38.png]]

#+NAME: TS-plot
#+BEGIN_SRC ipython :session :ipyfile images/rho-bins-TS-plot.png :results drawer
T, S, binned= dcpy.util.BinEqualizeHist([KTdf['T'], KTdf['S']], bins=[200, 100])
Tg, Sg = np.meshgrid(T, S, indexing='ij')
ρg = sw.pden(Sg, Tg, 50)
# plt.plot(KTdf['S'], KTdf['T'], '.')
plt.pcolormesh(S, T, binned.T, cmap=mpl.cm.Reds)
# hc = plt.contour(Sg, Tg, ρg, colors='k', levels=ρbins)
# plt.clabel(hc, fmt='%1.1f')
plt.xlabel('S')
plt.ylabel('T')

kmeans = 12

data = KTdf.ρ
centroids, _ = sp.cluster.vq.kmeans(data, kmeans)
idx, _ = sp.cluster.vq.vq(data, centroids)

for ii in range(kmeans):
    ST = np.vstack([KTdf.S[idx == ii], KTdf['T'][idx == ii]]).T
    hull = sp.spatial.ConvexHull(ST)
    plt.plot(ST[hull.vertices, 0], ST[hull.vertices, 1], 'k--')

cent = np.sort(centroids)
newbins = np.hstack([KTdf.ρ.min(), (cent[:-1]+cent[1:])/2])
hc = plt.contour(Sg, Tg, ρg, colors='k', levels=newbins, zorder=10)
plt.clabel(hc, fmt='%1.1f')
#+END_SRC
#+RESULTS: TS-plot
:RESULTS:
: <a list of 12 text.Text objects>
[[file:images/rho-bins-TS-plot.png]]
:END:
** analysis
*** Why is there a peak in SWNE in the EBOB array?
Biggest contribution is NRL1. Some more from NRL4. The low values are from NRL5. NRL3 seems to miss out... because the instruments are shallower?

#+CAPTION: 2014 monthly mean SSH EKE normalized by climatological monthly mean SSH EKE. NRL3 sees more EKE than usual.
[[file:images/eke-norm-clim-2014.png]]
*** At what ρ levels in the Bay is there large spiciness / large watermass contrasts?
  - σ=22-24; 23 is where the Arabian Sea S_{max} is.
* Surface fluxes
#+CALL: read-tropflux()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img7tMMDR.png
# sst = ra12.ctd['T'].sel(depth=1).groupby('time.month').mean(dim='time')

timebase = 'weekofyear'

tfsel = tropflux.sel(longitude=90, latitude=12, method='nearest')
tf = (tfsel.groupby('time.'+timebase)
      .mean(dim='time'))

jq0 = tf.netflux

if 'mldclim' not in locals():
   mldclim = dcpy.oceans.argo_mld_clim()

mld = mldclim.mld_da_mean.sel(lon=90, lat=12, method='nearest')

if timebase == 'weekofyear':
   ihi = np.interp(np.linspace(1,13, 53), mld.month,
                   0.45 * tfsel.swr.groupby('time.month').mean(dim='time')
                   ,* np.exp(-0.04 * mld))
   Ih = xr.DataArray(ihi, dims=[timebase],
                     coords=[jq0[timebase]], name='Ih')
else:
   Ih = 0.45*tfsel.swr.groupby('time.month').mean(dim='time')

f, ax = plt.subplots(2,1)
hsst = tf.sst.plot(ax=ax[0],color='k')
ax0 = ax[0]
ax1 = ax0.twinx()
hjq0 = ax1.fill_between(jq0[timebase], jq0-Ih, color='salmon')
ax1.set_zorder(-10)
ax1.axhline(0, color='k')
# hIh = Ih.plot.line('k--', ax=ax1)

ax0.set_title(''); ax1.set_title('');

_ = f.legend((hsst[0], hjq0),
           ('SST', 'Jq0-Ih'),
           loc='upper center')

jq14 = ra12.Jq.sel(time='2014').groupby('time.'+timebase).mean(dim='time')
jq15 = ra12.Jq.sel(time='2015').groupby('time.'+timebase).mean(dim='time')
jqt = (jq14.fillna(0) + jq15.fillna(0))/2
jqt.plot.line(ax=ax1)

_ = (mld*-1).plot(ax=ax[1])
args = {'color': 'k', 'ls': '--'}
ax[1].axhline(-15, **args)
ax[1].axhline(-30, **args)
ax[1].axhline(-45, **args)
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img7tMMDR.png]]
* Seasonal patterns
** depth of salinity surfaces

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgzT2m1u.png :results drawer
clim = xr.open_dataset('~/work/datasets/nio-atlas/nioa_climatology_seasonal_temp_salt_monsoon_season.nc', decode_times=False)

_, zmat = xr.broadcast(clim.SALT, clim.DEPTH)

S0 = 35
isodepth = zmat.where(np.logical_and(clim.SALT > 34.9, clim.SALT < 35.1)).mean(dim='DEPTH')

isodepth.plot(x='LONGITUDE', col='TIME', col_wrap=2, levels=np.arange(10, 500, 30))
#+END_SRC

#+RESULTS:
:RESULTS:
: <xarray.plot.facetgrid.FacetGrid at 0x7f44b39be6d8>
[[file:images/temp/imgzT2m1u.png]]
:END:
** "pycnocline uplift"
It is quite hard to see if there is a semi-regular period.

This could be the large-scale ∇S being advected back and forth across the mooring.
1. At 12N, it happens in Jul-2014, Jul-2015

#+BEGIN_SRC ipython :session :ipyfile images/rama-sal-mosaic.png :results drawer
sal = xr.open_dataset('~/TaoTritonPirataRama/RAMA/s_xyzt_dy.cdf',
                      autoclose=True)['S_41'].sel(lon=90, lat=[12,15])
sal.values[sal.values > 40] = np.nan
sal = sal.dropna(dim='depth', how='all')

def process(x):
    x = x.expand_dims('year')
    x['year'] = x.time.dt.year.pipe(np.unique)
    x['time'] = x.time.dt.dayofyear
    x = x.rename({'time': 'dayofyear'})
    return x

stacked = [process(a[1]) for a in sal.groupby('time.year')]

syearly = (xr.concat(stacked, dim='year')
           .dropna(dim='year', how='all')
           .drop([2007, 2018], dim='year'))

g = syearly.plot.contourf(x='dayofyear', row='year', col='lat',
                          robust=True, levels=40, yincrease=False, size=1, aspect=7)
# g.axes[0,0].set_xlim([0, 100])
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/rama-sal-mosaic.png]]
:END:
*** old figures :noexport:
[[file:images/15n-sal.png]]
[[file:images/12n-sal.png]]
** K_T variations
#+CAPTION: Distribution of 5 minute averages of K_T.
#+RESULTS:
[[file:../images//rama12n-kt-boxplot.png]]
** Seasonal cycle in internal wave energy?

Given a mooring calculate spectra at all depths. Average over season?

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgjHIylm.png

# T = nrl5.ctd['T_S']

kwargs = dict(dim='time', window=15*86400/10/60, shift=5*86400/10/60)
plot_kwargs = dict(cmap=svc.cm.blue_orange_div, add_colorbar=True)

spec = dcpy.ts.Spectrogram(nrl5.ctd.T_S.isel(z=3), **kwargs,
                           dt=10/24/60)
spec.freq.attrs['units'] = 'cpd'
spec.name = 'PSD(T)'

np.log10(spec).plot(robust=True, x='time', **plot_kwargs)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[62]:
: <matplotlib.collections.QuadMesh at 0x7fde680e0278>
[[file:images/temp/imgjHIylm.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgnRA15P.png
T = nrl5.ctd.T_S.isel(z=3)

kwargs = {'dt': 600/86400,
          'multitaper': True,
          'nsmooth': 5}
dcpy.ts.PlotSpectrum(T.monsoon.ne, **kwargs)
dcpy.ts.PlotSpectrum(T.monsoon.nesw, **kwargs)
dcpy.ts.PlotSpectrum(T.monsoon.sw, **kwargs)
dcpy.ts.PlotSpectrum(T.monsoon.swne, **kwargs)
tides = dcpy.ts.TidalAliases(600/86400)

plt.gca().axvline(1/(2*np.pi/dcpy.oceans.coriolis(8.5)/86400))
plt.gca().axvline(1/(2*np.pi/dcpy.oceans.coriolis(8.5)/86400))

dcpy.plots.linex([tt for tt in tides.values()])

plt.gca().legend(['NE', 'NESW', 'SW', 'SWNE'])

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[22]:
: <matplotlib.legend.Legend at 0x7f4248874b70>
[[file:images/temp/imgnRA15P.png]]
:END:

Let's integrate temperature spectrum in 3 bands:
1. Internal waves: 1/1.2f < freq < 1/20 minutes
2. Near-inertial: 1/1.2f < freq < 1/0.9f (*clockwise only*)
3. M2 : 0.9*f_M2 < freq < 1.1*f_M2
4. K1 : 0.9*f_K1 < freq < 1.1*f_K1

Compute the rotary spectra and integrate the sum if not near-inertial (in that case, I do clockwise only).
#+NAME: integrate_velocity_spectrum
#+BEGIN_SRC ipython :session :results none
kwargs = {'dt': 3600/86400,
          'multitaper': True,
          'nsmooth': 5}

Eiw = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                   columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                   dtype=np.float64)
Eniw = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                    columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                    dtype=np.float64)
Em2 = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                   columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                   dtype=np.float64)

Ek1 = pd.DataFrame(index=['NE', 'NESW', 'SW', 'SWNE'],
                   columns=['NRL1', 'NRL2', 'NRL3', 'NRL4', 'NRL5'],
                   dtype=np.float64)

tides = dcpy.ts.TidalAliases(dt=600/86400)

debug = True

def integrate_spectrum(spec, flo, fhi, debug=False):
    spec_iw = spec.where(np.logical_and(spec.freq > flo,
                                        spec.freq < fhi))

    if debug:
        spec.plot()
        spec_iw.dropna(dim='freq', how='all').plot()
        dcpy.plots.linex([flo, fhi])
        plt.gca().set_xscale('log')
        plt.gca().set_yscale('log')

    return (xrsp.integrate.trapz(spec_iw.dropna(dim='freq'),
                                 coord='freq')
            .values.ravel()[0])

if debug:
    with plt.style.context('ggplot'):
        fall, axall = plt.subplots(1, 2);
        fall.set_size_inches((10, 10/2.5))

for moor in [nrl1, nrl3, nrl4, nrl5]:
    print(moor.name)
    inertial = 1/(2*np.pi/(dcpy.oceans.coriolis(moor.lat)*86400))

    T = ((moor.vel.u + 1j * moor.vel.v)
         .sel(depth=100, method='nearest'))

    if np.all(np.isnan(T)):
        continue

    with plt.style.context('ggplot'):
        if debug:
            dcpy.ts.PlotSpectrum(T.dropna(dim='time'),
                                 preserve_area=True,
                                 ax=axall, twoside=True, **kwargs)

            f, ax = plt.subplots(2, 2, sharex=True, sharey=True)
            f.set_size_inches(8, 5)
            plt.suptitle(moor.name)
            axes = dict(NE=ax[0,0], SW=ax[0,1],
                        NESW=ax[1,0], SWNE=ax[1,1])

        for season in Eiw.index:
            # T = (np.hypot(moor.vel.u, moor.vel.v)
            #      .sel(depth=100, method='nearest'))

            Tsub = (T.where(T.monsoon.labels == season)
                    .sel(time='2014')
                    .dropna(dim='time'))

            # S, freq, conf = dcpy.ts.SpectralDensity(T, **kwargs)
            cw, ccw, freq, conf_cw, conf_ccw = dcpy.ts.RotaryPSD(Tsub, **kwargs)

            dakwargs = dict(dims=['freq'], coords={'freq': freq})
            spec = xr.Dataset()
            spec['cw'] = xr.DataArray(cw, **dakwargs)
            spec['ccw'] = xr.DataArray(ccw, **dakwargs)

            if debug:
                dcpy.ts.PlotSpectrum(Tsub, axes[season], twoside=False,
                                     preserve_area=True,
                                     ,**kwargs)
                axes[season].set_title(season)

            # spec = xr.DataArray(S, dims=['freq'], coords={'freq': freq})
            # integrate_spectrum(spec.cw, 0.9*inertial, 1.2*inertial)

            Eiw[moor.name][season] = (integrate_spectrum(spec.cw + spec.ccw,
                                                         0.9*inertial,
                                                         1/1200*86400))
            Eniw[moor.name][season] = (
                integrate_spectrum(spec.cw, 0.9*inertial, 1.2*inertial))
            Em2[moor.name][season] = (integrate_spectrum(spec.cw+spec.ccw,
                                                         0.9*tides['M2'],
                                                         1.1*tides['M2']))
            Ek1[moor.name][season] = (integrate_spectrum(spec.cw+spec.ccw,
                                                         0.9*tides['K1'],
                                                         1.1*tides['K1']))

        if debug:
            dcpy.plots.linex([0.9*inertial, 1.2*inertial,
                              0.9*tides['M2'], 1.1*tides['M2'],
                              0.9*tides['K1'], 1.1*tides['K1']],
                             ax=ax.ravel())
            [aa.set_xlabel('') for aa in ax[0, :]]
            [aa.set_ylabel('') for aa in ax[:, 1]]
            [aa.set_xlabel('Freq (cpd)') for aa in ax[1, :]]
            [aa.set_ylim([0, 0.013]) for aa in ax.flat]

            f.savefig('images/rotary-vel-spectra-'+moor.name+'.png',
                      bbox_inches='tight', transparent=False)

axall[0].set_ylim(axall[1].get_ylim())
axall[1].legend(['NRL1', 'NRL3', 'NRL4', 'NRL5'])
fall.savefig('images/rotary-vel-spectra-NRL.png', bbox_inches='tight',
             transparent=False)
#+END_SRC

#+CAPTION: Seasonal area/variance-preserving two-sided spectra of velocity at 100m for NRL1,3,4,5.
[[file:images/rotary-vel-spectra-NRL.png]]

[[file:images/rotary-vel-spectra-NRL1.png]]
[[file:images/rotary-vel-spectra-NRL3.png]]
[[file:images/rotary-vel-spectra-NRL4.png]]
[[file:images/rotary-vel-spectra-NRL5.png]]

#+BEGIN_SRC ipython :session :ipyfile images/temperature-seasonal-variance.png
f, ax = plt.subplots(1, 3)
sns.heatmap(Eiw*1e3, ax=ax[0], robust=True, annot=True, linecolor='w', linewidths=3,
            cmap=mpl.cm.Reds, fmt='.2f')
ax[0].set_title('internal wave band')

sns.heatmap(Eniw*1e3, ax=ax[1], robust=True, annot=True, linecolor='w', linewidths=3,
            cmap=mpl.cm.Reds, fmt='.2f')
ax[1].set_title('NIW band')

sns.heatmap(Em2*1e3, ax=ax[2], robust=True, annot=True, linecolor='w', linewidths=3,
            cmap=mpl.cm.Reds, fmt='.2f')
ax[2].set_title('M2 band')

f.suptitle('Temperature variance at 200m')
f.set_size_inches(16, 5)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[475]:
:END:

** Seasonal cycle in M_2 tide!
There is a seasonal cycle in M2. There are also prominent tidal harmonics = nonlinear tide?

There is a more prominent seasonal cycle in the K1 tide too?

Most of these KT are contaminated by instrument moving down in the water column :(

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl1.png
nrl1.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[171]:
[[file:images/seasonal-nrl1.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl2.png
nrl2.plot_spectrogram()
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl3.png
nrl3.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[176]:
[[file:images/seasonal-nrl3.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl4.png
nrl4.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[175]:
[[file:images/seasonal-nrl4.png]]
:END:

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-nrl5.png
nrl5.plot_spectrogram()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[174]:
[[file:images/seasonal-nrl5.png]]
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgdYM4bm.png
dt = 10/24/60
kwargs = dict(dim='time', dt=dt, window=25/dt, shift=5/dt)

spec = dcpy.ts.Spectrogram(self.ctd['T'].sel(depth2=150), **kwargs)
np.log10(spec).plot(robust=True, x='time')
plt.gca().set_yscale('log')

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[157]:
:END:


#+begin_SRC ipython :session :ipyfile images/temp/imgoi5WUg.png
spec = dcpy.ts.Spectrogram(ra15.vel.spd.interpolate_na(dim='time').squeeze(),
                           dim='time',
                           window=(7*86400)/(30*60),
                           shift=(3.5*86400)/(30*60), nsmooth=15)
np.log10(spec).plot.contourf(x='time', levels=40);
plt.gca().set_yscale('log')
#+END_SRC

#+RESULTS:
** Seasonal cycle in NIW?
*** NIW input u⋅τ
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgCv7Gly.png
self = nrl5

ut = (self.vel.u.isel(depth=0) * self.tropflux.taux
)
#+END_SRC
*** NIW energy at moorings

#+BEGIN_SRC ipython :session :ipyfile images/seasonal-niw-nrl.png
import bay

if 'nrl1' not in locals():
    nrl1 = bay.read_nrl1()

def depth_average(da, depth_range):
    import xrscipy as xrsp
    return (xrsp.integrate.trapz(da.sel(depth=depth_range),
                                 coord='depth'))

f, ax = plt.subplots(2, 2, constrained_layout=True)

for idx, moor in enumerate([nrl1, nrl3, nrl4, nrl5]):
    aa = ax.flat[idx]
    top = depth_average(moor.niw.KE, slice(0, 40))
    bottom = depth_average(moor.niw.KE, slice(40, None))

    def plot_monthly_average(da):
        mean = da.groupby('time.month').mean(dim='time')
        std = da.groupby('time.month').std(dim='time')

        norm = mean.max()
        (mean/norm).plot(yerr=std/norm/np.sqrt(2), ax=aa)

    plot_monthly_average(top)
    plot_monthly_average(bottom)
    aa.set_title(moor.name)
    f.legend(['0-40m', 'below 40m'], loc='outside')
    f.suptitle('Normalized seasonal mean depth integrated NIW KE + std')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[290]:
[[file:images/seasonal-niw-nrl.png]]
:END:
:END:
*** Ewa NIW @ NRL processing :noexport:
#+NAME: read-ewa
#+BEGIN_SRC ipython :session :results none
for fname in ['NRL1', 'NRL3', 'NRL4', 'NRL5']:

    nn = sp.io.loadmat('../datasets/ewa/' + fname + 'cxdm_out.mat', squeeze_me=True)

    time = dcpy.util.datenum2datetime(nn['date_time'])
    nrl = xr.Dataset()
    nrl['amp'] = xr.DataArray(nn['CA'].T/100,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['amp'].attrs['long_name'] = 'Clockwise amplitude'
    nrl['amp'].attrs['units'] = 'm/s'

    nrl['pha'] = xr.DataArray(nn['Cp'].T,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['pha'].attrs['long_name'] = 'Clockwise phase'
    nrl['pha'].attrs['units'] = 'rad'

    nrl['KE'] = xr.DataArray(nn['CKE'].T,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['KE'].attrs['long_name'] = 'Clockwise KE'
    nrl['KE'].attrs['units'] = 'J/m³'

    nrl.attrs['name'] = fname

    nrl.to_netcdf('../datasets/ewa/'+fname+'.nc')
#+END_SRC

#+NAME: plot-niw
#+BEGIN_SRC ipython :session :results none
def plot_ewa_niw(nrl):
    import cmocean

    kwargs = dict(robust=True, yincrease=False, cmap=mpl.cm.Reds)

    f, ax = plt.subplots(3, 1, sharex=True, sharey=True)

    nrl.amp.plot(ax=ax[0], **kwargs)
    nrl.pha.plot(ax=ax[1], robust=True, cmap=cmocean.cm.phase, yincrease=False, center=0)
    nrl.KE.plot(ax=ax[2], **kwargs)

    f.suptitle(nrl.name, y=0.91)
    ax[0].set_xlabel('')
    ax[1].set_xlabel('')


for nn in ['NRL1', 'NRL3', 'NRL4', 'NRL5']:
    nrl = xr.open_dataset('../datasets/ewa/' + nn + '.nc', autoclose=True).load()
    plot_ewa_niw(nrl)
    plt.savefig('../images/niw-' + nn + '.png', bbox_inches='tight')


#+END_SRC
** Seasonal cycle code
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgDcsXFa.png




#+END_SRC

* Barrier layers
When the freshwater arrives, I see large values of Jqt at 30m/45m. This is at both 12N, 15N in both 2014, 2015.

- This observation contradicts the presence of layers hmmm...

- Some of these are where T_z changes sign frequently. (╯°□°）╯︵ ┻━┻

- Sally says that in the Gulf of Mexico she thinks that ambient water is getting subducted under river plumes and mixing there because of strong shear at the base. This is as opposed to the standard barrier layer idea that there is not much mixing happening beneath the mixed layer: i.e., the freshwater cap prevents wind-forced turbulence from penetrating downward?

- Ritabrata observes similar stuff: high mixing near the base and mixing shuts down in 10-20m range below the base.

Some examples follow.
#+NAME: barrier-rama15-2015
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama15-2015-feb.png :results raw
ax = ra15.Plotχpods(region={'time': slice('2015-02-01', '2015-03-31')},
                    filt='mean',  filter_len=6*3600, Tlim=[26.5,28])
_ = ax['T'].set_ylim([50,0])
_ = ax['Jq'].set_yscale('symlog', linthreshy=10, linscaley=0.5)
#+END_SRC
#+ATTR_HTML: :class full-width
#+CAPTION: In this one, the rise in turbulence at 30m coincides with *speed increasing*. 30m χpod sees relatively few changes in T_z sign, but high heat fluxes (compare with below). The "waviness" seems to be M_2.
#+RESULTS: barrier-rama15-2015
[[file:images/barrier-layer-rama15-2015-feb.png]]

When the freshwater arrives we see stronger M_2 tides, maybe a packet came by? But the variability is confined to 20m, 40m CTDs.

#+BEGIN_SRC ipython :session :ipyfile images/rama-15n-freshwater-M2.png
f, ax = plt.subplots(3,1, sharex=False, sharey=False)

(ra15.ctd.S.sel(depth=[10, 20, 40, 60],
                time=slice('2015-02-01', '2015-04-10'))
.plot.line(x='time', ax=ax[0]))

(ra15.ctd.S.sel(depth=[10, 20, 40, 60],
                time=slice('2015-02-22', '2015-03-01'))
.plot.line(x='time', ax=ax[1], add_legend=False))
ax[0].set_title('RAMA 15N, arrival of freshwater 2015 - Note M2 signal')

specargs =dict(dt=600/86400, nsmooth=2, multitaper=True, preserve_area=False, ax=ax[2])
dcpy.ts.PlotSpectrum(ra15.ctd.S.sel(depth=40,
                                    time=slice('2015-02-16', '2015-03-10')),
                     **specargs)
dcpy.ts.PlotSpectrum(ra15.ctd.S.sel(depth=40,
                                    time=slice('2015-03-20', '2015-04-10')),
                     **specargs)
ax[2].set_ylim([10**-5, 1])
ax[2].set_xlabel('Freq (cpd)')
dcpy.plots.linex([1/(2*np.pi/dcpy.oceans.coriolis(15)/86400),
                  24/12.42], ax=ax[2])

plt.gca().set_title('Spectra of salinity at 40m | RAMA 15N, 90E')
plt.legend(['2015-Feb-16 - 2015-Mar-10', '2015-Mar-20 - 2015-Apr-10'])
# plt.gca().set_yscale('linear')
# plt.gca().set_ylim([0, 1])

plt.setp(ax[0].get_xticklabels(), visible=True, rotation=20)
plt.setp(ax[1].get_xticklabels(), visible=True, rotation=20)

f.set_size_inches((8.5, 12.5))
plt.tight_layout()
#+END_SRC
#+RESULTS:
:RESULTS:
[[file:images/rama-15n-freshwater-M2.png]]
:END:

10m velocity is not useful: 10m salinity behaves much differently. There's a near inertial packet Mar 13-17, otherwise just M2 in velocity.
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgt8hw0H.png
hdl, ax = (dcpy.ts.PlotSpectrum((ra15.vel.u+1j*ra15.vel.v)
                                .squeeze().sel(time=slice('2014-02-16',
                                                          '2014-03-10')),
                                multitaper=True, dt=30*60/86400))
hdl, ax = (dcpy.ts.PlotSpectrum((ra15.vel.u+1j*ra15.vel.v)
                                .squeeze().sel(time=slice('2014-03-12',
                                                          '2014-04-10')),
                                multitaper=True, dt=30*60/86400, ax=ax))

dcpy.plots.linex([1/(2*np.pi/dcpy.oceans.coriolis(15)/86400),
                  24/12.42], ax=ax)
ax[1].set_xlim([1e-1, 1e1])
ax[0].set_xlim([1e1, 1e-1])
#+END_SRC

#+RESULTS:
:RESULTS:
: (10.0, 0.1)
[[file:images/temp/imgt8hw0H.png]]
:END:

#+NAME: barrier-rama12-2014
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama12-2014-feb.png :results raw
ax = ra12.Plotχpods(region={'time': slice('2014-02-20', '2014-03-20')},
                    Tlim=[26.5, 28.75],
                    filt='hann',  filter_len=3*3600)
_ = ax['T'].set_ylim([60,0])
#+END_SRC
#+CAPTION: Here, both χpods see frequent changes in the sign of T_z and heat fluxes are large and change sign often. |T_z| stays decently big (0.01-0.1) for chunks of time --- these are associated with large fluxes. Maybe using internal T_z might make sense here.
#+RESULTS: barrier-rama12-2014
[[file:images/barrier-layer-rama12-2014-feb.png]]

#+NAME: barrier-rama12-2015
#+BEGIN_SRC ipython :session :ipyfile images/barrier-layer-rama12-2015-apr.png :results raw
ax = ra12.Plotχpods(filt='hann',  filter_len=6*3600, met='tropflux')
_ = ax['T'].set_ylim([60,0])
_ =  ax['met'].set_xlim(('2015-04-10', '2015-05-10'))
#+END_SRC
#+CAPTION: Not that similar to above (but see 2015/04/15-2015/04/18). Here, 45m χpod sees large heat fluxes.
#+RESULTS: barrier-rama12-2015
[[file:images/barrier-layer-rama12-2015-apr.png]]
* Hudhud sensitivity to Jq
# Read data
#+BEGIN_SRC ipython :session
def read_Turb(filename):
    from scipy.io import loadmat
    f = loadmat(filename)

    def process_estimate(estimate):
        chi = xr.Dataset()
        tmatlab = estimate[0,0]['time'][0,0].squeeze()
        tcommon = ((-86400 + (tmatlab-366) * 86400).astype('timedelta64[s]')
                   + np.datetime64('0001-01-01')).astype('datetime64[ns]')

        chi['χ'] = xr.DataArray(estimate[0,0]['chi'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['Kt'] = xr.DataArray(estimate[0,0]['Kt'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['Jq'] = xr.DataArray(estimate[0,0]['Jq'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])
        chi['ε'] = xr.DataArray(estimate[0,0]['eps'][0,0].squeeze(),
                                dims=['time'],
                                coords=[tcommon])

        return chi

    Turb = dict()
    for field in f['Turb'].dtype.names:
        if field in ['mm1', 'mm2', 'pm1', 'pm2',
                     'mi11', 'mi22', 'pi11', 'pi22']:
            estimate = f['Turb'][field]
            Turb[field] = process_estimate(estimate)
    return Turb

dirname = '/home/deepak/pods/526/proc/'
est = dict()
for tz in [1e-4, 3e-4, 7.5e-4, 1e-3, 2e-3, 5e-3]:
    filename = dirname + 'Turb-{0:.1e}.mat'.format(tz)
    print(filename)
    est[tz] = read_Turb(filename)

if ra12.sst == xr.Dataset():
    ra12.ReadSST()
#+END_SRC

# plot results
#+BEGIN_SRC ipython :session
trange = slice('2014-10-07','2014-10-11')
hudhud = slice('2014-10-08','2014-10-10 12:00')

uTx = (ra12.sst.Tx.sel(time=trange)
       ,* ra12.vel.u.squeeze().resample(time='D').mean(dim='time'))
vTy = (ra12.sst.Ty.sel(time=trange)
       ,* ra12.vel.v.squeeze().resample(time='D').mean(dim='time'))


meanvel = ra12.vel.sel(time=trange).mean()
meanSST = ra12.sst.sel(time=hudhud).mean()
meanSST = ra12.sst.sel(time=hudhud).mean()

mld = 15
Qadv = -(uTx + vTy) * 1025 * 4200 * mld
Qmean = -(meanvel.u * meanSST.Tx + meanvel.v * meanSST.Ty) * 1025 * 4200 * mld
print(Qmean)
print(Qadv.sel(time=hudhud).mean())

barwidth = 1e-4
f, ax = plt.subplots(2, 1)
for ee in est.keys():
    Jqvec = est[ee]['mm1'].Jq
    (Jqvec
     .resample(time='H').mean()
     .sel(time=trange)
     .plot(ax=ax[1], lw=1, label=ee))

    hb = ax[0].bar(ee, Jqvec.where(Jqvec > 0).sel(time=hudhud).mean(),
                   barwidth)
    ax[0].bar(ee, Jqvec.where(Jqvec < 0).sel(time=hudhud).mean(),
              barwidth, color=hb[0].get_facecolor())
    ax[0].plot(ee, Jqvec.sel(time=hudhud).mean(), 'k.')

ax[0].set_title('Mean heat flux (+/-) during Hudhud as fn(min_dTdz)')

hwda = (ra12.Jq.sel(depth=15, time=trange)
        .plot(ax=ax[1], add_legend=False, label='wda'))
ax[1].legend()

dcpy.plots.liney([ra12.Jq.where(ra12.Jq > 0).sel(depth=15, time=hudhud).mean(),
                  ra12.Jq.where(ra12.Jq < 0).sel(depth=15, time=hudhud).mean()],
                 ax=ax, color=hwda[0].get_color(), zorder=8)
dcpy.plots.liney(0, ax=ax, zorder=10, color='k', ls='-')
dcpy.plots.liney([Qadv.sel(time=hudhud).mean(), Qmean],
                 ax=ax, color='k', zorder=10)

plt.savefig('/home/deepak/bay/images/526-heat-flux-dTdz.png', bbox_inches='tight')
#+END_SRC

#+CAPTION: Sensitivity to ~min_dTdz~. Looks like there are a lot of observations at T_z ~ 1e-3. For lower values of ~min_dTdz~, there is a lot of +/- cancellation. Which do I believe? Bottom time series is hourly averaged Jq (for comparison with sally's paper). The WDA estimate in pink is still 60s-average.
file:images/526-heat-flux-dTdz.png

#+CAPTION: Turns out removing IC fits removes a lot of data during Hudhud.
[[file:images/wda-526-hudhud-jq-masking.png]]

* ECCO $K_d$
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgrONH8U.png
ecco = xr.open_dataset('../datasets/ecco/interp_Kd_ECCOv4.nc');

Kd = ecco.Kd_ECCOv4
Kd = xr.DataArray(Kd.values,
                  coords={'lon': Kd.lon.sel(i1=1).values,
                          'lat': Kd.lat.sel(i2=1).values,
                          'dep': Kd.dep.values},
                  dims=['lat', 'lon', 'dep'])

np.log10(Kd.sel(dep=50)).plot.contourf(levels=15);
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[200]:
[[file:images/temp/imgrONH8U.png]]
:END:


#+BEGIN_SRC ipython :session :ipyfile images/temp/imgfv1To1.png
np.log10(Kd).sel(lon=90, lat=[12, 15], method='nearest').plot.line(y='dep', yincrease=False)
np.log10(Kd).sel(lon=[85.5, 87, 88.5], lat=8, method='nearest').plot.line(y='dep', yincrease=False)
plt.gca().set_ylim([500, 0])
dcpy.plots.linex(np.log10([1e-6, 1e-5, 5e-4]))
dcpy.plots.liney([15, 30, 45])
plt.xlim([-6.5, -3])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[388]:
: (-6.5, -3)
[[file:images/temp/imgfv1To1.png]]
:END:

* O_2, nutrients
** climatological profiles
#+NAME: read-nutrients
#+BEGIN_SRC ipython :session :ipyfile :results none
o2 = xr.open_dataset('../datasets/woa13/woa13_all_o00_01.nc',
                     autoclose=True, decode_times=False)
o2seas = xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_o*_01.nc',
                           autoclose=True, decode_times=False)

n = xr.open_dataset('../datasets/woa13/woa13_all_n00_01.nc',
                     autoclose=True, decode_times=False)
nseas = xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_n*_01.nc',
                           autoclose=True, decode_times=False)

p = xr.open_dataset('../datasets/woa13/woa13_all_p00_01.nc',
                    autoclose=True, decode_times=False)
pseas = xr.open_mfdataset('../datasets/woa13/woa13-season/woa13_all_p*_01.nc',
                          autoclose=True, decode_times=False)
i = xr.open_dataset('../datasets/woa13/woa13_all_i00_01.nc',
                     autoclose=True, decode_times=False)
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/bay-chem-annual-mean.png
import bay

def plot_nutrients(nut, nutseas, var, ax, **kwargs):
    mean = (nut[var+'_mn'].sel(**bay.region)
            .mean(dim=['lat', 'lon']).squeeze())
    if ax[0] is not None:
        (mean.plot(ax=ax[0], y='depth', yincrease=False, color='k',
                   lw=2, zorder=10, **kwargs))
        plt.gca().set_ylim([150, 0])

    if var != 'o':
        ((mean/mean.sel(depth=150, method='nearest'))
         .plot(ax=ax[1], y='depth', yincrease=False, **kwargs))
    else:
        ((mean/mean.max())
         .plot(ax=ax[1], y='depth', yincrease=False, **kwargs))

    if nutseas is not None:
        (nutseas[var+'_mn'].sel(**bay.region)
         .mean(dim=['lat', 'lon']).squeeze()
         .plot.line(ax=ax[0], y='depth', yincrease=False, hue='time', **kwargs))

f, ax = plt.subplots(1, 4, sharey=True)
f.set_size_inches(8,4)
plot_nutrients(o2, o2seas, 'o', [ax[0], ax[-1]], add_legend=False)
plot_nutrients(n, nseas, 'n', [ax[1], ax[-1]], add_legend=False)
plot_nutrients(p, pseas, 'p', [ax[2], ax[-1]])
plot_nutrients(i, None, 'i', [None, ax[-1]])

ax[-1].set_title('')
ax[-1].set_xlabel('Normalized profile')
ax[-1].set_xlim([0, 1])
ax[-1].legend(['O₂', 'N', 'P', 'Si'])

[aa.set_ylabel('') for aa in ax[1:]]
f.suptitle('Average oxygen, nutrient distributions (WOA13) for Bay of Bengal')
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[166]:
: Text(0.5,0.98,'Average oxygen, nutrient distributions (WOA13) for Bay of Bengal')
[[file:images/bay-chem-annual-mean.png]]
:END:

** gyaan
cite:Sarma2016
1. Primary production is comparable to AS for NE and transitions but /lower/ for SW.
2. Cold-core eddies uplift nutrients?
3. Silicate is not a limiting nutrient
4. More depletion of N, P in the north

* Ewa NIW @ NRL
#+NAME: read-ewa
#+BEGIN_SRC ipython :session :results none
for fname in ['NRL1', 'NRL3', 'NRL4', 'NRL5']:

    nn = sp.io.loadmat('../datasets/ewa/' + fname + 'cxdm_out.mat', squeeze_me=True)

    time = dcpy.util.datenum2datetime(nn['date_time'])
    nrl = xr.Dataset()
    nrl['amp'] = xr.DataArray(nn['CA'].T/100,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['amp'].attrs['long_name'] = 'Clockwise amplitude'
    nrl['amp'].attrs['units'] = 'm/s'

    nrl['pha'] = xr.DataArray(nn['Cp'].T,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['pha'].attrs['long_name'] = 'Clockwise phase'
    nrl['pha'].attrs['units'] = 'rad'

    nrl['KE'] = xr.DataArray(nn['CKE'].T,
                             dims=['depth', 'time'],
                             coords={'time': time,
                                     'depth': nn['depth_levels']})
    nrl['KE'].attrs['long_name'] = 'Clockwise KE'
    nrl['KE'].attrs['units'] = 'J/m³'

    nrl.attrs['name'] = fname

    nrl.to_netcdf('../datasets/ewa/'+fname+'.nc')
#+END_SRC

#+NAME: plot-niw
#+BEGIN_SRC ipython :session :ipyfile images/temp/img19kudT.png
def plot_ewa_niw(nrl):
    import cmocean

    kwargs = dict(robust=True, yincrease=False, cmap=mpl.cm.Reds)

    f, ax = plt.subplots(3, 1, sharex=True, sharey=True)

    nrl.amp.plot(ax=ax[0], **kwargs)
    nrl.pha.plot(ax=ax[1], robust=True, cmap=cmocean.cm.phase, yincrease=False, center=0)
    nrl.KE.plot(ax=ax[2], **kwargs)

    f.suptitle(nrl.name, y=0.91)
    ax[0].set_xlabel('')
    ax[1].set_xlabel('')


for nn in ['NRL1', 'NRL3', 'NRL4', 'NRL5']:
    nrl = xr.open_dataset('../datasets/ewa/' + nn + '.nc', autoclose=True).load()
    plot_ewa_niw(nrl)
    plt.savefig('../images/niw-' + nn + '.png', bbox_inches='tight')


#+END_SRC
* MISO signals?
** Summary
cite:Sobel2010 show large TRMM 30-90 day variance between May and October in the Bay.
[[file:../images//sobel-trmm-variance.png]]

#+CAPTION: Subsurface anomalies line up with northward propagating features in SST, LWR.
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]

#+CAPTION: Southward propagating signals in 2011-Nov/Dec!
#+RESULTS:
[[file:images/bandpass-90e-2011.png]]

*** old                                                          :noexport:
I see northward propagating "anomalies" in Tropflux SWR.
[[file:images/90e-swr-anom.png]]
** in mixing
*** RAMA 12N
**** Coherence
- Note sure coherence is the way to do this given short records

The next figure shows coherence between Jq0 and  Jqt at 15m, 30m at the RAMA 12N mooring for the year 2014. Signs for all fluxes are such that +ve warms the surface.
Looks like we have significant coherence in the 20-60day band between daily averaged Jq0 and Jqt at 15m.
The 180 phase difference looks stable, is apparent in the filtered time series and seems to make physical sense (more surface heating → increases T_z → reduces J_q^t and vice versa).

Nothing at 30m
 - short(er) data record - instrument dies in september
 - not much temp fluctuations at that depth while the instrument was alive (see above).

#+CAPTION: (Top left) Band-passed time series. (bottom left) PSD for the unfiltered time series. (Right) coherence amplitude and phase between J_q^0 and J_q^t at both depths. Significance level marked by horizontal line. Pass band marked by vertical lines.
file:rama/images/ra12-jq0-jqt-coherence.png
** temp / salinity record
*** Stratification T_z
Filtered T_z?
#+BEGIN_SRC ipython :session :ipyfile images/ra12n-bandpass-strat.png
from dcpy.plots import offset_line_plot
f, ax = plt.subplots(4, 1, sharex=True)

trange = slice('2014-06', '2014-08')
T = rama.SelectVar('T', dict(lon=90))
Tz = (T.sel(lat=12)
      .dropna(dim='depth', how='all')
      .drop(-13, dim='depth')
      .diff(dim='depth'))
Tz /= Tz.sel(time=trange).std(dim='time')
Tzbp = (Tz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Tzbp /= Tzbp.sel(time=trange).std(dim='time')

S = rama.SelectVar('S', dict(lon=90))
Sz = (S.sel(lat=12)
      .dropna(dim='depth', how='all')
      .diff(dim='depth'))
Sz /= Sz.sel(time=trange).std(dim='time')
Szbp = (Sz.pipe(BandPassButter, freqs, dt=1, dim='time'))
Szbp /= Szbp.sel(time=trange).std(dim='time')

dcpy.plots.offset_line_plot(
    Tz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[0])

dcpy.plots.offset_line_plot(
    Tzbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[1])

dcpy.plots.offset_line_plot(
    Sz.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[2])

dcpy.plots.offset_line_plot(
    Szbp.dropna(dim='time', how='all')
    .sel(depth=[-20, -40], time=trange),
    x='time', y='depth', offset=0, ax=ax[3])

ax[0].set_ylabel('$ΔT$')
ax[1].set_ylabel('$ΔT$\'')
ax[2].set_ylabel('$ΔS$')
ax[3].set_ylabel('$ΔS$\'')

dcpy.plots.liney(0, ax=ax[0])
dcpy.plots.liney(0, ax=ax[1])

plt.suptitle('10-80 day bandpass filtered at χpod depths / normalized by std.', y=1.0)
plt.tight_layout()
plt.gcf().autofmt_xdate()
#+END_SRC

#+RESULTS:
[[file:images/ra12n-bandpass-strat.png]]
*** Subsurface MISO signals?
What am I looking for?
1. northward propagation of MISO signal
2. subsurface MISO signals in 30d-90d band

#+BEGIN_SRC ipython :session :ipyfile images/temp/asd02j.png :noweb yes
if 'rama' not in locals():
     print('reading rama')
     <<read-rama-array>>

flen = np.array([10.0, 80.0])
hdl, var = rama.hov('T', region=dict(lon=90, depth=[-1, -10, -20]),
                    row='depth', filt='bandpass',
                    filter_len=flen*86400)

plt.gcf().set_size_inches((8.5, 2.5))
plt.gca().set_xlim(['2011-01-01', '2013-07-01'])
plt.gcf().autofmt_xdate()
# plt.gcf().suptitle('bandpass ' + str(flen) + 'days')
#+END_SRC
#+CAPTION: Hovmöller plot of RAMA 90E data | Bandpassed 10, 80 days. Looks like _southward_ propagation in Nov/Dec 2011.
#+RESULTS:
[[file:images/temp/asd02j.png]]
#+BEGIN_SRC ipython :session :ipyfile images/rama-iso-T-std.png :noweb yes
if 'rama' not in locals():
    <<read-rama-array>>

from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

Tfilt = BandPassButter(rama.T.where(rama.T < 40), freqs=freqs, dim='time')

MayToOct = np.logical_and(Tfilt.time.dt.month >=5,
                          Tfilt.time.dt.month <= 10)

def plot_temp_std_along_lon(Tfilt, inmask, lon):
    f, ax = plt.subplots(2, 2, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx], cmap=mpl.cm.Reds))

        # normalize at each lat,lon by maximum in depth
        Tnorm = Tstd / Tstd.max(dim='depth')
        Tnorm.name = 'normalized to \n show structure'
        (Tnorm.sel(lon=lon)
         .dropna(dim='depth', how='all')
         .dropna(dim='lat', how='all')
         .plot(ax=ax[idx+2], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_along_lon(Tfilt, MayToOct, lon=90)
#+END_SRC
#+CAPTION: Lon = 90: Max 30-90 day std dev is within 5S-5N as expected from Han (2005). Seems independent of season. Subsurface peak = thermocline? Agrees with Girishkumar et al (2013)
#+RESULTS:
[[file:images/rama-iso-T-std.png]]

#+BEGIN_SRC ipython :session :ipyfile images/iso-T-std-lat-lon-map.png
def plot_temp_std_lat_lon(Tfilt, inmask):
    ''' Takes max. std along depth and plots in (lon, lat) space'''
    f, ax = plt.subplots(2, 1, sharex=True, sharey=True)

    ax = ax.flat
    for idx, mask in enumerate([inmask, ~inmask]):
        Tstd = (Tfilt.where(mask)
                     .std(dim=['time'], skipna=True))
        Tstd.name = '30d-90d std dev of temp'

        (Tstd.dropna(dim='depth', how='all')
             .dropna(dim='lat', how='all')
             .max(dim=['depth']).transpose()
             .plot(ax=ax[idx], cmap=mpl.cm.Reds))

    ax[0].set_xlabel('')
    ax[0].set_title('May-Oct')
    ax[1].set_title('Nov-Apr')
    plt.tight_layout()

plot_temp_std_lat_lon(Tfilt, MayToOct)
#+END_SRC
#+CAPTION: Taking max(std) along depth → (lon, lat) map. Some sign of near-equatorial maxima.
#+RESULTS:
[[file:images/iso-T-std-lat-lon-map.png]]


#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907n9q.png
from dcpy.ts import apply_along_dim_1d

freqs = [1/30.0, 1/60.0]

T = rama.T.copy()

T.values[T.values > 40] = np.nan

apply_along_dim_1d(T, 'time', dcpy.ts.FillGaps, x=T.time, maxlen=20)

bp = (BandPassButter(T.sel(lon=90, lat=[15, 12, 8])
                     .dropna(dim='time', how='all'),
                     freqs=freqs, dim=['time'])
      .dropna(dim='depth', how='all'))

bp.plot.contourf(row='lat', x='time', levels=40)
plt.gcf().set_size_inches((8.5, 4.5))
plt.gca().set_ylim([-140, 0])
# plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:images/temp/img3907n9q.png]]

#+call: read-rama-array()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img9554Dcu.png
from dcpy.plots import offset_line_plot

T = rama.SelectVar('T', dict(lon=90.0))

T = T.groupby('time.month') - T.groupby('time.month').mean(dim='time')
Tclim = T.groupby('time.dayofyear').mean(dim='time')
Tanom = T.groupby('time.dayofyear') - Tclim


offset_line_plot(T.sel(depth=-1)
           .dropna(dim='time', how='all'),
          x='time', y='lat')
plt.gca().set_xlim('2011', '2014')

# Tanom.sel(depth=-1).plot()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC

#+RESULTS:
[[file:images/temp/img9554Dcu.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-90e-2014.png :noweb yes
freqs = [1/10.0, 1/80.0]
time = '2015'

<<bandpass-mosaic>>
#+END_SRC
#+CAPTION: Southward propagating signals in 2011-Nov/Dec, but not so much in 2014?
#+RESULTS:
[[file:images/bandpass-90e-2014.png]]
*** Spectra
#+call: read-mur()

#+NAME: calc-spec
#+BEGIN_SRC ipython :session :results none
import xarray as xr
from dcpy.ts import SpectralDensity

var = rama.SelectVar('T', region=dict(lon=90, lat=12)).dropna(dim='depth', how='all')

iz = var.get_axis_num('depth')

spec = []
for zz in range(var.shape[iz]):
    S, f, conf = SpectralDensity(var.isel(depth=zz), dt=1,
                                 multitaper=False, nsmooth=2,
                                 fillgaps=True, maxlen=60)
    # create a DataArray
    spec.append(xr.DataArray(S, coords=[f], dims=['freq'],
                             attrs={'depth': var.depth.values[zz]},
                             name='PSD'))
#+END_SRC

:code-notes:
1. Let's try FFT - yes, using ~apply()~ works like doing things manually. +But results look weird+ xarray isn't respecting missing_value; haven't figured out why :(

2. bah gaps are non-uniform at all depths. can't do the groupby-apply thing. lets make a list of DataArrays and iterate over them when we plot.

3. xarray line-plots are only for 1D data.

:END:
#+CALL: calc-spec()
#+BEGIN_SRC ipython :session :ipyfile images/12n-spectra.png :exports results
if 'mur' in locals():
    S, f, conf = dcpy.ts.SpectralDensity(mur['sst'].sel(lon=90, lat=12), multitaper=True)
    plt.loglog(f, S*10**1.25, label='SST', lw=0.5)

for si, ss in enumerate(spec[0:8]):
    (ss*10**-si**1.15).plot(label=str(ss.depth), lw=0.5)

plt.title('12N 90E')
ax = plt.gca()
ax.set_xscale('log')
ax.set_yscale('log')
ax.legend()
plt.gcf().set_size_inches(8.5, 5.5)
plt.xlim([10**-3.5, 1])
#+END_SRC

#+RESULTS:
[[file:../images/12n-spectra.png]]

*** spectra old :noexport:
#+BEGIN_SRC ipython :session :ipyfile images/temp/img16594-DQ.png
data = rama.SelectVar('T', region=dict(lon=90, lat=12, depth=10))

S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=True)
plt.loglog(f, S)
S, f, conf = SpectralDensity(data.where(data < 40), fillgaps=False, maxlen=60, multitaper=False)
plt.loglog(f, S)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img16594-DQ.png]]

#+BEGIN_SRC ipython :session
%matplotlib inline

import moor.moor as moor
import chipy.chipy as chipy

moor = importlib.reload(moor)
chipy = importlib.reload(chipy)

import os
if 'rama' not in os.getcwd():
    os.chdir('/home/deepak/rama/scripts/')

ra12 = moor.moor(90, 12, 'RAMA 12N', '../RAMA13/')
# ra12.AddChipod(526, 15, 'mm', '2017-07-10.mat')
# ra12.AddChipod(527, 30, 'mm', '2017-07-10.mat')
ra12.ReadMet('../RAMA13/rama_mooring_data/', WindType='pmel')
# ra12.ReadCTD('../RamaPrelimProcessed/RAMA13.mat', 'ramaprelim')
ra12.ReadCTD('../data/', 'rama')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :session :ipyfile images/temp/py28335Frc.png
dcpy.ts = importlib.reload(dcpy.ts)
dcpy.oceans = importlib.reload(dcpy.oceans)
dcpy.plots = importlib.reload(dcpy.plots)

freqs = [1/(2*np.pi/dcpy.oceans.inertial(ra12.lat)/86400),
         dcpy.ts.AliasFreq(1/(12.42/24), 1),
         1/30, 1/90]

nsmooth = 4
subset = None
mtflag = True

plt.figure(figsize=(6.5, 10.5))
ax0 = plt.subplot(211)
dcpy.ts.PlotSpectrum(ra12.ctd.Tlong, SubsetLength=subset, ax=ax0,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
ax0.set_ylabel('PSD (T)')
if mtflag:
    ax0.set_title('Multitaper')

dcpy.plots.linex(freqs)
ax1 = plt.subplot(212, sharex=ax0)
dcpy.ts.PlotSpectrum(ra12.ctd.Slong, SubsetLength=subset, ax=ax1,
                     nsmooth=nsmooth, multitaper=mtflag, scale=4)
dcpy.plots.linex(freqs)
ax1.set_ylabel('PSD (S)')
ax1.set_xlabel('Freq (cpd)')

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//temp/py28335Frc.png]]

** winds at EBOB and rama
#+BEGIN_SRC ipython :session :ipyfile images/bob-winds.png
from scipy.interpolate import interpn

tau = nc.MFDataset('../tropflux/tau_tropflux*')
flx = nc.MFDataset('../tropflux/netflux_tropflux*')

ttime = tau['time'][:]
ftime = flx['time'][:]

ax = [1, 1, 1, 1]
ax[0] = plt.subplot(4, 1, 1)
ax[0].set_title('RAMA')
ax[1] = plt.subplot(4, 1, 2, sharex=ax[0])
ax[1].set_title('EBOB')
ax[2] = plt.subplot(4, 1, 3, sharex=ax[0])
ax[2].set_title('RAMA')
ax[3] = plt.subplot(4, 1, 4, sharex=ax[0])
ax[3].set_title('EBOB')

for latm, lonm in zip([12, 18, 5.5, 8],
                     [90, 90, 85.5, 88.5]):

    if latm < 12:
        ind = 1
    else:
        ind = 0

    label = str(latm) + 'N, ' + str(lonm) + 'E'
    τtrop = interpn((ttime,
                     tau['latitude'][:],
                     tau['longitude'][:]),
                    tau['tau'][:, :, :],
                    (ttime, latm, lonm))
    ftrop = interpn((ttime,
                     flx['latitude'][:],
                     flx['longitude'][:]),
                    flx['netflux'][:, :, :],
                    (ttime, latm, lonm))
    ttrop = ttime \
            + dt.date2num(dt.datetime.date(1950, 1, 1))

    ax[ind].plot(ttrop, τtrop, label=label)
    ax[ind+2].plot(ttrop, ftrop, label=label)

for ind in [0,1]:
    ax[ind].xaxis_date()
    ax[ind].legend()
    ax[ind].set_ylim([0, 0.4])
    ax[ind].set_ylabel('τ (N/m²)')
    ax[ind+2].set_ylabel('flux (W/m²)')

ax[0].set_xlim([dt.datetime.datetime(2013, 11, 29, 0, 0, 0),
                dt.datetime.datetime(2015, 1, 1, 0, 0, 0)])
ax[2].axhline(0, color='gray')
ax[3].axhline(0, color='gray')
plt.gcf().autofmt_xdate()
plt.tight_layout()
#+END_SRC
#+RESULTS:
[[file:../images//bob-winds.png]]
** in SWR
Look at anomalies:
1. Subtract yearly average.
2. Subtract daily climatology (2001-2017)

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-anom.png :noweb yes
if 'swr' not in locals():
    <<read-tropflux-swr>>
swr['swr'].load()

grpstr = 'time.dayofyear'

# pick location
sw = swr['swr'].sel(longitude=90.5, latitude=slice(0.5, 22.5))
# remove yearly average
swa = (sw.groupby('time.year')
       - sw.groupby('time.year').mean(dim='time'))
# make daily climatology
clim = sw.groupby(grpstr).mean(dim='time')
# get daily anomalies
anom = sw.groupby(grpstr) - clim

f, ax = plt.subplots(3, 1, sharey=True)

(anom.sel(time=slice('2014-05', '2014-09'))
     .plot(x='time', y='latitude', ax=ax[0]))
(anom.sel(time=slice('2015-05', '2015-09'))
     .plot(x='time', y='latitude', ax=ax[1]))

(anom.sel(time=slice('2013', '2016'))
     .groupby('time.dayofyear')
     .mean(dim='time')
     .plot(x='dayofyear', y='latitude', ax=ax[2]))
ax[2].set_title('anomalies averaged over 2013-2016')

ax[0].set_xlabel('')
ax[1].set_xlabel('')
ax[1].set_title('')

plt.tight_layout()
plt.gcf().set_size_inches((8.5, 4.5))
#+END_SRC
#+CAPTION: Shortwave radiation anomalies w.r.t daily climatology [2001-2017]. Definitely see northward propagating anomalies along 90°E. Propagation is most evident for lat > 8°N. Winter is quite for lat > 10.
#+RESULTS:
[[file:images/90e-swr-anom.png]]

Let's try 10-80day filter like cite:Sengupta2001a
#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SWR.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]

if 'swr' not in locals():
    swr = xr.open_mfdataset('../datasets/tropflux/swr*.nc', autoclose=True)

swr['swr'].load()

bp = (
    swr['swr'].sel(longitude=[85, 90], method='nearest')
    .pipe(BandPassButter, freqs, dt=1, dim='time')
)

bp.sel(time='2014').plot(x='time', row='longitude')

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC
#+CAPTION: bandpass filter yields same results as above (slightly smoother).
#+RESULTS:
[[file:images/bandpass-SWR.png]]

#+BEGIN_SRC ipython :session :ipyfile images/90e-swr-spec.png
dcpy.ts.PlotSpectrum(swr['swr'].sel(latitude=[15, 12, 8], longitude=90, method='nearest'), multitaper=True, nsmooth=5, scale=5)
dcpy.plots.linex([1/10.0, 1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0, 1/120, 1/180, 1/360])
plt.title('Tropflux SWR spectra along 90E')
plt.legend(('15N', '12N', '8N'))
#+END_SRC
#+CAPTION: Spectra of SW radiation along 90°E. Seasonal cycle harmonics are very evident 360, 180, 90, 45. 120-day peak at 8N, 12N.
#+RESULTS:
[[file:images/90e-swr-spec.png]]

** SST analysis
*** test snapshot
#+CALL: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907o-U.png
mur['sst'].isel(time=1).plot()
#+END_SRC
#+CAPTION: Test snapshot
#+RESULTS:
[[file:../images//temp/img3907o-U.png]]
*** spec
#+call: read-mur()
#+BEGIN_SRC ipython :session :ipyfile images/mur-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

# psd = xrft.power_spectrum(mur['sst'].sel(lon=90, lat=12), dim=['time'], density=True, window=True, detrend='constant')
scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = mur.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('MUR SST spectra along RAMA line')
plt.legend()
#+END_SRC
#+CAPTION: MUR SST spectra 2013-2016
#+RESULTS:
[[file:images/mur-spectra-RAMA-line.png]]


#+BEGIN_SRC ipython :session :ipyfile images/cmc-spectra-RAMA-line.png
%matplotlib inline

import xrft.xrft as xrft

scale = 2.2
for idx, lat in enumerate([8, 12, 15, 18]):
    da = cmc.sst.sel(lon=90, lat=lat)
    dcpy.ts.PlotSpectrum(da, label=str(lat)+'N'+', 90E',
                         scale=scale**-idx, axis=0, multitaper=True)

dcpy.plots.linex([1/20.0, 1/30.0, 1/45.0, 1/60.0, 1/90.0])
plt.xlabel('freq (cpd)')
plt.title('CMC SST spectra along RAMA line (2007-2017)')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:images/cmc-spectra-RAMA-line.png]]

#+BEGIN_SRC ipython :session :ipyfile images/bandpass-SST.png
from dcpy.ts import BandPassButter

freqs = [1/10.0, 1/80.0]


(cmc['sst'].sel(lon=[85, 90], method='nearest')
           .where(cmc.mask == 1)
           .pipe(BandPassButter, freqs, dt=1, dim='time')
           .sel(time='2014')
           .plot(x='time', row='lon'))

plt.gca().set_ylim((0, 22))
plt.gcf().suptitle('[10, 80] day bandpass filtered', y=1.1)
plt.gcf().set_size_inches((8.5, 3.5))
#+END_SRC

#+RESULTS:
[[file:images/bandpass-SST.png]]
*** SST variance map
#+BEGIN_SRC ipython :session :results none
freqs = [1/30.0, 1/90.0]

bp = dcpy.ts.BandPassButter(sst, freqs=freqs, dim=['time'])
bp = bp.dropna(dim='time', how='all')

# dcpy.ts.PlotSpectrum(mur['sst'].sel(lon=90, lat=12))
# dcpy.plots.linex(freqs)
# dcpy.ts.PlotSpectrum(bp.sel(lon=90, lat=12))
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907dce.png]]
#+BEGIN_SRC ipython :session :results none
import matplotlib.animation

def animate(i):
    import matplotlib.pyplot as plt
    plt.clf()
    hdl = bp.isel(time=i).plot()
    return hdl

anim = mpl.animation.FuncAnimation(plt.gcf(), animate)

anim.save('sst-iso.mp4', fps=5)
#+END_SRC
* vel spectra

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907nzu.png
u = rama.SelectVar('u', region=dict(lon=90, lat=12))
v = rama.SelectVar('v', region=dict(lon=90, lat=12))
KE = 0.5*np.hypot(u,v)

dcpy.ts.PlotSpectrum(KE)
dcpy.ts.PlotSpectrum(KE, multitaper=True)
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907nzu.png]]


#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907fRQ.png
np.sqrt(N2).plot()
plt.ylabel('N (1/s)')
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907fRQ.png]]

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907mHE.png
KE = np.hypot(ra12.vel.u, ra12.vel.v)*2

dcpy.ts.PlotSpectrum(KE, dt=30*60.0, multitaper=False, label='KE 10m')

# figure out N²
woa = dcpy.oceans.ReadWoa(lon=90, lat=12, return_xr=True)
N2, _, pn2 = sw.bfrq(woa['S'], woa['T'], woa['depth'], lat=12)

N2 = xr.DataArray(np.squeeze(N2), coords=[np.squeeze(pn2)], dims=['depth'])
N = np.sqrt(N2)
omg, K_omg, P_omg, _, _, _ = dcpy.oceans.GM(lat=12.0,
                                            N=N.sel(depth=10, method='nearest').values,
                                            N0=N.sel(depth=50, method='nearest').values)

# plot frequency spectra
ax = plt.gca()
ax.loglog(omg/(2*np.pi), 2*np.pi*K_omg, label='GM81 KE')
ax.loglog(omg/(2*np.pi), 2*np.pi*P_omg, label='GM81 PE')
ax.legend(frameon=False)
ax.set_title('energy spectra')
ax.set_xlabel('frequency (cps)')
ax.set_ylabel('power spectral density (m^2/s^2/cps)')

#+END_SRC
#+CAPTION: Attempt at GM spectra for KE
#+RESULTS:
[[file:../images//temp/img3907mHE.png]]

* TS plots

#+BEGIN_SRC ipython :session :ipyfile images/TS.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.TSPlot(ax=ax3)
nrl5.TSPlot(ax=ax1)
ra12.TSPlot(ax=ax2)

ax1.set_xlim([32, 36])
plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//TS.png]]

#+BEGIN_SRC ipython :session :ipyfile images/KT-seasonal.png
plt.figure(figsize=(10,10))

ax1 = plt.subplot(221)
ax2 = plt.subplot(222, sharex=ax1, sharey=ax1)
ax3 = plt.subplot(223, sharex=ax1, sharey=ax1)

nrl1.ChipodSeasonalSummary(ax=ax3)
nrl5.ChipodSeasonalSummary(ax=ax1)
ra12.ChipodSeasonalSummary(ax=ax2)

plt.tight_layout()
#+END_SRC

#+RESULTS:
[[file:../images//KT-seasonal.png]]
* MLD climatology

#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907e_A.png
mld = dcpy.oceans.argo_mld_clim()

ax = plt.gca()
for lat in range(0, 22, 2):
    mld.mld_da_mean.sel(lon=90, lat=lat,
                        method='nearest', tolerance=1).plot(ax=ax, label=str(lat))

plt.title('lon=90.5')
plt.legend()
#+END_SRC

#+RESULTS:
[[file:../images//temp/img3907e_A.png]]

* [#B] ARGO data : S_min and S_max
[[file:../images//argo-smin-smax.png]]
* code tests
** MLD calc
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgJlnzfg.png
f, ax = plt.subplots(1,3)

it = 35000
ra15.ctd['T'].isel(time=it).plot(ax=ax[0])
dcpy.plots.linex(ra15.ild.isel(time=it), ax=ax[0])

ra15.ctd['S'].isel(time=it).plot(ax=ax[1])
dcpy.plots.linex(ra15.sld.isel(time=it), ax=ax[1])

ra15.ctd['ρ'].isel(time=it).plot(ax=ax[2])
dcpy.plots.linex(ra15.mld.isel(time=it), ax=ax[2])
#+END_SRC

#+RESULTS:
:RESULTS:
:END:
* OSM 2018 figures
** rama vs nrl | met & K_T
#+BEGIN_SRC ipython :session :results none
def full_extent(ax, pad=0.0):
    """Get the full extent of an axes, including axes labels, tick labels, and
    titles."""

    from matplotlib.transforms import Bbox
    # For text objects, we need to draw the figure first, otherwise the extents
    # are undefined.
    ax.figure.canvas.draw()
    items = [ax, ax.title, ax.xaxis.label, ax.yaxis.label]
    items += (ax.get_xticklabels() + ax.get_yticklabels())
    bbox = Bbox.union([item.get_window_extent() for item in items])

    return bbox.expanded(1.0 + pad, 1.0 + pad)

ax, hkr = ra12.met_turb_summary(region={'time': '2014', 'depth': 15}, naxes=2)
ax['met'].set_xlabel('')
plt.gcf().set_size_inches((6, 3.25))

ktrama = (ra12.KT.sel(time='2014')
         .dropna(dim='depth', how='all')
         .resample(time='D').mean(dim='time')
         .isel(depth=0))
hdl_pointr = ax['Kt'].plot(ktrama.time[-1], ktrama[-1],
                           'o', ms=4, color=hkr[0].get_color(), clip_on=False)
hdl_textr = ax['Kt'].text('2014-12-31', ktrama[-1], '  12N 15m', ha='left',
                          clip_on=False, color=hkr[0].get_color())

arrowprops = dict(arrowstyle="<->", connectionstyle="arc3")
ha1 = ax['Kt'].annotate("",
                        xy=('2014-04-15', 5e-5), xycoords='data',
                        xytext=('2014-04-15', 1), textcoords='data',
                        arrowprops=arrowprops)
ha2 = ax['Kt'].annotate("",
                        xy=('2014-07-15', 5e-3), xycoords='data',
                        xytext=('2014-07-15', 1), textcoords='data',
                        arrowprops=arrowprops)
ha3 = ax['Kt'].annotate("",
                        xy=('2014-10-9', 5e-2), xycoords='data',
                        xytext=('2014-10-9', 10), textcoords='data',
                        arrowprops=arrowprops)

htxt = []
htxt.append(
    ax['met'].text('2014-02-01', 0.35, 'NE', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-04-15', 0.35, 'NESW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-07-16', 0.35, 'SW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-10-20', 0.35, 'SWNE', va='bottom', zorder=-1)
)

ax['met'].set_xlim(('2014-01', '2015-01'))
ax['met'].set_ylim([0, 0.35])
ax['Kt'].xaxis.set_major_formatter(mpl.dates.DateFormatter('%b-%d'))
ax['Kt'].set_xlabel('2014')
ax['Kt'].set_ylabel('Daily avg. $K_T$ (m²/s)')
ax['Kt'].xaxis.set_tick_params(rotation=0)
plt.tight_layout()
plt.savefig('images/rama-vs-nrl-0.png', bbox_inches='tight')

ktnrl = (nrl5.KT.sel(time='2014')
         .dropna(dim='depth', how='all')
         .resample(time='D').mean(dim='time')
         .isel(depth=1))
hdl = ax['Kt'].plot(ktnrl.time, ktnrl, lw=0.75)
hdl_pointn = ax['Kt'].plot(ktnrl.time[-1], ktnrl[-1],
                           'o', ms=4, color=hdl[0].get_color(), clip_on=False)
hdl_textn = ax['Kt'].text('2014-12-31', ktnrl[-1], '  8N 100m', ha='left',
                          clip_on=False, color=hdl[0].get_color())

for ha in [ha1, ha2, ha3]:
    ha.set_visible(False)

ha = []
arrowprops = dict(arrowstyle="->", connectionstyle="arc3")
ha.append(ax['Kt'].annotate("near-molecular!",
                       xytext=('2014-04-01', 7e-6), xycoords='data',
                       xy=('2014-04-15', 2e-7), textcoords='data',
                            arrowprops=arrowprops, ha='right'))

plt.gcf().set_size_inches((6, 3.25))
plt.savefig('images/rama-vs-nrl-1.png', bbox_inches='tight')

# extent = full_extent(ax['Kt']).transformed(f.transFigure.inverted())
# # We can now make the rectangle in figure coords using the "transform" kwarg.
# rect = mpl.patches.Rectangle([extent.xmin, extent.ymin],
#                              extent.width, extent.height,
#                              facecolor='yellow', edgecolor='none', zorder=-1,
#                              transform=fig.transFigure)
# f.patches.append(rect)

ax['Jq0'].set_visible(False)
ax['met'].set_visible(False)

plt.savefig('images/rama-vs-nrl-KT.png', bbox_inches='tight')

hkr[0].set_visible(False)
hdl_textr.set_visible(False)
hdl_pointr[0].set_visible(False)

ha.append(ax['Kt'].annotate("Arabian Sea water arrives",
                       xytext=('2014-06-01', 1e-3), xycoords='data',
                       xy=('2014-07-01', 5e-7), textcoords='data',
                            arrowprops=arrowprops, ha='right'))

ha.append(ax['Kt'].annotate("Near-inertial wave burst",
                       xytext=('2014-09-01', 1e-2), xycoords='data',
                       xy=('2014-07-27', 1e-3), textcoords='data',
                            arrowprops=arrowprops, ha='center'))

plt.savefig('images/nrl5-KT-labels.png', bbox_inches='tight')

#ax['met'].set_visible(True)

# (turb.S.sel(**nrlregion)
#  .dropna(dim='depth', how='all')
#  .resample(time='D').mean(dim='time')
#  .isel(depth=0)).plot.line(x='time', ax=ax['met'],
#                            color=hdl[0].get_color())

# ax['met'].set_ylim([34, 36])
# ax['met'].set_title('')
# ax['Kt'].xaxis.set_tick_params(rotation=0)
# plt.savefig('images/rama-vs-nrl-KT-nrl-sal.png', bbox_inches='tight')

#+END_SRC
[[file:images/rama-vs-nrl-1.png]]
** rama vs nrl | K_T distributions
#+BEGIN_SRC ipython :session :ipyfile images/rama-vs-nrl-kt-violin.png
<<define-vert_distrib>>

moor_mask = np.logical_or(
    np.logical_and(KTdf.moor == 'RAMA12', np.round(KTdf.depth)==15),
    np.logical_and(KTdf.moor == 'NRL5', np.round(KTdf.depth) == 104))
new_deep_mask = np.logical_and(mask_deep, moor_mask)
subset = KTdf[moor_mask]

bins = [1018, 1022.5, 1026]
subset = bin_ktdf(subset, bins)

subset.loc[subset.moor == 'NRL5', 'z'] -= 85
subset.loc[subset.bin == 'ML', 'z'] -= 10
subset.loc[subset.bin == 'BL', 'z'] -= 5

with plt.rc_context({'font.size': 8}):
    f, ax = vert_distrib(subset, subset.bin, varname='KT',
                         label_moorings=False, label_bins=True, adjust_fig=False,
                         width=8, percentile=False, add_offset=False)

    for aa in ax:
         ax[aa].yaxis.set_visible(True)
         ax[aa].spines['left'].set_visible(True)

    ax['NE'].set_yticklabels(['', '', '15', '//', '', '100'])
    ax['NE'].set_ylim([28, 0])
    plt.gcf().set_size_inches((6.2, 1.8))
    plt.suptitle('$\log_{10}$ hourly averaged $K_T$ (m²/s)', y=-0.15, va='baseline')
    plt.subplots_adjust(wspace=0.07)
    sns.despine(fig=f, left=False, bottom=False, trim=True)

plt.savefig('images/rama-vs-nrl-kt.svg')
# plt.tight_layout(w_pad=-1)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1754]:
:END:

** nrl5 adcp near-inertial
#+BEGIN_SRC ipython :session :ipyfile images/nrl5-near-inertial-adcp.png
#from dcpy.ts import xfilter
#f,  axx = plt.subplots(3, 1, sharex=True)
# ax = dict(Kt=axx[0], u=axx[1], v=axx[2])
# (nrl5.KT.isel(depth=1)
# .sel(**nrl5.select_region(['Storm+IW'])).plot(ax=ax['Kt']))
# ax['KT'].set_yscale('log')
# axv
with plt.rc_context({'font.size': 14}):
    ax, hc = nrl5.PlotVel(region='Storm+IW')
    ax['u'].set_ylim([250, 0])
    ax['v'].set_ylim([250, 0])
    ax['v'].set_xlabel('')

arrowprops = dict(arrowstyle="<-", connectionstyle="arc3")

hanno.remove()
hanno = ax['v'].annotate("",
                       xy=('2014-07-18', 70), xycoords='data',
                       xytext=('2014-08-7', 150), textcoords='data',
                       arrowprops=arrowprops)
#+END_SRC
#+RESULTS:
:RESULTS:
# Out[1681]:
[[file:images/nrl5-near-inertial-adcp.png]]
:END:

** χpod depths on ARGO climatology
#+BEGIN_SRC ipython :session :ipyfile images/argo-clim-χpod-depths.png
with plt.rc_context({'font.size': 15,
                     'axes.facecolor': 'white',
                     'savefig.transparent': False}):

   bay.mark_χpod_depths_on_clim()
   plt.gcf().set_size_inches(8, 6)
   plt.savefig('images/argo-clim-χpod-depths.svg')

#+END_SRC
#+RESULTS:
:RESULTS:
# Out[16]:
[[file:images/argo-clim-χpod-depths.png]]
:END:

* sampling considerations
** ISO signals
Can I  see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+BEGIN_SRC ipython :session :ipyfile images/temp/img3907IKt.png
dt = 1  # day
N = 365  # number of days
smth = [1, 2, 3, 4, 5]  # nsmooth
periods = np.array([10.0, 20.0, 30.0, 50.0, 60.0, 90.0])  # peaks

ax = []
ax.append(plt.subplot(211))
ax.append(plt.subplot(212))

t = np.arange(N)
ts = dcpy.ts.synthetic(N, dt, 1, -3)

for tt in periods:
    ts += 1e3 * np.sin(2*3.14/tt * t)

for ss in smth:
    dcpy.ts.PlotSpectrum(ts, ax=ax[0], scale=5**-ss,
                         nsmooth=ss, label=str(ss))
    dcpy.ts.PlotSpectrum(ts, ax=ax[1], scale=5**-ss,
                         nsmooth=ss, label=str(ss),
                         multitaper=True)

ax[0].set_title('Varying smoothing | ' + str(N) + ' day daily timeseries')
ax[1].set_title('multitaper')
plt.legend()
# dcpy.ts.PlotSpectrum(ts, nsmooth=smth, multitaper=True)
dcpy.plots.linex(1/periods)
#+END_SRC
#+CAPTION: Can I see a 10/20/30/50/60/90 day peak confidently in a year-long record?
#+RESULTS:
[[file:../images//temp/img3907IKt.png]]o
** χpod depths for RAMA17

#+name: read-rama-10m
#+BEGIN_SRC ipython :session :results none
import xarray as xr
import pandas as pd

rama10 = xr.open_mfdataset('rama/data/t*90e_10m.cdf', autoclose=True)
salhr = xr.open_mfdataset('rama/data/s[0-9]*90e_hr.cdf', autoclose=True)

newtrange = pd.date_range(start=rama10.time.values.min(),
                          end=rama10.time.values.max(), freq='10min')
#+END_SRC

#+call: read-rama-10m()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427kYC.png
# ra12 = xr.open_dataset('rama/data/t12n90e_10m.cdf', autoclose=True)
T = rama10.T_20.sel(depth=[10, 20, 40, 60])
T = T.reindex({'time': newtrange})
T = T.where(T < 40).squeeze()
Tz = -T.diff(dim='depth')/T.depth.diff(dim='depth')
Tz['depth'] = (T.depth.values[:-1] + T.depth.values[1:])/2
Tz.name = '$T_z$'

S = salhr.S_41.sel(lat=12, depth=[10, 20, 40, 60])
S = S.reindex({'time': pd.date_range(start=S.time.values.min(),
                                     end=S.time.values.max(), freq='1H')})
S = S.where(S < 40).squeeze()
Sz = -S.diff(dim='depth')/S.depth.diff(dim='depth')
Sz.name = '$S_z$'

N2 = -9.81 * (-1.7e-4 * Tz + 7.6e-4 * Sz)
#+END_SRC

#+RESULTS:
[[file:images/temp/img10427kYC.png]]

#+BEGIN_SRC ipython :session :ipyfile images/min-Tz-rama.png
min_Tz = 1e-3

def count(x):
    return (x.where(np.abs(x) < 1e-3).count(dim='time'))/x.count(dim='time')*100

lat = [15, 12, 8, 4, 0]

f, ax = plt.subplots(len(lat), 1, sharex=True, sharey=True)

for (axx, ll) in zip(ax, lat):
    dcpy.plots.offset_line_plot(Tz.sel(lat=ll)
                                .groupby('time.dayofyear')
                                .apply(count),
                                x='dayofyear', y='depth',
                                offset=0, remove_mean=False, ax=axx)
    axx.set_title(str(ll)+'N')

f.suptitle('% observations in a day with $T_z$ < 1e-3', y=1.05)
ax[0].set_ylim([0, 100])

ax[-1].set_xlabel('day of year')

plt.tight_layout()
plt.gcf().set_size_inches((6.5, 6.5))
#+END_SRC
#+CAPTION: How likely is it that we can compute χ for an instrument at 30m vs instrument at 45m
#+RESULTS:
[[file:images/min-Tz-rama.png]]

[[file:images/li-et-al-may-oct-mld.png]]

#+call: read-ra12()

#+BEGIN_SRC ipython :session :ipyfile images/temp/img10427SMu.png

#+END_SRC
* χ processing
** Winters & D'Asaro methodology
*** Smyth et al 2001
As of now, it looks like the Smyth approach is to use a single value for a patch. The Winters & D'Asaro approach is the "high resolution" version I guess.
*** Convection
*** determining sign
1. Use mooring dT/dz (10-20m scale)
2. Use sign of hourly moving median (6 points).
3. For |dT/dz| < 1e-3; use sign of two hourly median

[[file:~/work/bay/images/wda-tz-sign.png]]

[[file:~/work/bay/images/wda-tz-sign-2.png]]

*** noise levels
The differentiator uses the /analog/ signal as input; so it never differentaties bit-noise in T. i.e. the noise floor in Tp and T are _different._

~chi_chi_proc~ checks for Tp noise floor.

When doing the WDA estimate, I need to check for the T noise floor when sorting temperature.
*** Use just the sorted gradient or re-evalute with mooring gradient?
[[file:images/wda-Jq-comparison.png]]
** really low turbulence

- instrument is being pumped through what looks like really quiet layers.
- 15 sec period roughly : signal is also seen in pressure time series.

[[file:images/518-low-turbulence.png]]
#+CAPTION: zoom-in of first image
[[file:images/518-low-turbulence-zoom-1.png]]
#+CAPTION: zoom-in of first image
[[file:images/518-low-turbulence-zoom-2.png]]
** 1 sec IC fits
Use 526 2017-07-06 to test: this has kstart, kstop, ki saved for the entire year.

1. I can get ~k_stop~ decently well in ~combine_turbulence~. Not doing that well with ~k_start.~
2. Part of the reason is that I'm not actually getting k_b right which is mystifying.
3. If I can do ~k_start~ I can also check how many points are in fitting range.
   1. Though really, I should redo all calculations :(.

#+CAPTION: Comparing estimated k_b with saved k_b. Why is this wrong?!  This might be because chi, epsilon is recalculated right at the end but the k_b I saved was not.
[[file:images/526-k_b-est-saved.png]]

#+CAPTION: This figure show histograms of ε when k_i > k_{stop}. It compares one where I estimate kstop and other where kstop was saved during iterations.
[[file:images/526-eps-ki-filter-hist.png]]

#+CAPTION: Here I compare ε distributions after when k_i < k_stop (straddling the transition) and k_i < k_start (always in vc range). These use the saved ranges.
[[file:images/526-chi-ki-filtering.png]]
** using pressure instead of accelerometer

Tested with RAMA14-810
#+CAPTION: Δp is quantized! Bit resolution ≈ 2 cm. I smooth over 0.5 seconds.
[[file:images/810-p-velz-a-velz.png]]

#+ATTR_HTML: :width 50%
#+CAPTION: Agrees with Perlin & Moum (2012), though here $dp/dt$ is smaller.
[[file:images/810-compare-spd.png]]
#+CAPTION: mean/median larger by a factor of 2 (only tested for 20-Feb-2015)
[[file:images/810-compare-chi-eps.png]]

#+CAPTION: slope ≈ 1.5 (only tested for 20-Feb-2015)
[[file:images/810-compare-hist2-chi-eps.png]]

bibliography:~/Papers/bibtexLibrary.bib
* Paper figures
** summary paper
*** Figure 1: map + depths on argo climatology
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgeMzvg3.png
import cartopy.crs as ccrs

with plt.rc_context({'font.size': 11,
                     'axes.facecolor': 'white',
                     'savefig.transparent': False}):

    f = plt.figure(constrained_layout=True)

    n=3
    n0=2
    # gs = mpl.gridspec.GridSpec(2, n, figure=f)
    # ax1 = f.add_subplot(gs[:, :n0], projection=ccrs.PlateCarree())
    # ax2 = f.add_subplot(gs[0, n0:])
    # ax3 = f.add_subplot(gs[1, n0:])

    gs = mpl.gridspec.GridSpec(n, 2, figure=f)
    ax1 = f.add_subplot(gs[:n0, :], projection=ccrs.PlateCarree())
    ax2 = f.add_subplot(gs[n0:, 0])
    ax3 = f.add_subplot(gs[n0:, 1])

    f.set_size_inches((4.75, 8))

    bay.make_labeled_map(ax=ax1)
    bay.mark_χpod_depths_on_clim(ax=[ax2, ax3])

    for label, ax in zip(['a', 'b', 'c'], [ax1, ax2, ax3]):
        ax.text(0.025, 0.05, label+')', transform=ax.transAxes,
                fontsize='medium')

    [tt.set_rotation(30) for tt in ax1.get_xticklabels()]
    ax3.set_ylabel('')
    ax3.set_yticklabels([])

    plt.savefig('images/paper1/map.pdf', bbox_inches='tight')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[140]:
:END:
*** RAMA vs NRL
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgcqnSXp.png
def full_extent(ax, pad=0.0):
    """Get the full extent of an axes, including axes labels, tick labels, and
    titles."""

    from matplotlib.transforms import Bbox
    # For text objects, we need to draw the figure first, otherwise the extents
    # are undefined.
    ax.figure.canvas.draw()
    items = [ax, ax.title, ax.xaxis.label, ax.yaxis.label]
    items += (ax.get_xticklabels() + ax.get_yticklabels())
    bbox = Bbox.union([item.get_window_extent() for item in items])

    return bbox.expanded(1.0 + pad, 1.0 + pad)

def mark_location(ax, KT, label, color):
    kt = (KT.sel(time='2014')
          .resample(time='D').mean(dim='time'))

    hdl_point = ax.plot(kt.time[-1], kt[-1],
                        'o', ms=4, color=color, clip_on=False)
    hdl_text = ax.text('2014-12-31', kt[-1], '  '+label, ha='left',
                       clip_on=False, color=color)

    return hdl_point, hdl_text


f, axx = plt.subplots(3, 1, sharex=True, constrained_layout=True)

ax, hkr = ra12.met_turb_summary(region={'time': '2014', 'depth': 15},
                                ax=axx[:2])
axn, hkn = nrl5.met_turb_summary(region={'time': '2014', 'depth': 104.0},
                                 ax=[axx[2], axx[1]])

hdl_pointr, hdl_textr = mark_location(axx[1], ra12.KT.isel(depth=0),
                                      label='12N 15m',
                                      color=hkr[0].get_color())

hdl_pointn, hdl_textb = mark_location(axx[1], nrl5.KT.isel(depth=1),
                                      label='8N 104m',
                                      color=hkn[0].get_color())

htxt = []
htxt.append(
    ax['met'].text('2014-02-01', 0.35, 'NE', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-04-15', 0.35, 'NESW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-07-16', 0.35, 'SW', va='bottom', zorder=-1)
)
htxt.append(
    ax['met'].text('2014-10-20', 0.35, 'SWNE', va='bottom', zorder=-1)
)

ax['met'].set_xlim(('2014-01', '2015-01'))
ax['met'].set_ylim([0, 0.35])
ax['Kt'].xaxis.set_major_formatter(mpl.dates.DateFormatter('%b-%d'))
ax['Kt'].set_xlabel('2014')
ax['Kt'].set_ylabel('Daily avg. \n $K_T$ [m²/s]')
ax['Kt'].grid(False, axis='x')
ax['Kt'].grid(True, which='both', axis='y')
[aa.set_xlabel('') for aa in axx]
axx[2].xaxis.set_tick_params(rotation=0)
f.set_size_inches((7, 4.25))

plt.savefig('images/paper1/rama-vs-nrl.pdf', bbox_inches='tight')

# arrowprops = dict(arrowstyle="<->", connectionstyle="arc3")
# ha1 = ax['Kt'].annotate("",
#                         xy=('2014-04-15', 5e-5), xycoords='data',
#                         xytext=('2014-04-15', 1), textcoords='data',
#                         arrowprops=arrowprops)
# ha2 = ax['Kt'].annotate("",
#                         xy=('2014-07-15', 5e-3), xycoords='data',
#                         xytext=('2014-07-15', 1), textcoords='data',
#                         arrowprops=arrowprops)
# ha3 = ax['Kt'].annotate("",
#                         xy=('2014-10-9', 5e-2), xycoords='data',
#                         xytext=('2014-10-9', 10), textcoords='data',
#                         arrowprops=arrowprops)


# for ha in [ha1, ha2, ha3]:
#     ha.set_visible(False)

# ha = []
# arrowprops = dict(arrowstyle="->", connectionstyle="arc3")
# ha.append(ax['Kt'].annotate("near-molecular!",
#                        xytext=('2014-04-01', 7e-6), xycoords='data',
#                        xy=('2014-04-15', 2e-7), textcoords='data',
#                             arrowprops=arrowprops, ha='right'))

# plt.gcf().set_size_inches((6, 3.25))
# plt.savefig('images/rama-vs-nrl-1.png', bbox_inches='tight')

# extent = full_extent(ax['Kt']).transformed(f.transFigure.inverted())
# # We can now make the rectangle in figure coords using the "transform" kwarg.
# rect = mpl.patches.Rectangle([extent.xmin, extent.ymin],
#                              extent.width, extent.height,
#                              facecolor='yellow', edgecolor='none', zorder=-1,
#                              transform=fig.transFigure)
# f.patches.append(rect)

# ax['Jq0'].set_visible(False)
# ax['met'].set_visible(False)



#+END_SRC
*** Vertical profile
*** Seasonal spatial variations
#+BEGIN_SRC ipython :session :ipyfile images/temp/imgGiGXBs.png

bay = importlib.reload(bay)

import cartopy.crs as ccrs

if 'ssha' not in locals():
    ssha = (xr.open_dataset('../datasets/ssh/'
                            + 'dataset-duacs-rep-global-merged-allsat-phy-l4-v3_1522711420825.nc',
                            autoclose=True)
            .sel(time='2014')
            .load())
    ssha['EKE'] = 0.5 * (ssha.ugosa**2 + ssha.vgosa**2)
    eke = (ssha.EKE.groupby(ssha.EKE.time.monsoon.labels)
           .mean(dim='time'))

if 'tropflux' not in locals():
    tropflux = (xr.open_mfdataset('../datasets/tropflux/tau*_tropflux_1d_*.nc',
                                  autoclose=True)
                .drop('tau')
                .sel(time='2014',
                     latitude=slice(2, 25),
                     longitude=slice(78, 96))
                .load())
    tropflux = (tropflux.groupby(tropflux.time.monsoon.labels)
                .mean(dim='time'))

if 'trmm' not in locals():
    trmm = (dcpy.oceans.read_trmm()
            .sel(time='2014',
                 lat=slice(2, 25),
                 lon=slice(78, 96)))
    trmm = (trmm.groupby(trmm.time.monsoon.labels)
            .sum(dim='time'))

def make_insets(ax):
    insets = dict()

    kwargs = dict(transform=ax.transData, zorder=6)

    with plt.rc_context({'axes.facecolor': 'w'}):
        insets['ra12'] = ax.inset_axes([96, 10.5, 5, 3],
                                       ,**kwargs)
        insets['ra15'] = ax.inset_axes([96, 14, 5, 3],
                                       ,**kwargs)
        insets['nrl5'] = ax.inset_axes([96, 6.5, 5, 3],
                                       ,**kwargs)

        insets['nrl1'] = ax.inset_axes([75, 3, 5, 3],
                                       ,**kwargs)

        insets['nrl3'] = ax.inset_axes([75, 8.5, 5, 3],
                                       ,**kwargs)

        insets['nrl4'] = ax.inset_axes([75, 13, 5, 3],
                                       ,**kwargs)


        ax.indicate_inset([nrl4.lon-0.25, nrl4.lat-0.25, 0.5, 0.5],
                          inset_ax=insets['nrl4'],
                          transform=ax.transData)

        ax.indicate_inset([nrl3.lon-0.25, nrl3.lat-0.25, 0.5, 0.5],
                          inset_ax=insets['nrl3'],
                          transform=ax.transData)


    return insets


def clean_inset_axes(ax):
    ax.set_ylabel('')
    ax.set_xlabel('')
    ax.set_xlim([-7, -1])
    ax.set_title('')
    ax.set_yticks([])
    ax.set_yticklabels([])
    ax.spines['left'].set_visible(False)

N = 200
cmap = mpl.cm.GnBu(np.arange(N))
cmap[:, -1] = np.linspace(0.25, 0.5, N)
ppt_cmap = mpl.colors.ListedColormap(cmap[60:])

f, ax = plt.subplots(4, 1, constrained_layout=True,
                     subplot_kw={'projection':ccrs.PlateCarree()})
f.set_size_inches((4, 10))

axes = dict()
# axes['NE'] = ax[0, 0]
# axes['NESW'] = ax[0, 1]
# axes['SW'] = ax[1, 0]
# axes['SWNE'] = ax[1, 1]

axes['NE'] = ax[0]
axes['NESW'] = ax[1]
axes['SW'] = ax[2]
axes['SWNE'] = ax[3]

insets = dict()

for season in axes:
    hdl = (eke.sel(monsoon=season)
           .plot.contourf(ax=axes[season], x='longitude', y='latitude',
                          cmap=mpl.cm.OrRd,
                          levels=np.linspace(8e-3, 0.25, 40),
                          add_colorbar=False))

    hq = axes[season].quiver(tropflux.longitude, tropflux.latitude,
                             tropflux.taux.sel(monsoon=season),
                             tropflux.tauy.sel(monsoon=season),
                             scale=1,
                             zorder=5)

    ppt = trmmm.sel(monsoon=season).precipitation
    (ppt.where(ppt > 300)
     .plot.contourf(ax=axes[season], x='lon', y='lat',
                    levels=np.arange(300, 2000, 300),
                    cmap=ppt_cmap, zorder=4, add_colorbar=False))

    axes[season].set_title('')

    axes[season].text(0.1, 0.9, season,
                      transform=axes[season].transAxes,
                      color='k', zorder=10)


    bay.plot_coastline(ax=axes[season])
    axes[season].set_extent([78, 96, 2, 20])
    bay.mark_moors(ax=axes[season], color='k')
    insets[season] = make_insets(axes[season])

axes[season].quiverkey(hq, 0.1, 0.01, 0.1, label='0.1 N/m²',
                       coordinates='figure')

for mname, moor in zip(['ra12', 'ra15', 'nrl5'],
                       [ra12, ra15, nrl5]):
    grouped = moor.KT.groupby(moor.KT.time.monsoon.labels)

    for season, subset in grouped:
        for zz in subset.depth:
            hdl = (np.log10(subset.sel(depth=zz))
                   .resample(time='H').mean(dim='time')
                   .plot.hist(ax=insets[season][mname],
                              density=True,
                              bins=60,
                              histtype='step'))

        clean_inset_axes(insets[season][mname])

for season in ['NE', 'NESW', 'SW', 'SWNE']:
    insets[season]['ra15'].set_xticklabels([])
    insets[season]['ra12'].set_xticklabels([])
    insets[season]['nrl3'].set_xticklabels([])
    insets[season]['nrl4'].set_xticklabels([])
#+END_SRC

#+BEGIN_SRC ipython :session :ipyfile images/temp/imgOZW81M.png


# import pycpt

# ppt_cmap = pycpt.load.gmtColormap('/home/deepak/Downloads/blues.cpt')

cmap = mpl.cm.GnBu(np.arange(120))
cmap[:, -1] = np.linspace(0.3, 0.6, 120)
ppt_cmap = mpl.colors.ListedColormap(cmap)

trmmm.sel(monsoon='SW').precipitation.plot.contourf(x='lon',
                                                    y='lat',
                                                    robust=True,
                                                    cmap=ppt_cmap)
#+END_SRC
